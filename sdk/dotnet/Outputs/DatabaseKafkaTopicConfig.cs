// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.DigitalOcean.Outputs
{

    [OutputType]
    public sealed class DatabaseKafkaTopicConfig
    {
        /// <summary>
        /// The topic cleanup policy that decribes whether messages should be deleted, compacted, or both when retention policies are violated.
        /// This may be one of "delete", "compact", or "compact_delete".
        /// </summary>
        public readonly string? CleanupPolicy;
        /// <summary>
        /// The topic compression codecs used for a given topic.
        /// This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        /// </summary>
        public readonly string? CompressionType;
        /// <summary>
        /// The amount of time, in ms, that deleted records are retained.
        /// </summary>
        public readonly string? DeleteRetentionMs;
        /// <summary>
        /// The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        /// </summary>
        public readonly string? FileDeleteDelayMs;
        /// <summary>
        /// The number of messages accumulated on a topic partition before they are flushed to disk.
        /// </summary>
        public readonly string? FlushMessages;
        /// <summary>
        /// The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        /// </summary>
        public readonly string? FlushMs;
        /// <summary>
        /// The interval, in bytes, in which entries are added to the offset index.
        /// </summary>
        public readonly string? IndexIntervalBytes;
        /// <summary>
        /// The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        /// </summary>
        public readonly string? MaxCompactionLagMs;
        /// <summary>
        /// The maximum size, in bytes, of a message.
        /// </summary>
        public readonly string? MaxMessageBytes;
        /// <summary>
        /// Determines whether down-conversion of message formats for consumers is enabled.
        /// </summary>
        public readonly bool? MessageDownConversionEnable;
        /// <summary>
        /// The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        /// </summary>
        public readonly string? MessageFormatVersion;
        /// <summary>
        /// The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        /// </summary>
        public readonly string? MessageTimestampDifferenceMaxMs;
        /// <summary>
        /// Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        /// </summary>
        public readonly string? MessageTimestampType;
        /// <summary>
        /// A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        /// </summary>
        public readonly double? MinCleanableDirtyRatio;
        public readonly string? MinCompactionLagMs;
        /// <summary>
        /// The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful.
        /// </summary>
        public readonly int? MinInsyncReplicas;
        /// <summary>
        /// Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        /// </summary>
        public readonly bool? Preallocate;
        /// <summary>
        /// The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        /// </summary>
        public readonly string? RetentionBytes;
        /// <summary>
        /// The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        /// </summary>
        public readonly string? RetentionMs;
        /// <summary>
        /// The maximum size, in bytes, of a single topic log file.
        /// </summary>
        public readonly string? SegmentBytes;
        /// <summary>
        /// The maximum size, in bytes, of the offset index.
        /// </summary>
        public readonly string? SegmentIndexBytes;
        /// <summary>
        /// The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        /// </summary>
        public readonly string? SegmentJitterMs;
        /// <summary>
        /// The maximum time, in ms, before the topic log will flush to disk.
        /// </summary>
        public readonly string? SegmentMs;
        /// <summary>
        /// Determines whether to allow nodes that are not part of the in-sync replica set (IRS) to be elected as leader. Note: setting this to "true" could result in data loss.
        /// </summary>
        public readonly bool? UncleanLeaderElectionEnable;

        [OutputConstructor]
        private DatabaseKafkaTopicConfig(
            string? cleanupPolicy,

            string? compressionType,

            string? deleteRetentionMs,

            string? fileDeleteDelayMs,

            string? flushMessages,

            string? flushMs,

            string? indexIntervalBytes,

            string? maxCompactionLagMs,

            string? maxMessageBytes,

            bool? messageDownConversionEnable,

            string? messageFormatVersion,

            string? messageTimestampDifferenceMaxMs,

            string? messageTimestampType,

            double? minCleanableDirtyRatio,

            string? minCompactionLagMs,

            int? minInsyncReplicas,

            bool? preallocate,

            string? retentionBytes,

            string? retentionMs,

            string? segmentBytes,

            string? segmentIndexBytes,

            string? segmentJitterMs,

            string? segmentMs,

            bool? uncleanLeaderElectionEnable)
        {
            CleanupPolicy = cleanupPolicy;
            CompressionType = compressionType;
            DeleteRetentionMs = deleteRetentionMs;
            FileDeleteDelayMs = fileDeleteDelayMs;
            FlushMessages = flushMessages;
            FlushMs = flushMs;
            IndexIntervalBytes = indexIntervalBytes;
            MaxCompactionLagMs = maxCompactionLagMs;
            MaxMessageBytes = maxMessageBytes;
            MessageDownConversionEnable = messageDownConversionEnable;
            MessageFormatVersion = messageFormatVersion;
            MessageTimestampDifferenceMaxMs = messageTimestampDifferenceMaxMs;
            MessageTimestampType = messageTimestampType;
            MinCleanableDirtyRatio = minCleanableDirtyRatio;
            MinCompactionLagMs = minCompactionLagMs;
            MinInsyncReplicas = minInsyncReplicas;
            Preallocate = preallocate;
            RetentionBytes = retentionBytes;
            RetentionMs = retentionMs;
            SegmentBytes = segmentBytes;
            SegmentIndexBytes = segmentIndexBytes;
            SegmentJitterMs = segmentJitterMs;
            SegmentMs = segmentMs;
            UncleanLeaderElectionEnable = uncleanLeaderElectionEnable;
        }
    }
}
