// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package digitalocean

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a DigitalOcean database logsink resource allowing you to forward logs from a managed database cluster to an external OpenSearch cluster or Elasticsearch endpoint.
//
// This resource is compatible with both OpenSearch and Elasticsearch endpoints due to API compatibility. You can use this resource to connect to either service.
//
// This resource supports the following DigitalOcean managed database engines:
//
// * PostgreSQL
// * MySQL
// * Kafka
// * Valkey
//
// **Note**: MongoDB databases use a different log forwarding mechanism and require Datadog logsinks (not currently available in this provider).
//
// ## Example Usage
//
// ### Basic OpenSearch configuration
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			postgres_example, err := digitalocean.NewDatabaseCluster(ctx, "postgres-example", &digitalocean.DatabaseClusterArgs{
//				Name:      pulumi.String("example-postgres-cluster"),
//				Engine:    pulumi.String("pg"),
//				Version:   pulumi.String("15"),
//				Size:      pulumi.String(digitalocean.DatabaseSlug_DB_1VPCU1GB),
//				Region:    pulumi.String(digitalocean.RegionNYC1),
//				NodeCount: pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = digitalocean.NewDatabaseLogsinkOpensearch(ctx, "example", &digitalocean.DatabaseLogsinkOpensearchArgs{
//				ClusterId:    postgres_example.ID(),
//				Name:         pulumi.String("opensearch-logs"),
//				Endpoint:     pulumi.String("https://opensearch.example.com:9200"),
//				IndexPrefix:  pulumi.String("db-logs"),
//				IndexDaysMax: pulumi.Int(7),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### OpenSearch with authentication and CA certificate
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean"
//	"github.com/pulumi/pulumi-std/sdk/go/std"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			invokeFile, err := std.File(ctx, &std.FileArgs{
//				Input: "/path/to/ca.pem",
//			}, nil)
//			if err != nil {
//				return err
//			}
//			_, err = digitalocean.NewDatabaseLogsinkOpensearch(ctx, "example-secure", &digitalocean.DatabaseLogsinkOpensearchArgs{
//				ClusterId:      pulumi.Any(postgres_example.Id),
//				Name:           pulumi.String("opensearch-secure"),
//				Endpoint:       pulumi.String("https://user:password@opensearch.example.com:9200"),
//				IndexPrefix:    pulumi.String("secure-logs"),
//				IndexDaysMax:   pulumi.Int(14),
//				CaCert:         pulumi.String(invokeFile.Result),
//				TimeoutSeconds: pulumi.Int(30),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### Elasticsearch endpoint configuration
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := digitalocean.NewDatabaseLogsinkOpensearch(ctx, "elasticsearch", &digitalocean.DatabaseLogsinkOpensearchArgs{
//				ClusterId:    pulumi.Any(postgres_example.Id),
//				Name:         pulumi.String("elasticsearch-logs"),
//				Endpoint:     pulumi.String("https://elasticsearch.example.com:9243"),
//				IndexPrefix:  pulumi.String("es-logs"),
//				IndexDaysMax: pulumi.Int(30),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ### MySQL to OpenSearch configuration
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			mysql_example, err := digitalocean.NewDatabaseCluster(ctx, "mysql-example", &digitalocean.DatabaseClusterArgs{
//				Name:      pulumi.String("example-mysql-cluster"),
//				Engine:    pulumi.String("mysql"),
//				Version:   pulumi.String("8"),
//				Size:      pulumi.String(digitalocean.DatabaseSlug_DB_1VPCU1GB),
//				Region:    pulumi.String(digitalocean.RegionNYC1),
//				NodeCount: pulumi.Int(1),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = digitalocean.NewDatabaseLogsinkOpensearch(ctx, "mysql", &digitalocean.DatabaseLogsinkOpensearchArgs{
//				ClusterId:    mysql_example.ID(),
//				Name:         pulumi.String("mysql-logs"),
//				Endpoint:     pulumi.String("https://opensearch.example.com:9200"),
//				IndexPrefix:  pulumi.String("mysql-logs"),
//				IndexDaysMax: pulumi.Int(7),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Important Notes
//
// ### Elasticsearch Compatibility
// This resource works with both OpenSearch and Elasticsearch endpoints due to their API compatibility. Use the same resource type regardless of whether you're connecting to OpenSearch or Elasticsearch.
//
// ### Managed OpenSearch with Trusted Sources
// When forwarding logs to a DigitalOcean Managed OpenSearch cluster with trusted sources enabled, you must manually allow-list the IP addresses of your database cluster nodes.
//
// ### Authentication
// Include authentication credentials directly in the endpoint URL using the format `https://username:password@host:port`. Alternatively, configure authentication on your OpenSearch/Elasticsearch cluster to accept connections from your database cluster's IP addresses.
//
// ## Import
//
// Database logsink OpenSearch resources can be imported using the composite ID format `cluster_id,logsink_id`. For example:
//
// ```sh
// $ pulumi import digitalocean:index/databaseLogsinkOpensearch:DatabaseLogsinkOpensearch example 245bcfd0-7f31-4ce6-a2bc-475a116cca97,f38db7c8-1f31-4ce6-a2bc-475a116cca97
// ```
//
// **Note**: The cluster ID and logsink ID must be separated by a comma.
type DatabaseLogsinkOpensearch struct {
	pulumi.CustomResourceState

	// CA certificate for TLS verification in PEM format. Can be specified using `file()` function. This field is marked as sensitive.
	CaCert pulumi.StringPtrOutput `pulumi:"caCert"`
	// UUID of the source database cluster that will forward logs.
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// HTTPS URL to the OpenSearch or Elasticsearch cluster (e.g., `https://host:port`). **Note**: Only HTTPS URLs are supported.
	Endpoint pulumi.StringOutput `pulumi:"endpoint"`
	// Maximum number of days to retain indices. Must be 1 or greater.
	IndexDaysMax pulumi.IntPtrOutput `pulumi:"indexDaysMax"`
	// Prefix for the indices where logs will be stored.
	IndexPrefix pulumi.StringOutput `pulumi:"indexPrefix"`
	// The unique identifier for the logsink as returned by the DigitalOcean API.
	LogsinkId pulumi.StringOutput `pulumi:"logsinkId"`
	// Display name for the logsink. **Note**: This is immutable; changing it will force recreation of the resource.
	Name pulumi.StringOutput `pulumi:"name"`
	// Request timeout for log deliveries in seconds. Must be 1 or greater.
	TimeoutSeconds pulumi.IntPtrOutput `pulumi:"timeoutSeconds"`
}

// NewDatabaseLogsinkOpensearch registers a new resource with the given unique name, arguments, and options.
func NewDatabaseLogsinkOpensearch(ctx *pulumi.Context,
	name string, args *DatabaseLogsinkOpensearchArgs, opts ...pulumi.ResourceOption) (*DatabaseLogsinkOpensearch, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.Endpoint == nil {
		return nil, errors.New("invalid value for required argument 'Endpoint'")
	}
	if args.IndexPrefix == nil {
		return nil, errors.New("invalid value for required argument 'IndexPrefix'")
	}
	if args.CaCert != nil {
		args.CaCert = pulumi.ToSecret(args.CaCert).(pulumi.StringPtrInput)
	}
	secrets := pulumi.AdditionalSecretOutputs([]string{
		"caCert",
	})
	opts = append(opts, secrets)
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DatabaseLogsinkOpensearch
	err := ctx.RegisterResource("digitalocean:index/databaseLogsinkOpensearch:DatabaseLogsinkOpensearch", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDatabaseLogsinkOpensearch gets an existing DatabaseLogsinkOpensearch resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDatabaseLogsinkOpensearch(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DatabaseLogsinkOpensearchState, opts ...pulumi.ResourceOption) (*DatabaseLogsinkOpensearch, error) {
	var resource DatabaseLogsinkOpensearch
	err := ctx.ReadResource("digitalocean:index/databaseLogsinkOpensearch:DatabaseLogsinkOpensearch", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DatabaseLogsinkOpensearch resources.
type databaseLogsinkOpensearchState struct {
	// CA certificate for TLS verification in PEM format. Can be specified using `file()` function. This field is marked as sensitive.
	CaCert *string `pulumi:"caCert"`
	// UUID of the source database cluster that will forward logs.
	ClusterId *string `pulumi:"clusterId"`
	// HTTPS URL to the OpenSearch or Elasticsearch cluster (e.g., `https://host:port`). **Note**: Only HTTPS URLs are supported.
	Endpoint *string `pulumi:"endpoint"`
	// Maximum number of days to retain indices. Must be 1 or greater.
	IndexDaysMax *int `pulumi:"indexDaysMax"`
	// Prefix for the indices where logs will be stored.
	IndexPrefix *string `pulumi:"indexPrefix"`
	// The unique identifier for the logsink as returned by the DigitalOcean API.
	LogsinkId *string `pulumi:"logsinkId"`
	// Display name for the logsink. **Note**: This is immutable; changing it will force recreation of the resource.
	Name *string `pulumi:"name"`
	// Request timeout for log deliveries in seconds. Must be 1 or greater.
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

type DatabaseLogsinkOpensearchState struct {
	// CA certificate for TLS verification in PEM format. Can be specified using `file()` function. This field is marked as sensitive.
	CaCert pulumi.StringPtrInput
	// UUID of the source database cluster that will forward logs.
	ClusterId pulumi.StringPtrInput
	// HTTPS URL to the OpenSearch or Elasticsearch cluster (e.g., `https://host:port`). **Note**: Only HTTPS URLs are supported.
	Endpoint pulumi.StringPtrInput
	// Maximum number of days to retain indices. Must be 1 or greater.
	IndexDaysMax pulumi.IntPtrInput
	// Prefix for the indices where logs will be stored.
	IndexPrefix pulumi.StringPtrInput
	// The unique identifier for the logsink as returned by the DigitalOcean API.
	LogsinkId pulumi.StringPtrInput
	// Display name for the logsink. **Note**: This is immutable; changing it will force recreation of the resource.
	Name pulumi.StringPtrInput
	// Request timeout for log deliveries in seconds. Must be 1 or greater.
	TimeoutSeconds pulumi.IntPtrInput
}

func (DatabaseLogsinkOpensearchState) ElementType() reflect.Type {
	return reflect.TypeOf((*databaseLogsinkOpensearchState)(nil)).Elem()
}

type databaseLogsinkOpensearchArgs struct {
	// CA certificate for TLS verification in PEM format. Can be specified using `file()` function. This field is marked as sensitive.
	CaCert *string `pulumi:"caCert"`
	// UUID of the source database cluster that will forward logs.
	ClusterId string `pulumi:"clusterId"`
	// HTTPS URL to the OpenSearch or Elasticsearch cluster (e.g., `https://host:port`). **Note**: Only HTTPS URLs are supported.
	Endpoint string `pulumi:"endpoint"`
	// Maximum number of days to retain indices. Must be 1 or greater.
	IndexDaysMax *int `pulumi:"indexDaysMax"`
	// Prefix for the indices where logs will be stored.
	IndexPrefix string `pulumi:"indexPrefix"`
	// Display name for the logsink. **Note**: This is immutable; changing it will force recreation of the resource.
	Name *string `pulumi:"name"`
	// Request timeout for log deliveries in seconds. Must be 1 or greater.
	TimeoutSeconds *int `pulumi:"timeoutSeconds"`
}

// The set of arguments for constructing a DatabaseLogsinkOpensearch resource.
type DatabaseLogsinkOpensearchArgs struct {
	// CA certificate for TLS verification in PEM format. Can be specified using `file()` function. This field is marked as sensitive.
	CaCert pulumi.StringPtrInput
	// UUID of the source database cluster that will forward logs.
	ClusterId pulumi.StringInput
	// HTTPS URL to the OpenSearch or Elasticsearch cluster (e.g., `https://host:port`). **Note**: Only HTTPS URLs are supported.
	Endpoint pulumi.StringInput
	// Maximum number of days to retain indices. Must be 1 or greater.
	IndexDaysMax pulumi.IntPtrInput
	// Prefix for the indices where logs will be stored.
	IndexPrefix pulumi.StringInput
	// Display name for the logsink. **Note**: This is immutable; changing it will force recreation of the resource.
	Name pulumi.StringPtrInput
	// Request timeout for log deliveries in seconds. Must be 1 or greater.
	TimeoutSeconds pulumi.IntPtrInput
}

func (DatabaseLogsinkOpensearchArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*databaseLogsinkOpensearchArgs)(nil)).Elem()
}

type DatabaseLogsinkOpensearchInput interface {
	pulumi.Input

	ToDatabaseLogsinkOpensearchOutput() DatabaseLogsinkOpensearchOutput
	ToDatabaseLogsinkOpensearchOutputWithContext(ctx context.Context) DatabaseLogsinkOpensearchOutput
}

func (*DatabaseLogsinkOpensearch) ElementType() reflect.Type {
	return reflect.TypeOf((**DatabaseLogsinkOpensearch)(nil)).Elem()
}

func (i *DatabaseLogsinkOpensearch) ToDatabaseLogsinkOpensearchOutput() DatabaseLogsinkOpensearchOutput {
	return i.ToDatabaseLogsinkOpensearchOutputWithContext(context.Background())
}

func (i *DatabaseLogsinkOpensearch) ToDatabaseLogsinkOpensearchOutputWithContext(ctx context.Context) DatabaseLogsinkOpensearchOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatabaseLogsinkOpensearchOutput)
}

// DatabaseLogsinkOpensearchArrayInput is an input type that accepts DatabaseLogsinkOpensearchArray and DatabaseLogsinkOpensearchArrayOutput values.
// You can construct a concrete instance of `DatabaseLogsinkOpensearchArrayInput` via:
//
//	DatabaseLogsinkOpensearchArray{ DatabaseLogsinkOpensearchArgs{...} }
type DatabaseLogsinkOpensearchArrayInput interface {
	pulumi.Input

	ToDatabaseLogsinkOpensearchArrayOutput() DatabaseLogsinkOpensearchArrayOutput
	ToDatabaseLogsinkOpensearchArrayOutputWithContext(context.Context) DatabaseLogsinkOpensearchArrayOutput
}

type DatabaseLogsinkOpensearchArray []DatabaseLogsinkOpensearchInput

func (DatabaseLogsinkOpensearchArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DatabaseLogsinkOpensearch)(nil)).Elem()
}

func (i DatabaseLogsinkOpensearchArray) ToDatabaseLogsinkOpensearchArrayOutput() DatabaseLogsinkOpensearchArrayOutput {
	return i.ToDatabaseLogsinkOpensearchArrayOutputWithContext(context.Background())
}

func (i DatabaseLogsinkOpensearchArray) ToDatabaseLogsinkOpensearchArrayOutputWithContext(ctx context.Context) DatabaseLogsinkOpensearchArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatabaseLogsinkOpensearchArrayOutput)
}

// DatabaseLogsinkOpensearchMapInput is an input type that accepts DatabaseLogsinkOpensearchMap and DatabaseLogsinkOpensearchMapOutput values.
// You can construct a concrete instance of `DatabaseLogsinkOpensearchMapInput` via:
//
//	DatabaseLogsinkOpensearchMap{ "key": DatabaseLogsinkOpensearchArgs{...} }
type DatabaseLogsinkOpensearchMapInput interface {
	pulumi.Input

	ToDatabaseLogsinkOpensearchMapOutput() DatabaseLogsinkOpensearchMapOutput
	ToDatabaseLogsinkOpensearchMapOutputWithContext(context.Context) DatabaseLogsinkOpensearchMapOutput
}

type DatabaseLogsinkOpensearchMap map[string]DatabaseLogsinkOpensearchInput

func (DatabaseLogsinkOpensearchMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DatabaseLogsinkOpensearch)(nil)).Elem()
}

func (i DatabaseLogsinkOpensearchMap) ToDatabaseLogsinkOpensearchMapOutput() DatabaseLogsinkOpensearchMapOutput {
	return i.ToDatabaseLogsinkOpensearchMapOutputWithContext(context.Background())
}

func (i DatabaseLogsinkOpensearchMap) ToDatabaseLogsinkOpensearchMapOutputWithContext(ctx context.Context) DatabaseLogsinkOpensearchMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatabaseLogsinkOpensearchMapOutput)
}

type DatabaseLogsinkOpensearchOutput struct{ *pulumi.OutputState }

func (DatabaseLogsinkOpensearchOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DatabaseLogsinkOpensearch)(nil)).Elem()
}

func (o DatabaseLogsinkOpensearchOutput) ToDatabaseLogsinkOpensearchOutput() DatabaseLogsinkOpensearchOutput {
	return o
}

func (o DatabaseLogsinkOpensearchOutput) ToDatabaseLogsinkOpensearchOutputWithContext(ctx context.Context) DatabaseLogsinkOpensearchOutput {
	return o
}

// CA certificate for TLS verification in PEM format. Can be specified using `file()` function. This field is marked as sensitive.
func (o DatabaseLogsinkOpensearchOutput) CaCert() pulumi.StringPtrOutput {
	return o.ApplyT(func(v *DatabaseLogsinkOpensearch) pulumi.StringPtrOutput { return v.CaCert }).(pulumi.StringPtrOutput)
}

// UUID of the source database cluster that will forward logs.
func (o DatabaseLogsinkOpensearchOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseLogsinkOpensearch) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

// HTTPS URL to the OpenSearch or Elasticsearch cluster (e.g., `https://host:port`). **Note**: Only HTTPS URLs are supported.
func (o DatabaseLogsinkOpensearchOutput) Endpoint() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseLogsinkOpensearch) pulumi.StringOutput { return v.Endpoint }).(pulumi.StringOutput)
}

// Maximum number of days to retain indices. Must be 1 or greater.
func (o DatabaseLogsinkOpensearchOutput) IndexDaysMax() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DatabaseLogsinkOpensearch) pulumi.IntPtrOutput { return v.IndexDaysMax }).(pulumi.IntPtrOutput)
}

// Prefix for the indices where logs will be stored.
func (o DatabaseLogsinkOpensearchOutput) IndexPrefix() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseLogsinkOpensearch) pulumi.StringOutput { return v.IndexPrefix }).(pulumi.StringOutput)
}

// The unique identifier for the logsink as returned by the DigitalOcean API.
func (o DatabaseLogsinkOpensearchOutput) LogsinkId() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseLogsinkOpensearch) pulumi.StringOutput { return v.LogsinkId }).(pulumi.StringOutput)
}

// Display name for the logsink. **Note**: This is immutable; changing it will force recreation of the resource.
func (o DatabaseLogsinkOpensearchOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseLogsinkOpensearch) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

// Request timeout for log deliveries in seconds. Must be 1 or greater.
func (o DatabaseLogsinkOpensearchOutput) TimeoutSeconds() pulumi.IntPtrOutput {
	return o.ApplyT(func(v *DatabaseLogsinkOpensearch) pulumi.IntPtrOutput { return v.TimeoutSeconds }).(pulumi.IntPtrOutput)
}

type DatabaseLogsinkOpensearchArrayOutput struct{ *pulumi.OutputState }

func (DatabaseLogsinkOpensearchArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DatabaseLogsinkOpensearch)(nil)).Elem()
}

func (o DatabaseLogsinkOpensearchArrayOutput) ToDatabaseLogsinkOpensearchArrayOutput() DatabaseLogsinkOpensearchArrayOutput {
	return o
}

func (o DatabaseLogsinkOpensearchArrayOutput) ToDatabaseLogsinkOpensearchArrayOutputWithContext(ctx context.Context) DatabaseLogsinkOpensearchArrayOutput {
	return o
}

func (o DatabaseLogsinkOpensearchArrayOutput) Index(i pulumi.IntInput) DatabaseLogsinkOpensearchOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DatabaseLogsinkOpensearch {
		return vs[0].([]*DatabaseLogsinkOpensearch)[vs[1].(int)]
	}).(DatabaseLogsinkOpensearchOutput)
}

type DatabaseLogsinkOpensearchMapOutput struct{ *pulumi.OutputState }

func (DatabaseLogsinkOpensearchMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DatabaseLogsinkOpensearch)(nil)).Elem()
}

func (o DatabaseLogsinkOpensearchMapOutput) ToDatabaseLogsinkOpensearchMapOutput() DatabaseLogsinkOpensearchMapOutput {
	return o
}

func (o DatabaseLogsinkOpensearchMapOutput) ToDatabaseLogsinkOpensearchMapOutputWithContext(ctx context.Context) DatabaseLogsinkOpensearchMapOutput {
	return o
}

func (o DatabaseLogsinkOpensearchMapOutput) MapIndex(k pulumi.StringInput) DatabaseLogsinkOpensearchOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DatabaseLogsinkOpensearch {
		return vs[0].(map[string]*DatabaseLogsinkOpensearch)[vs[1].(string)]
	}).(DatabaseLogsinkOpensearchOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DatabaseLogsinkOpensearchInput)(nil)).Elem(), &DatabaseLogsinkOpensearch{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatabaseLogsinkOpensearchArrayInput)(nil)).Elem(), DatabaseLogsinkOpensearchArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatabaseLogsinkOpensearchMapInput)(nil)).Elem(), DatabaseLogsinkOpensearchMap{})
	pulumi.RegisterOutputType(DatabaseLogsinkOpensearchOutput{})
	pulumi.RegisterOutputType(DatabaseLogsinkOpensearchArrayOutput{})
	pulumi.RegisterOutputType(DatabaseLogsinkOpensearchMapOutput{})
}
