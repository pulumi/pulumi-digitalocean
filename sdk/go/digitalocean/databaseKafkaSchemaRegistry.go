// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package digitalocean

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Provides a DigitalOcean Kafka schema registry for Kafka clusters.
//
// ## Example Usage
//
// ### Create a new Kafka Schema Registry
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			kafka_example, err := digitalocean.NewDatabaseCluster(ctx, "kafka-example", &digitalocean.DatabaseClusterArgs{
//				Name:      pulumi.String("example-kafka-cluster"),
//				Engine:    pulumi.String("kafka"),
//				Version:   pulumi.String("3.5"),
//				Size:      pulumi.String("gd-2vcpu-8gb"),
//				Region:    pulumi.String(digitalocean.RegionBLR1),
//				NodeCount: pulumi.Int(3),
//				Tags: pulumi.StringArray{
//					pulumi.String("production"),
//				},
//			})
//			if err != nil {
//				return err
//			}
//			_, err = digitalocean.NewDatabaseKafkaSchemaRegistry(ctx, "schema-01", &digitalocean.DatabaseKafkaSchemaRegistryArgs{
//				ClusterId:   kafka_example.ID(),
//				SubjectName: pulumi.String("test-schema"),
//				SchemaType:  pulumi.String("avro"),
//				Schema: pulumi.String(`{
//	  \"type\": \"record\",
//	  \"namespace\": \"example\",
//	  \"name\": \"TestRecord\",
//	  \"fields\": [
//	    {\"name\": \"id\", \"type\": \"string\"},
//	    {\"name\": \"name\", \"type\": \"string\"},
//	    {\"name\": \"value\", \"type\": \"int\"}
//	  ]
//	}
//
// `),
//
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
type DatabaseKafkaSchemaRegistry struct {
	pulumi.CustomResourceState

	// The ID of the target Kafka cluster.
	ClusterId pulumi.StringOutput `pulumi:"clusterId"`
	// The schema definition as a string.
	Schema pulumi.StringOutput `pulumi:"schema"`
	// The schema type. Available values are: avro, json, or protobuf.
	SchemaType pulumi.StringOutput `pulumi:"schemaType"`
	// The name of the schema subject.
	SubjectName pulumi.StringOutput `pulumi:"subjectName"`
}

// NewDatabaseKafkaSchemaRegistry registers a new resource with the given unique name, arguments, and options.
func NewDatabaseKafkaSchemaRegistry(ctx *pulumi.Context,
	name string, args *DatabaseKafkaSchemaRegistryArgs, opts ...pulumi.ResourceOption) (*DatabaseKafkaSchemaRegistry, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.ClusterId == nil {
		return nil, errors.New("invalid value for required argument 'ClusterId'")
	}
	if args.Schema == nil {
		return nil, errors.New("invalid value for required argument 'Schema'")
	}
	if args.SchemaType == nil {
		return nil, errors.New("invalid value for required argument 'SchemaType'")
	}
	if args.SubjectName == nil {
		return nil, errors.New("invalid value for required argument 'SubjectName'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource DatabaseKafkaSchemaRegistry
	err := ctx.RegisterResource("digitalocean:index/databaseKafkaSchemaRegistry:DatabaseKafkaSchemaRegistry", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetDatabaseKafkaSchemaRegistry gets an existing DatabaseKafkaSchemaRegistry resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetDatabaseKafkaSchemaRegistry(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *DatabaseKafkaSchemaRegistryState, opts ...pulumi.ResourceOption) (*DatabaseKafkaSchemaRegistry, error) {
	var resource DatabaseKafkaSchemaRegistry
	err := ctx.ReadResource("digitalocean:index/databaseKafkaSchemaRegistry:DatabaseKafkaSchemaRegistry", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering DatabaseKafkaSchemaRegistry resources.
type databaseKafkaSchemaRegistryState struct {
	// The ID of the target Kafka cluster.
	ClusterId *string `pulumi:"clusterId"`
	// The schema definition as a string.
	Schema *string `pulumi:"schema"`
	// The schema type. Available values are: avro, json, or protobuf.
	SchemaType *string `pulumi:"schemaType"`
	// The name of the schema subject.
	SubjectName *string `pulumi:"subjectName"`
}

type DatabaseKafkaSchemaRegistryState struct {
	// The ID of the target Kafka cluster.
	ClusterId pulumi.StringPtrInput
	// The schema definition as a string.
	Schema pulumi.StringPtrInput
	// The schema type. Available values are: avro, json, or protobuf.
	SchemaType pulumi.StringPtrInput
	// The name of the schema subject.
	SubjectName pulumi.StringPtrInput
}

func (DatabaseKafkaSchemaRegistryState) ElementType() reflect.Type {
	return reflect.TypeOf((*databaseKafkaSchemaRegistryState)(nil)).Elem()
}

type databaseKafkaSchemaRegistryArgs struct {
	// The ID of the target Kafka cluster.
	ClusterId string `pulumi:"clusterId"`
	// The schema definition as a string.
	Schema string `pulumi:"schema"`
	// The schema type. Available values are: avro, json, or protobuf.
	SchemaType string `pulumi:"schemaType"`
	// The name of the schema subject.
	SubjectName string `pulumi:"subjectName"`
}

// The set of arguments for constructing a DatabaseKafkaSchemaRegistry resource.
type DatabaseKafkaSchemaRegistryArgs struct {
	// The ID of the target Kafka cluster.
	ClusterId pulumi.StringInput
	// The schema definition as a string.
	Schema pulumi.StringInput
	// The schema type. Available values are: avro, json, or protobuf.
	SchemaType pulumi.StringInput
	// The name of the schema subject.
	SubjectName pulumi.StringInput
}

func (DatabaseKafkaSchemaRegistryArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*databaseKafkaSchemaRegistryArgs)(nil)).Elem()
}

type DatabaseKafkaSchemaRegistryInput interface {
	pulumi.Input

	ToDatabaseKafkaSchemaRegistryOutput() DatabaseKafkaSchemaRegistryOutput
	ToDatabaseKafkaSchemaRegistryOutputWithContext(ctx context.Context) DatabaseKafkaSchemaRegistryOutput
}

func (*DatabaseKafkaSchemaRegistry) ElementType() reflect.Type {
	return reflect.TypeOf((**DatabaseKafkaSchemaRegistry)(nil)).Elem()
}

func (i *DatabaseKafkaSchemaRegistry) ToDatabaseKafkaSchemaRegistryOutput() DatabaseKafkaSchemaRegistryOutput {
	return i.ToDatabaseKafkaSchemaRegistryOutputWithContext(context.Background())
}

func (i *DatabaseKafkaSchemaRegistry) ToDatabaseKafkaSchemaRegistryOutputWithContext(ctx context.Context) DatabaseKafkaSchemaRegistryOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatabaseKafkaSchemaRegistryOutput)
}

// DatabaseKafkaSchemaRegistryArrayInput is an input type that accepts DatabaseKafkaSchemaRegistryArray and DatabaseKafkaSchemaRegistryArrayOutput values.
// You can construct a concrete instance of `DatabaseKafkaSchemaRegistryArrayInput` via:
//
//	DatabaseKafkaSchemaRegistryArray{ DatabaseKafkaSchemaRegistryArgs{...} }
type DatabaseKafkaSchemaRegistryArrayInput interface {
	pulumi.Input

	ToDatabaseKafkaSchemaRegistryArrayOutput() DatabaseKafkaSchemaRegistryArrayOutput
	ToDatabaseKafkaSchemaRegistryArrayOutputWithContext(context.Context) DatabaseKafkaSchemaRegistryArrayOutput
}

type DatabaseKafkaSchemaRegistryArray []DatabaseKafkaSchemaRegistryInput

func (DatabaseKafkaSchemaRegistryArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DatabaseKafkaSchemaRegistry)(nil)).Elem()
}

func (i DatabaseKafkaSchemaRegistryArray) ToDatabaseKafkaSchemaRegistryArrayOutput() DatabaseKafkaSchemaRegistryArrayOutput {
	return i.ToDatabaseKafkaSchemaRegistryArrayOutputWithContext(context.Background())
}

func (i DatabaseKafkaSchemaRegistryArray) ToDatabaseKafkaSchemaRegistryArrayOutputWithContext(ctx context.Context) DatabaseKafkaSchemaRegistryArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatabaseKafkaSchemaRegistryArrayOutput)
}

// DatabaseKafkaSchemaRegistryMapInput is an input type that accepts DatabaseKafkaSchemaRegistryMap and DatabaseKafkaSchemaRegistryMapOutput values.
// You can construct a concrete instance of `DatabaseKafkaSchemaRegistryMapInput` via:
//
//	DatabaseKafkaSchemaRegistryMap{ "key": DatabaseKafkaSchemaRegistryArgs{...} }
type DatabaseKafkaSchemaRegistryMapInput interface {
	pulumi.Input

	ToDatabaseKafkaSchemaRegistryMapOutput() DatabaseKafkaSchemaRegistryMapOutput
	ToDatabaseKafkaSchemaRegistryMapOutputWithContext(context.Context) DatabaseKafkaSchemaRegistryMapOutput
}

type DatabaseKafkaSchemaRegistryMap map[string]DatabaseKafkaSchemaRegistryInput

func (DatabaseKafkaSchemaRegistryMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DatabaseKafkaSchemaRegistry)(nil)).Elem()
}

func (i DatabaseKafkaSchemaRegistryMap) ToDatabaseKafkaSchemaRegistryMapOutput() DatabaseKafkaSchemaRegistryMapOutput {
	return i.ToDatabaseKafkaSchemaRegistryMapOutputWithContext(context.Background())
}

func (i DatabaseKafkaSchemaRegistryMap) ToDatabaseKafkaSchemaRegistryMapOutputWithContext(ctx context.Context) DatabaseKafkaSchemaRegistryMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(DatabaseKafkaSchemaRegistryMapOutput)
}

type DatabaseKafkaSchemaRegistryOutput struct{ *pulumi.OutputState }

func (DatabaseKafkaSchemaRegistryOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**DatabaseKafkaSchemaRegistry)(nil)).Elem()
}

func (o DatabaseKafkaSchemaRegistryOutput) ToDatabaseKafkaSchemaRegistryOutput() DatabaseKafkaSchemaRegistryOutput {
	return o
}

func (o DatabaseKafkaSchemaRegistryOutput) ToDatabaseKafkaSchemaRegistryOutputWithContext(ctx context.Context) DatabaseKafkaSchemaRegistryOutput {
	return o
}

// The ID of the target Kafka cluster.
func (o DatabaseKafkaSchemaRegistryOutput) ClusterId() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseKafkaSchemaRegistry) pulumi.StringOutput { return v.ClusterId }).(pulumi.StringOutput)
}

// The schema definition as a string.
func (o DatabaseKafkaSchemaRegistryOutput) Schema() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseKafkaSchemaRegistry) pulumi.StringOutput { return v.Schema }).(pulumi.StringOutput)
}

// The schema type. Available values are: avro, json, or protobuf.
func (o DatabaseKafkaSchemaRegistryOutput) SchemaType() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseKafkaSchemaRegistry) pulumi.StringOutput { return v.SchemaType }).(pulumi.StringOutput)
}

// The name of the schema subject.
func (o DatabaseKafkaSchemaRegistryOutput) SubjectName() pulumi.StringOutput {
	return o.ApplyT(func(v *DatabaseKafkaSchemaRegistry) pulumi.StringOutput { return v.SubjectName }).(pulumi.StringOutput)
}

type DatabaseKafkaSchemaRegistryArrayOutput struct{ *pulumi.OutputState }

func (DatabaseKafkaSchemaRegistryArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*DatabaseKafkaSchemaRegistry)(nil)).Elem()
}

func (o DatabaseKafkaSchemaRegistryArrayOutput) ToDatabaseKafkaSchemaRegistryArrayOutput() DatabaseKafkaSchemaRegistryArrayOutput {
	return o
}

func (o DatabaseKafkaSchemaRegistryArrayOutput) ToDatabaseKafkaSchemaRegistryArrayOutputWithContext(ctx context.Context) DatabaseKafkaSchemaRegistryArrayOutput {
	return o
}

func (o DatabaseKafkaSchemaRegistryArrayOutput) Index(i pulumi.IntInput) DatabaseKafkaSchemaRegistryOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *DatabaseKafkaSchemaRegistry {
		return vs[0].([]*DatabaseKafkaSchemaRegistry)[vs[1].(int)]
	}).(DatabaseKafkaSchemaRegistryOutput)
}

type DatabaseKafkaSchemaRegistryMapOutput struct{ *pulumi.OutputState }

func (DatabaseKafkaSchemaRegistryMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*DatabaseKafkaSchemaRegistry)(nil)).Elem()
}

func (o DatabaseKafkaSchemaRegistryMapOutput) ToDatabaseKafkaSchemaRegistryMapOutput() DatabaseKafkaSchemaRegistryMapOutput {
	return o
}

func (o DatabaseKafkaSchemaRegistryMapOutput) ToDatabaseKafkaSchemaRegistryMapOutputWithContext(ctx context.Context) DatabaseKafkaSchemaRegistryMapOutput {
	return o
}

func (o DatabaseKafkaSchemaRegistryMapOutput) MapIndex(k pulumi.StringInput) DatabaseKafkaSchemaRegistryOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *DatabaseKafkaSchemaRegistry {
		return vs[0].(map[string]*DatabaseKafkaSchemaRegistry)[vs[1].(string)]
	}).(DatabaseKafkaSchemaRegistryOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*DatabaseKafkaSchemaRegistryInput)(nil)).Elem(), &DatabaseKafkaSchemaRegistry{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatabaseKafkaSchemaRegistryArrayInput)(nil)).Elem(), DatabaseKafkaSchemaRegistryArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*DatabaseKafkaSchemaRegistryMapInput)(nil)).Elem(), DatabaseKafkaSchemaRegistryMap{})
	pulumi.RegisterOutputType(DatabaseKafkaSchemaRegistryOutput{})
	pulumi.RegisterOutputType(DatabaseKafkaSchemaRegistryArrayOutput{})
	pulumi.RegisterOutputType(DatabaseKafkaSchemaRegistryMapOutput{})
}
