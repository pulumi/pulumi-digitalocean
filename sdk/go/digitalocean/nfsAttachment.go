// Code generated by pulumi-language-go DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package digitalocean

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// Manages attaching a NFS share to a vpc.
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-digitalocean/sdk/v4/go/digitalocean"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			foobar, err := digitalocean.NewVpc(ctx, "foobar", &digitalocean.VpcArgs{
//				Name:   pulumi.String("example-vpc"),
//				Region: pulumi.String("atl1"),
//			})
//			if err != nil {
//				return err
//			}
//			foobarNfs, err := digitalocean.NewNfs(ctx, "foobar", &digitalocean.NfsArgs{
//				Region: pulumi.String("atl1"),
//				Name:   pulumi.String("example-nfs"),
//				Size:   pulumi.Int(50),
//				VpcId:  foobar.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			_, err = digitalocean.NewNfsAttachment(ctx, "foobar", &digitalocean.NfsAttachmentArgs{
//				ShareId: foobarNfs.ID(),
//				VpcId:   foobar.ID(),
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Import
//
// NFS attachments can be imported using the `share_id` and `vpc_id` separated by a comma, e.g.
//
// ```sh
// $ pulumi import digitalocean:index/nfsAttachment:NfsAttachment foobar 506f78a4-e098-11e5-ad9f-000f53306ae1,d1ebc5a4-e098-11e5-ad9f-000f53306ae1
// ```
type NfsAttachment struct {
	pulumi.CustomResourceState

	Region pulumi.StringOutput `pulumi:"region"`
	// The ID of the NFS share to attach.
	ShareId pulumi.StringOutput `pulumi:"shareId"`
	// The ID of the vpc to attach the NFS share to.
	VpcId pulumi.StringOutput `pulumi:"vpcId"`
}

// NewNfsAttachment registers a new resource with the given unique name, arguments, and options.
func NewNfsAttachment(ctx *pulumi.Context,
	name string, args *NfsAttachmentArgs, opts ...pulumi.ResourceOption) (*NfsAttachment, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Region == nil {
		return nil, errors.New("invalid value for required argument 'Region'")
	}
	if args.ShareId == nil {
		return nil, errors.New("invalid value for required argument 'ShareId'")
	}
	if args.VpcId == nil {
		return nil, errors.New("invalid value for required argument 'VpcId'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource NfsAttachment
	err := ctx.RegisterResource("digitalocean:index/nfsAttachment:NfsAttachment", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetNfsAttachment gets an existing NfsAttachment resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetNfsAttachment(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *NfsAttachmentState, opts ...pulumi.ResourceOption) (*NfsAttachment, error) {
	var resource NfsAttachment
	err := ctx.ReadResource("digitalocean:index/nfsAttachment:NfsAttachment", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering NfsAttachment resources.
type nfsAttachmentState struct {
	Region *string `pulumi:"region"`
	// The ID of the NFS share to attach.
	ShareId *string `pulumi:"shareId"`
	// The ID of the vpc to attach the NFS share to.
	VpcId *string `pulumi:"vpcId"`
}

type NfsAttachmentState struct {
	Region pulumi.StringPtrInput
	// The ID of the NFS share to attach.
	ShareId pulumi.StringPtrInput
	// The ID of the vpc to attach the NFS share to.
	VpcId pulumi.StringPtrInput
}

func (NfsAttachmentState) ElementType() reflect.Type {
	return reflect.TypeOf((*nfsAttachmentState)(nil)).Elem()
}

type nfsAttachmentArgs struct {
	Region string `pulumi:"region"`
	// The ID of the NFS share to attach.
	ShareId string `pulumi:"shareId"`
	// The ID of the vpc to attach the NFS share to.
	VpcId string `pulumi:"vpcId"`
}

// The set of arguments for constructing a NfsAttachment resource.
type NfsAttachmentArgs struct {
	Region pulumi.StringInput
	// The ID of the NFS share to attach.
	ShareId pulumi.StringInput
	// The ID of the vpc to attach the NFS share to.
	VpcId pulumi.StringInput
}

func (NfsAttachmentArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*nfsAttachmentArgs)(nil)).Elem()
}

type NfsAttachmentInput interface {
	pulumi.Input

	ToNfsAttachmentOutput() NfsAttachmentOutput
	ToNfsAttachmentOutputWithContext(ctx context.Context) NfsAttachmentOutput
}

func (*NfsAttachment) ElementType() reflect.Type {
	return reflect.TypeOf((**NfsAttachment)(nil)).Elem()
}

func (i *NfsAttachment) ToNfsAttachmentOutput() NfsAttachmentOutput {
	return i.ToNfsAttachmentOutputWithContext(context.Background())
}

func (i *NfsAttachment) ToNfsAttachmentOutputWithContext(ctx context.Context) NfsAttachmentOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NfsAttachmentOutput)
}

// NfsAttachmentArrayInput is an input type that accepts NfsAttachmentArray and NfsAttachmentArrayOutput values.
// You can construct a concrete instance of `NfsAttachmentArrayInput` via:
//
//	NfsAttachmentArray{ NfsAttachmentArgs{...} }
type NfsAttachmentArrayInput interface {
	pulumi.Input

	ToNfsAttachmentArrayOutput() NfsAttachmentArrayOutput
	ToNfsAttachmentArrayOutputWithContext(context.Context) NfsAttachmentArrayOutput
}

type NfsAttachmentArray []NfsAttachmentInput

func (NfsAttachmentArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NfsAttachment)(nil)).Elem()
}

func (i NfsAttachmentArray) ToNfsAttachmentArrayOutput() NfsAttachmentArrayOutput {
	return i.ToNfsAttachmentArrayOutputWithContext(context.Background())
}

func (i NfsAttachmentArray) ToNfsAttachmentArrayOutputWithContext(ctx context.Context) NfsAttachmentArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NfsAttachmentArrayOutput)
}

// NfsAttachmentMapInput is an input type that accepts NfsAttachmentMap and NfsAttachmentMapOutput values.
// You can construct a concrete instance of `NfsAttachmentMapInput` via:
//
//	NfsAttachmentMap{ "key": NfsAttachmentArgs{...} }
type NfsAttachmentMapInput interface {
	pulumi.Input

	ToNfsAttachmentMapOutput() NfsAttachmentMapOutput
	ToNfsAttachmentMapOutputWithContext(context.Context) NfsAttachmentMapOutput
}

type NfsAttachmentMap map[string]NfsAttachmentInput

func (NfsAttachmentMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NfsAttachment)(nil)).Elem()
}

func (i NfsAttachmentMap) ToNfsAttachmentMapOutput() NfsAttachmentMapOutput {
	return i.ToNfsAttachmentMapOutputWithContext(context.Background())
}

func (i NfsAttachmentMap) ToNfsAttachmentMapOutputWithContext(ctx context.Context) NfsAttachmentMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(NfsAttachmentMapOutput)
}

type NfsAttachmentOutput struct{ *pulumi.OutputState }

func (NfsAttachmentOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**NfsAttachment)(nil)).Elem()
}

func (o NfsAttachmentOutput) ToNfsAttachmentOutput() NfsAttachmentOutput {
	return o
}

func (o NfsAttachmentOutput) ToNfsAttachmentOutputWithContext(ctx context.Context) NfsAttachmentOutput {
	return o
}

func (o NfsAttachmentOutput) Region() pulumi.StringOutput {
	return o.ApplyT(func(v *NfsAttachment) pulumi.StringOutput { return v.Region }).(pulumi.StringOutput)
}

// The ID of the NFS share to attach.
func (o NfsAttachmentOutput) ShareId() pulumi.StringOutput {
	return o.ApplyT(func(v *NfsAttachment) pulumi.StringOutput { return v.ShareId }).(pulumi.StringOutput)
}

// The ID of the vpc to attach the NFS share to.
func (o NfsAttachmentOutput) VpcId() pulumi.StringOutput {
	return o.ApplyT(func(v *NfsAttachment) pulumi.StringOutput { return v.VpcId }).(pulumi.StringOutput)
}

type NfsAttachmentArrayOutput struct{ *pulumi.OutputState }

func (NfsAttachmentArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*NfsAttachment)(nil)).Elem()
}

func (o NfsAttachmentArrayOutput) ToNfsAttachmentArrayOutput() NfsAttachmentArrayOutput {
	return o
}

func (o NfsAttachmentArrayOutput) ToNfsAttachmentArrayOutputWithContext(ctx context.Context) NfsAttachmentArrayOutput {
	return o
}

func (o NfsAttachmentArrayOutput) Index(i pulumi.IntInput) NfsAttachmentOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *NfsAttachment {
		return vs[0].([]*NfsAttachment)[vs[1].(int)]
	}).(NfsAttachmentOutput)
}

type NfsAttachmentMapOutput struct{ *pulumi.OutputState }

func (NfsAttachmentMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*NfsAttachment)(nil)).Elem()
}

func (o NfsAttachmentMapOutput) ToNfsAttachmentMapOutput() NfsAttachmentMapOutput {
	return o
}

func (o NfsAttachmentMapOutput) ToNfsAttachmentMapOutputWithContext(ctx context.Context) NfsAttachmentMapOutput {
	return o
}

func (o NfsAttachmentMapOutput) MapIndex(k pulumi.StringInput) NfsAttachmentOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *NfsAttachment {
		return vs[0].(map[string]*NfsAttachment)[vs[1].(string)]
	}).(NfsAttachmentOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*NfsAttachmentInput)(nil)).Elem(), &NfsAttachment{})
	pulumi.RegisterInputType(reflect.TypeOf((*NfsAttachmentArrayInput)(nil)).Elem(), NfsAttachmentArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*NfsAttachmentMapInput)(nil)).Elem(), NfsAttachmentMap{})
	pulumi.RegisterOutputType(NfsAttachmentOutput{})
	pulumi.RegisterOutputType(NfsAttachmentArrayOutput{})
	pulumi.RegisterOutputType(NfsAttachmentMapOutput{})
}
