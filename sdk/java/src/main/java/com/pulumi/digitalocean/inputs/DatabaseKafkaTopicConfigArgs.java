// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.digitalocean.inputs;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import java.lang.Boolean;
import java.lang.Double;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DatabaseKafkaTopicConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final DatabaseKafkaTopicConfigArgs Empty = new DatabaseKafkaTopicConfigArgs();

    /**
     * The topic cleanup policy that decribes whether messages should be deleted, compacted, or both when retention policies are violated.
     * This may be one of &#34;delete&#34;, &#34;compact&#34;, or &#34;compact_delete&#34;.
     * 
     */
    @Import(name="cleanupPolicy")
    private @Nullable Output<String> cleanupPolicy;

    /**
     * @return The topic cleanup policy that decribes whether messages should be deleted, compacted, or both when retention policies are violated.
     * This may be one of &#34;delete&#34;, &#34;compact&#34;, or &#34;compact_delete&#34;.
     * 
     */
    public Optional<Output<String>> cleanupPolicy() {
        return Optional.ofNullable(this.cleanupPolicy);
    }

    /**
     * The topic compression codecs used for a given topic.
     * This may be one of &#34;uncompressed&#34;, &#34;gzip&#34;, &#34;snappy&#34;, &#34;lz4&#34;, &#34;producer&#34;, &#34;zstd&#34;. &#34;uncompressed&#34; indicates that there is no compression and &#34;producer&#34; retains the original compression codec set by the producer.
     * 
     */
    @Import(name="compressionType")
    private @Nullable Output<String> compressionType;

    /**
     * @return The topic compression codecs used for a given topic.
     * This may be one of &#34;uncompressed&#34;, &#34;gzip&#34;, &#34;snappy&#34;, &#34;lz4&#34;, &#34;producer&#34;, &#34;zstd&#34;. &#34;uncompressed&#34; indicates that there is no compression and &#34;producer&#34; retains the original compression codec set by the producer.
     * 
     */
    public Optional<Output<String>> compressionType() {
        return Optional.ofNullable(this.compressionType);
    }

    /**
     * The amount of time, in ms, that deleted records are retained.
     * 
     */
    @Import(name="deleteRetentionMs")
    private @Nullable Output<String> deleteRetentionMs;

    /**
     * @return The amount of time, in ms, that deleted records are retained.
     * 
     */
    public Optional<Output<String>> deleteRetentionMs() {
        return Optional.ofNullable(this.deleteRetentionMs);
    }

    /**
     * The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
     * 
     */
    @Import(name="fileDeleteDelayMs")
    private @Nullable Output<String> fileDeleteDelayMs;

    /**
     * @return The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
     * 
     */
    public Optional<Output<String>> fileDeleteDelayMs() {
        return Optional.ofNullable(this.fileDeleteDelayMs);
    }

    /**
     * The number of messages accumulated on a topic partition before they are flushed to disk.
     * 
     */
    @Import(name="flushMessages")
    private @Nullable Output<String> flushMessages;

    /**
     * @return The number of messages accumulated on a topic partition before they are flushed to disk.
     * 
     */
    public Optional<Output<String>> flushMessages() {
        return Optional.ofNullable(this.flushMessages);
    }

    /**
     * The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
     * 
     */
    @Import(name="flushMs")
    private @Nullable Output<String> flushMs;

    /**
     * @return The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
     * 
     */
    public Optional<Output<String>> flushMs() {
        return Optional.ofNullable(this.flushMs);
    }

    /**
     * The interval, in bytes, in which entries are added to the offset index.
     * 
     */
    @Import(name="indexIntervalBytes")
    private @Nullable Output<String> indexIntervalBytes;

    /**
     * @return The interval, in bytes, in which entries are added to the offset index.
     * 
     */
    public Optional<Output<String>> indexIntervalBytes() {
        return Optional.ofNullable(this.indexIntervalBytes);
    }

    /**
     * The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to &#34;uncompressed&#34; or it is set to `producer` and the producer is not using compression.
     * 
     */
    @Import(name="maxCompactionLagMs")
    private @Nullable Output<String> maxCompactionLagMs;

    /**
     * @return The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to &#34;uncompressed&#34; or it is set to `producer` and the producer is not using compression.
     * 
     */
    public Optional<Output<String>> maxCompactionLagMs() {
        return Optional.ofNullable(this.maxCompactionLagMs);
    }

    /**
     * The maximum size, in bytes, of a message.
     * 
     */
    @Import(name="maxMessageBytes")
    private @Nullable Output<String> maxMessageBytes;

    /**
     * @return The maximum size, in bytes, of a message.
     * 
     */
    public Optional<Output<String>> maxMessageBytes() {
        return Optional.ofNullable(this.maxMessageBytes);
    }

    /**
     * Determines whether down-conversion of message formats for consumers is enabled.
     * 
     */
    @Import(name="messageDownConversionEnable")
    private @Nullable Output<Boolean> messageDownConversionEnable;

    /**
     * @return Determines whether down-conversion of message formats for consumers is enabled.
     * 
     */
    public Optional<Output<Boolean>> messageDownConversionEnable() {
        return Optional.ofNullable(this.messageDownConversionEnable);
    }

    /**
     * The version of the inter-broker protocol that will be used. This may be one of &#34;0.8.0&#34;, &#34;0.8.1&#34;, &#34;0.8.2&#34;, &#34;0.9.0&#34;, &#34;0.10.0&#34;, &#34;0.10.0-IV0&#34;, &#34;0.10.0-IV1&#34;, &#34;0.10.1&#34;, &#34;0.10.1-IV0&#34;, &#34;0.10.1-IV1&#34;, &#34;0.10.1-IV2&#34;, &#34;0.10.2&#34;, &#34;0.10.2-IV0&#34;, &#34;0.11.0&#34;, &#34;0.11.0-IV0&#34;, &#34;0.11.0-IV1&#34;, &#34;0.11.0-IV2&#34;, &#34;1.0&#34;, &#34;1.0-IV0&#34;, &#34;1.1&#34;, &#34;1.1-IV0&#34;, &#34;2.0&#34;, &#34;2.0-IV0&#34;, &#34;2.0-IV1&#34;, &#34;2.1&#34;, &#34;2.1-IV0&#34;, &#34;2.1-IV1&#34;, &#34;2.1-IV2&#34;, &#34;2.2&#34;, &#34;2.2-IV0&#34;, &#34;2.2-IV1&#34;, &#34;2.3&#34;, &#34;2.3-IV0&#34;, &#34;2.3-IV1&#34;, &#34;2.4&#34;, &#34;2.4-IV0&#34;, &#34;2.4-IV1&#34;, &#34;2.5&#34;, &#34;2.5-IV0&#34;, &#34;2.6&#34;, &#34;2.6-IV0&#34;, &#34;2.7&#34;, &#34;2.7-IV0&#34;, &#34;2.7-IV1&#34;, &#34;2.7-IV2&#34;, &#34;2.8&#34;, &#34;2.8-IV0&#34;, &#34;2.8-IV1&#34;, &#34;3.0&#34;, &#34;3.0-IV0&#34;, &#34;3.0-IV1&#34;, &#34;3.1&#34;, &#34;3.1-IV0&#34;, &#34;3.2&#34;, &#34;3.2-IV0&#34;, &#34;3.3&#34;, &#34;3.3-IV0&#34;, &#34;3.3-IV1&#34;, &#34;3.3-IV2&#34;, &#34;3.3-IV3&#34;, &#34;3.4&#34;, &#34;3.4-IV0&#34;, &#34;3.5&#34;, &#34;3.5-IV0&#34;, &#34;3.5-IV1&#34;, &#34;3.5-IV2&#34;, &#34;3.6&#34;, &#34;3.6-IV0&#34;, &#34;3.6-IV1&#34;, &#34;3.6-IV2&#34;.
     * 
     */
    @Import(name="messageFormatVersion")
    private @Nullable Output<String> messageFormatVersion;

    /**
     * @return The version of the inter-broker protocol that will be used. This may be one of &#34;0.8.0&#34;, &#34;0.8.1&#34;, &#34;0.8.2&#34;, &#34;0.9.0&#34;, &#34;0.10.0&#34;, &#34;0.10.0-IV0&#34;, &#34;0.10.0-IV1&#34;, &#34;0.10.1&#34;, &#34;0.10.1-IV0&#34;, &#34;0.10.1-IV1&#34;, &#34;0.10.1-IV2&#34;, &#34;0.10.2&#34;, &#34;0.10.2-IV0&#34;, &#34;0.11.0&#34;, &#34;0.11.0-IV0&#34;, &#34;0.11.0-IV1&#34;, &#34;0.11.0-IV2&#34;, &#34;1.0&#34;, &#34;1.0-IV0&#34;, &#34;1.1&#34;, &#34;1.1-IV0&#34;, &#34;2.0&#34;, &#34;2.0-IV0&#34;, &#34;2.0-IV1&#34;, &#34;2.1&#34;, &#34;2.1-IV0&#34;, &#34;2.1-IV1&#34;, &#34;2.1-IV2&#34;, &#34;2.2&#34;, &#34;2.2-IV0&#34;, &#34;2.2-IV1&#34;, &#34;2.3&#34;, &#34;2.3-IV0&#34;, &#34;2.3-IV1&#34;, &#34;2.4&#34;, &#34;2.4-IV0&#34;, &#34;2.4-IV1&#34;, &#34;2.5&#34;, &#34;2.5-IV0&#34;, &#34;2.6&#34;, &#34;2.6-IV0&#34;, &#34;2.7&#34;, &#34;2.7-IV0&#34;, &#34;2.7-IV1&#34;, &#34;2.7-IV2&#34;, &#34;2.8&#34;, &#34;2.8-IV0&#34;, &#34;2.8-IV1&#34;, &#34;3.0&#34;, &#34;3.0-IV0&#34;, &#34;3.0-IV1&#34;, &#34;3.1&#34;, &#34;3.1-IV0&#34;, &#34;3.2&#34;, &#34;3.2-IV0&#34;, &#34;3.3&#34;, &#34;3.3-IV0&#34;, &#34;3.3-IV1&#34;, &#34;3.3-IV2&#34;, &#34;3.3-IV3&#34;, &#34;3.4&#34;, &#34;3.4-IV0&#34;, &#34;3.5&#34;, &#34;3.5-IV0&#34;, &#34;3.5-IV1&#34;, &#34;3.5-IV2&#34;, &#34;3.6&#34;, &#34;3.6-IV0&#34;, &#34;3.6-IV1&#34;, &#34;3.6-IV2&#34;.
     * 
     */
    public Optional<Output<String>> messageFormatVersion() {
        return Optional.ofNullable(this.messageFormatVersion);
    }

    /**
     * The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
     * 
     */
    @Import(name="messageTimestampDifferenceMaxMs")
    private @Nullable Output<String> messageTimestampDifferenceMaxMs;

    /**
     * @return The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
     * 
     */
    public Optional<Output<String>> messageTimestampDifferenceMaxMs() {
        return Optional.ofNullable(this.messageTimestampDifferenceMaxMs);
    }

    /**
     * Specifies which timestamp to use for the message. This may be one of &#34;create_time&#34; or &#34;log_append_time&#34;.
     * 
     */
    @Import(name="messageTimestampType")
    private @Nullable Output<String> messageTimestampType;

    /**
     * @return Specifies which timestamp to use for the message. This may be one of &#34;create_time&#34; or &#34;log_append_time&#34;.
     * 
     */
    public Optional<Output<String>> messageTimestampType() {
        return Optional.ofNullable(this.messageTimestampType);
    }

    /**
     * A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
     * 
     */
    @Import(name="minCleanableDirtyRatio")
    private @Nullable Output<Double> minCleanableDirtyRatio;

    /**
     * @return A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
     * 
     */
    public Optional<Output<Double>> minCleanableDirtyRatio() {
        return Optional.ofNullable(this.minCleanableDirtyRatio);
    }

    @Import(name="minCompactionLagMs")
    private @Nullable Output<String> minCompactionLagMs;

    public Optional<Output<String>> minCompactionLagMs() {
        return Optional.ofNullable(this.minCompactionLagMs);
    }

    /**
     * The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful.
     * 
     */
    @Import(name="minInsyncReplicas")
    private @Nullable Output<Integer> minInsyncReplicas;

    /**
     * @return The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful.
     * 
     */
    public Optional<Output<Integer>> minInsyncReplicas() {
        return Optional.ofNullable(this.minInsyncReplicas);
    }

    /**
     * Determines whether to preallocate a file on disk when creating a new log segment within a topic.
     * 
     */
    @Import(name="preallocate")
    private @Nullable Output<Boolean> preallocate;

    /**
     * @return Determines whether to preallocate a file on disk when creating a new log segment within a topic.
     * 
     */
    public Optional<Output<Boolean>> preallocate() {
        return Optional.ofNullable(this.preallocate);
    }

    /**
     * The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
     * 
     */
    @Import(name="retentionBytes")
    private @Nullable Output<String> retentionBytes;

    /**
     * @return The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
     * 
     */
    public Optional<Output<String>> retentionBytes() {
        return Optional.ofNullable(this.retentionBytes);
    }

    /**
     * The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
     * 
     */
    @Import(name="retentionMs")
    private @Nullable Output<String> retentionMs;

    /**
     * @return The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
     * 
     */
    public Optional<Output<String>> retentionMs() {
        return Optional.ofNullable(this.retentionMs);
    }

    /**
     * The maximum size, in bytes, of a single topic log file.
     * 
     */
    @Import(name="segmentBytes")
    private @Nullable Output<String> segmentBytes;

    /**
     * @return The maximum size, in bytes, of a single topic log file.
     * 
     */
    public Optional<Output<String>> segmentBytes() {
        return Optional.ofNullable(this.segmentBytes);
    }

    /**
     * The maximum size, in bytes, of the offset index.
     * 
     */
    @Import(name="segmentIndexBytes")
    private @Nullable Output<String> segmentIndexBytes;

    /**
     * @return The maximum size, in bytes, of the offset index.
     * 
     */
    public Optional<Output<String>> segmentIndexBytes() {
        return Optional.ofNullable(this.segmentIndexBytes);
    }

    /**
     * The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
     * 
     */
    @Import(name="segmentJitterMs")
    private @Nullable Output<String> segmentJitterMs;

    /**
     * @return The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
     * 
     */
    public Optional<Output<String>> segmentJitterMs() {
        return Optional.ofNullable(this.segmentJitterMs);
    }

    /**
     * The maximum time, in ms, before the topic log will flush to disk.
     * 
     */
    @Import(name="segmentMs")
    private @Nullable Output<String> segmentMs;

    /**
     * @return The maximum time, in ms, before the topic log will flush to disk.
     * 
     */
    public Optional<Output<String>> segmentMs() {
        return Optional.ofNullable(this.segmentMs);
    }

    /**
     * Determines whether to allow nodes that are not part of the in-sync replica set (IRS) to be elected as leader. Note: setting this to &#34;true&#34; could result in data loss.
     * 
     */
    @Import(name="uncleanLeaderElectionEnable")
    private @Nullable Output<Boolean> uncleanLeaderElectionEnable;

    /**
     * @return Determines whether to allow nodes that are not part of the in-sync replica set (IRS) to be elected as leader. Note: setting this to &#34;true&#34; could result in data loss.
     * 
     */
    public Optional<Output<Boolean>> uncleanLeaderElectionEnable() {
        return Optional.ofNullable(this.uncleanLeaderElectionEnable);
    }

    private DatabaseKafkaTopicConfigArgs() {}

    private DatabaseKafkaTopicConfigArgs(DatabaseKafkaTopicConfigArgs $) {
        this.cleanupPolicy = $.cleanupPolicy;
        this.compressionType = $.compressionType;
        this.deleteRetentionMs = $.deleteRetentionMs;
        this.fileDeleteDelayMs = $.fileDeleteDelayMs;
        this.flushMessages = $.flushMessages;
        this.flushMs = $.flushMs;
        this.indexIntervalBytes = $.indexIntervalBytes;
        this.maxCompactionLagMs = $.maxCompactionLagMs;
        this.maxMessageBytes = $.maxMessageBytes;
        this.messageDownConversionEnable = $.messageDownConversionEnable;
        this.messageFormatVersion = $.messageFormatVersion;
        this.messageTimestampDifferenceMaxMs = $.messageTimestampDifferenceMaxMs;
        this.messageTimestampType = $.messageTimestampType;
        this.minCleanableDirtyRatio = $.minCleanableDirtyRatio;
        this.minCompactionLagMs = $.minCompactionLagMs;
        this.minInsyncReplicas = $.minInsyncReplicas;
        this.preallocate = $.preallocate;
        this.retentionBytes = $.retentionBytes;
        this.retentionMs = $.retentionMs;
        this.segmentBytes = $.segmentBytes;
        this.segmentIndexBytes = $.segmentIndexBytes;
        this.segmentJitterMs = $.segmentJitterMs;
        this.segmentMs = $.segmentMs;
        this.uncleanLeaderElectionEnable = $.uncleanLeaderElectionEnable;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DatabaseKafkaTopicConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DatabaseKafkaTopicConfigArgs $;

        public Builder() {
            $ = new DatabaseKafkaTopicConfigArgs();
        }

        public Builder(DatabaseKafkaTopicConfigArgs defaults) {
            $ = new DatabaseKafkaTopicConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param cleanupPolicy The topic cleanup policy that decribes whether messages should be deleted, compacted, or both when retention policies are violated.
         * This may be one of &#34;delete&#34;, &#34;compact&#34;, or &#34;compact_delete&#34;.
         * 
         * @return builder
         * 
         */
        public Builder cleanupPolicy(@Nullable Output<String> cleanupPolicy) {
            $.cleanupPolicy = cleanupPolicy;
            return this;
        }

        /**
         * @param cleanupPolicy The topic cleanup policy that decribes whether messages should be deleted, compacted, or both when retention policies are violated.
         * This may be one of &#34;delete&#34;, &#34;compact&#34;, or &#34;compact_delete&#34;.
         * 
         * @return builder
         * 
         */
        public Builder cleanupPolicy(String cleanupPolicy) {
            return cleanupPolicy(Output.of(cleanupPolicy));
        }

        /**
         * @param compressionType The topic compression codecs used for a given topic.
         * This may be one of &#34;uncompressed&#34;, &#34;gzip&#34;, &#34;snappy&#34;, &#34;lz4&#34;, &#34;producer&#34;, &#34;zstd&#34;. &#34;uncompressed&#34; indicates that there is no compression and &#34;producer&#34; retains the original compression codec set by the producer.
         * 
         * @return builder
         * 
         */
        public Builder compressionType(@Nullable Output<String> compressionType) {
            $.compressionType = compressionType;
            return this;
        }

        /**
         * @param compressionType The topic compression codecs used for a given topic.
         * This may be one of &#34;uncompressed&#34;, &#34;gzip&#34;, &#34;snappy&#34;, &#34;lz4&#34;, &#34;producer&#34;, &#34;zstd&#34;. &#34;uncompressed&#34; indicates that there is no compression and &#34;producer&#34; retains the original compression codec set by the producer.
         * 
         * @return builder
         * 
         */
        public Builder compressionType(String compressionType) {
            return compressionType(Output.of(compressionType));
        }

        /**
         * @param deleteRetentionMs The amount of time, in ms, that deleted records are retained.
         * 
         * @return builder
         * 
         */
        public Builder deleteRetentionMs(@Nullable Output<String> deleteRetentionMs) {
            $.deleteRetentionMs = deleteRetentionMs;
            return this;
        }

        /**
         * @param deleteRetentionMs The amount of time, in ms, that deleted records are retained.
         * 
         * @return builder
         * 
         */
        public Builder deleteRetentionMs(String deleteRetentionMs) {
            return deleteRetentionMs(Output.of(deleteRetentionMs));
        }

        /**
         * @param fileDeleteDelayMs The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
         * 
         * @return builder
         * 
         */
        public Builder fileDeleteDelayMs(@Nullable Output<String> fileDeleteDelayMs) {
            $.fileDeleteDelayMs = fileDeleteDelayMs;
            return this;
        }

        /**
         * @param fileDeleteDelayMs The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
         * 
         * @return builder
         * 
         */
        public Builder fileDeleteDelayMs(String fileDeleteDelayMs) {
            return fileDeleteDelayMs(Output.of(fileDeleteDelayMs));
        }

        /**
         * @param flushMessages The number of messages accumulated on a topic partition before they are flushed to disk.
         * 
         * @return builder
         * 
         */
        public Builder flushMessages(@Nullable Output<String> flushMessages) {
            $.flushMessages = flushMessages;
            return this;
        }

        /**
         * @param flushMessages The number of messages accumulated on a topic partition before they are flushed to disk.
         * 
         * @return builder
         * 
         */
        public Builder flushMessages(String flushMessages) {
            return flushMessages(Output.of(flushMessages));
        }

        /**
         * @param flushMs The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
         * 
         * @return builder
         * 
         */
        public Builder flushMs(@Nullable Output<String> flushMs) {
            $.flushMs = flushMs;
            return this;
        }

        /**
         * @param flushMs The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
         * 
         * @return builder
         * 
         */
        public Builder flushMs(String flushMs) {
            return flushMs(Output.of(flushMs));
        }

        /**
         * @param indexIntervalBytes The interval, in bytes, in which entries are added to the offset index.
         * 
         * @return builder
         * 
         */
        public Builder indexIntervalBytes(@Nullable Output<String> indexIntervalBytes) {
            $.indexIntervalBytes = indexIntervalBytes;
            return this;
        }

        /**
         * @param indexIntervalBytes The interval, in bytes, in which entries are added to the offset index.
         * 
         * @return builder
         * 
         */
        public Builder indexIntervalBytes(String indexIntervalBytes) {
            return indexIntervalBytes(Output.of(indexIntervalBytes));
        }

        /**
         * @param maxCompactionLagMs The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to &#34;uncompressed&#34; or it is set to `producer` and the producer is not using compression.
         * 
         * @return builder
         * 
         */
        public Builder maxCompactionLagMs(@Nullable Output<String> maxCompactionLagMs) {
            $.maxCompactionLagMs = maxCompactionLagMs;
            return this;
        }

        /**
         * @param maxCompactionLagMs The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to &#34;uncompressed&#34; or it is set to `producer` and the producer is not using compression.
         * 
         * @return builder
         * 
         */
        public Builder maxCompactionLagMs(String maxCompactionLagMs) {
            return maxCompactionLagMs(Output.of(maxCompactionLagMs));
        }

        /**
         * @param maxMessageBytes The maximum size, in bytes, of a message.
         * 
         * @return builder
         * 
         */
        public Builder maxMessageBytes(@Nullable Output<String> maxMessageBytes) {
            $.maxMessageBytes = maxMessageBytes;
            return this;
        }

        /**
         * @param maxMessageBytes The maximum size, in bytes, of a message.
         * 
         * @return builder
         * 
         */
        public Builder maxMessageBytes(String maxMessageBytes) {
            return maxMessageBytes(Output.of(maxMessageBytes));
        }

        /**
         * @param messageDownConversionEnable Determines whether down-conversion of message formats for consumers is enabled.
         * 
         * @return builder
         * 
         */
        public Builder messageDownConversionEnable(@Nullable Output<Boolean> messageDownConversionEnable) {
            $.messageDownConversionEnable = messageDownConversionEnable;
            return this;
        }

        /**
         * @param messageDownConversionEnable Determines whether down-conversion of message formats for consumers is enabled.
         * 
         * @return builder
         * 
         */
        public Builder messageDownConversionEnable(Boolean messageDownConversionEnable) {
            return messageDownConversionEnable(Output.of(messageDownConversionEnable));
        }

        /**
         * @param messageFormatVersion The version of the inter-broker protocol that will be used. This may be one of &#34;0.8.0&#34;, &#34;0.8.1&#34;, &#34;0.8.2&#34;, &#34;0.9.0&#34;, &#34;0.10.0&#34;, &#34;0.10.0-IV0&#34;, &#34;0.10.0-IV1&#34;, &#34;0.10.1&#34;, &#34;0.10.1-IV0&#34;, &#34;0.10.1-IV1&#34;, &#34;0.10.1-IV2&#34;, &#34;0.10.2&#34;, &#34;0.10.2-IV0&#34;, &#34;0.11.0&#34;, &#34;0.11.0-IV0&#34;, &#34;0.11.0-IV1&#34;, &#34;0.11.0-IV2&#34;, &#34;1.0&#34;, &#34;1.0-IV0&#34;, &#34;1.1&#34;, &#34;1.1-IV0&#34;, &#34;2.0&#34;, &#34;2.0-IV0&#34;, &#34;2.0-IV1&#34;, &#34;2.1&#34;, &#34;2.1-IV0&#34;, &#34;2.1-IV1&#34;, &#34;2.1-IV2&#34;, &#34;2.2&#34;, &#34;2.2-IV0&#34;, &#34;2.2-IV1&#34;, &#34;2.3&#34;, &#34;2.3-IV0&#34;, &#34;2.3-IV1&#34;, &#34;2.4&#34;, &#34;2.4-IV0&#34;, &#34;2.4-IV1&#34;, &#34;2.5&#34;, &#34;2.5-IV0&#34;, &#34;2.6&#34;, &#34;2.6-IV0&#34;, &#34;2.7&#34;, &#34;2.7-IV0&#34;, &#34;2.7-IV1&#34;, &#34;2.7-IV2&#34;, &#34;2.8&#34;, &#34;2.8-IV0&#34;, &#34;2.8-IV1&#34;, &#34;3.0&#34;, &#34;3.0-IV0&#34;, &#34;3.0-IV1&#34;, &#34;3.1&#34;, &#34;3.1-IV0&#34;, &#34;3.2&#34;, &#34;3.2-IV0&#34;, &#34;3.3&#34;, &#34;3.3-IV0&#34;, &#34;3.3-IV1&#34;, &#34;3.3-IV2&#34;, &#34;3.3-IV3&#34;, &#34;3.4&#34;, &#34;3.4-IV0&#34;, &#34;3.5&#34;, &#34;3.5-IV0&#34;, &#34;3.5-IV1&#34;, &#34;3.5-IV2&#34;, &#34;3.6&#34;, &#34;3.6-IV0&#34;, &#34;3.6-IV1&#34;, &#34;3.6-IV2&#34;.
         * 
         * @return builder
         * 
         */
        public Builder messageFormatVersion(@Nullable Output<String> messageFormatVersion) {
            $.messageFormatVersion = messageFormatVersion;
            return this;
        }

        /**
         * @param messageFormatVersion The version of the inter-broker protocol that will be used. This may be one of &#34;0.8.0&#34;, &#34;0.8.1&#34;, &#34;0.8.2&#34;, &#34;0.9.0&#34;, &#34;0.10.0&#34;, &#34;0.10.0-IV0&#34;, &#34;0.10.0-IV1&#34;, &#34;0.10.1&#34;, &#34;0.10.1-IV0&#34;, &#34;0.10.1-IV1&#34;, &#34;0.10.1-IV2&#34;, &#34;0.10.2&#34;, &#34;0.10.2-IV0&#34;, &#34;0.11.0&#34;, &#34;0.11.0-IV0&#34;, &#34;0.11.0-IV1&#34;, &#34;0.11.0-IV2&#34;, &#34;1.0&#34;, &#34;1.0-IV0&#34;, &#34;1.1&#34;, &#34;1.1-IV0&#34;, &#34;2.0&#34;, &#34;2.0-IV0&#34;, &#34;2.0-IV1&#34;, &#34;2.1&#34;, &#34;2.1-IV0&#34;, &#34;2.1-IV1&#34;, &#34;2.1-IV2&#34;, &#34;2.2&#34;, &#34;2.2-IV0&#34;, &#34;2.2-IV1&#34;, &#34;2.3&#34;, &#34;2.3-IV0&#34;, &#34;2.3-IV1&#34;, &#34;2.4&#34;, &#34;2.4-IV0&#34;, &#34;2.4-IV1&#34;, &#34;2.5&#34;, &#34;2.5-IV0&#34;, &#34;2.6&#34;, &#34;2.6-IV0&#34;, &#34;2.7&#34;, &#34;2.7-IV0&#34;, &#34;2.7-IV1&#34;, &#34;2.7-IV2&#34;, &#34;2.8&#34;, &#34;2.8-IV0&#34;, &#34;2.8-IV1&#34;, &#34;3.0&#34;, &#34;3.0-IV0&#34;, &#34;3.0-IV1&#34;, &#34;3.1&#34;, &#34;3.1-IV0&#34;, &#34;3.2&#34;, &#34;3.2-IV0&#34;, &#34;3.3&#34;, &#34;3.3-IV0&#34;, &#34;3.3-IV1&#34;, &#34;3.3-IV2&#34;, &#34;3.3-IV3&#34;, &#34;3.4&#34;, &#34;3.4-IV0&#34;, &#34;3.5&#34;, &#34;3.5-IV0&#34;, &#34;3.5-IV1&#34;, &#34;3.5-IV2&#34;, &#34;3.6&#34;, &#34;3.6-IV0&#34;, &#34;3.6-IV1&#34;, &#34;3.6-IV2&#34;.
         * 
         * @return builder
         * 
         */
        public Builder messageFormatVersion(String messageFormatVersion) {
            return messageFormatVersion(Output.of(messageFormatVersion));
        }

        /**
         * @param messageTimestampDifferenceMaxMs The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
         * 
         * @return builder
         * 
         */
        public Builder messageTimestampDifferenceMaxMs(@Nullable Output<String> messageTimestampDifferenceMaxMs) {
            $.messageTimestampDifferenceMaxMs = messageTimestampDifferenceMaxMs;
            return this;
        }

        /**
         * @param messageTimestampDifferenceMaxMs The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
         * 
         * @return builder
         * 
         */
        public Builder messageTimestampDifferenceMaxMs(String messageTimestampDifferenceMaxMs) {
            return messageTimestampDifferenceMaxMs(Output.of(messageTimestampDifferenceMaxMs));
        }

        /**
         * @param messageTimestampType Specifies which timestamp to use for the message. This may be one of &#34;create_time&#34; or &#34;log_append_time&#34;.
         * 
         * @return builder
         * 
         */
        public Builder messageTimestampType(@Nullable Output<String> messageTimestampType) {
            $.messageTimestampType = messageTimestampType;
            return this;
        }

        /**
         * @param messageTimestampType Specifies which timestamp to use for the message. This may be one of &#34;create_time&#34; or &#34;log_append_time&#34;.
         * 
         * @return builder
         * 
         */
        public Builder messageTimestampType(String messageTimestampType) {
            return messageTimestampType(Output.of(messageTimestampType));
        }

        /**
         * @param minCleanableDirtyRatio A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
         * 
         * @return builder
         * 
         */
        public Builder minCleanableDirtyRatio(@Nullable Output<Double> minCleanableDirtyRatio) {
            $.minCleanableDirtyRatio = minCleanableDirtyRatio;
            return this;
        }

        /**
         * @param minCleanableDirtyRatio A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
         * 
         * @return builder
         * 
         */
        public Builder minCleanableDirtyRatio(Double minCleanableDirtyRatio) {
            return minCleanableDirtyRatio(Output.of(minCleanableDirtyRatio));
        }

        public Builder minCompactionLagMs(@Nullable Output<String> minCompactionLagMs) {
            $.minCompactionLagMs = minCompactionLagMs;
            return this;
        }

        public Builder minCompactionLagMs(String minCompactionLagMs) {
            return minCompactionLagMs(Output.of(minCompactionLagMs));
        }

        /**
         * @param minInsyncReplicas The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful.
         * 
         * @return builder
         * 
         */
        public Builder minInsyncReplicas(@Nullable Output<Integer> minInsyncReplicas) {
            $.minInsyncReplicas = minInsyncReplicas;
            return this;
        }

        /**
         * @param minInsyncReplicas The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful.
         * 
         * @return builder
         * 
         */
        public Builder minInsyncReplicas(Integer minInsyncReplicas) {
            return minInsyncReplicas(Output.of(minInsyncReplicas));
        }

        /**
         * @param preallocate Determines whether to preallocate a file on disk when creating a new log segment within a topic.
         * 
         * @return builder
         * 
         */
        public Builder preallocate(@Nullable Output<Boolean> preallocate) {
            $.preallocate = preallocate;
            return this;
        }

        /**
         * @param preallocate Determines whether to preallocate a file on disk when creating a new log segment within a topic.
         * 
         * @return builder
         * 
         */
        public Builder preallocate(Boolean preallocate) {
            return preallocate(Output.of(preallocate));
        }

        /**
         * @param retentionBytes The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
         * 
         * @return builder
         * 
         */
        public Builder retentionBytes(@Nullable Output<String> retentionBytes) {
            $.retentionBytes = retentionBytes;
            return this;
        }

        /**
         * @param retentionBytes The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
         * 
         * @return builder
         * 
         */
        public Builder retentionBytes(String retentionBytes) {
            return retentionBytes(Output.of(retentionBytes));
        }

        /**
         * @param retentionMs The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
         * 
         * @return builder
         * 
         */
        public Builder retentionMs(@Nullable Output<String> retentionMs) {
            $.retentionMs = retentionMs;
            return this;
        }

        /**
         * @param retentionMs The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
         * 
         * @return builder
         * 
         */
        public Builder retentionMs(String retentionMs) {
            return retentionMs(Output.of(retentionMs));
        }

        /**
         * @param segmentBytes The maximum size, in bytes, of a single topic log file.
         * 
         * @return builder
         * 
         */
        public Builder segmentBytes(@Nullable Output<String> segmentBytes) {
            $.segmentBytes = segmentBytes;
            return this;
        }

        /**
         * @param segmentBytes The maximum size, in bytes, of a single topic log file.
         * 
         * @return builder
         * 
         */
        public Builder segmentBytes(String segmentBytes) {
            return segmentBytes(Output.of(segmentBytes));
        }

        /**
         * @param segmentIndexBytes The maximum size, in bytes, of the offset index.
         * 
         * @return builder
         * 
         */
        public Builder segmentIndexBytes(@Nullable Output<String> segmentIndexBytes) {
            $.segmentIndexBytes = segmentIndexBytes;
            return this;
        }

        /**
         * @param segmentIndexBytes The maximum size, in bytes, of the offset index.
         * 
         * @return builder
         * 
         */
        public Builder segmentIndexBytes(String segmentIndexBytes) {
            return segmentIndexBytes(Output.of(segmentIndexBytes));
        }

        /**
         * @param segmentJitterMs The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
         * 
         * @return builder
         * 
         */
        public Builder segmentJitterMs(@Nullable Output<String> segmentJitterMs) {
            $.segmentJitterMs = segmentJitterMs;
            return this;
        }

        /**
         * @param segmentJitterMs The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
         * 
         * @return builder
         * 
         */
        public Builder segmentJitterMs(String segmentJitterMs) {
            return segmentJitterMs(Output.of(segmentJitterMs));
        }

        /**
         * @param segmentMs The maximum time, in ms, before the topic log will flush to disk.
         * 
         * @return builder
         * 
         */
        public Builder segmentMs(@Nullable Output<String> segmentMs) {
            $.segmentMs = segmentMs;
            return this;
        }

        /**
         * @param segmentMs The maximum time, in ms, before the topic log will flush to disk.
         * 
         * @return builder
         * 
         */
        public Builder segmentMs(String segmentMs) {
            return segmentMs(Output.of(segmentMs));
        }

        /**
         * @param uncleanLeaderElectionEnable Determines whether to allow nodes that are not part of the in-sync replica set (IRS) to be elected as leader. Note: setting this to &#34;true&#34; could result in data loss.
         * 
         * @return builder
         * 
         */
        public Builder uncleanLeaderElectionEnable(@Nullable Output<Boolean> uncleanLeaderElectionEnable) {
            $.uncleanLeaderElectionEnable = uncleanLeaderElectionEnable;
            return this;
        }

        /**
         * @param uncleanLeaderElectionEnable Determines whether to allow nodes that are not part of the in-sync replica set (IRS) to be elected as leader. Note: setting this to &#34;true&#34; could result in data loss.
         * 
         * @return builder
         * 
         */
        public Builder uncleanLeaderElectionEnable(Boolean uncleanLeaderElectionEnable) {
            return uncleanLeaderElectionEnable(Output.of(uncleanLeaderElectionEnable));
        }

        public DatabaseKafkaTopicConfigArgs build() {
            return $;
        }
    }

}
