// *** WARNING: this file was generated by pulumi-java-gen. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package com.pulumi.digitalocean;

import com.pulumi.core.Output;
import com.pulumi.core.annotations.Import;
import com.pulumi.exceptions.MissingRequiredPropertyException;
import java.lang.Boolean;
import java.lang.Integer;
import java.lang.String;
import java.util.Objects;
import java.util.Optional;
import javax.annotation.Nullable;


public final class DatabaseKafkaConfigArgs extends com.pulumi.resources.ResourceArgs {

    public static final DatabaseKafkaConfigArgs Empty = new DatabaseKafkaConfigArgs();

    /**
     * Enable auto creation of topics.
     * 
     */
    @Import(name="autoCreateTopicsEnable")
    private @Nullable Output<Boolean> autoCreateTopicsEnable;

    /**
     * @return Enable auto creation of topics.
     * 
     */
    public Optional<Output<Boolean>> autoCreateTopicsEnable() {
        return Optional.ofNullable(this.autoCreateTopicsEnable);
    }

    /**
     * The ID of the target Kafka cluster.
     * 
     */
    @Import(name="clusterId", required=true)
    private Output<String> clusterId;

    /**
     * @return The ID of the target Kafka cluster.
     * 
     */
    public Output<String> clusterId() {
        return this.clusterId;
    }

    /**
     * The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time.
     * 
     */
    @Import(name="groupInitialRebalanceDelayMs")
    private @Nullable Output<Integer> groupInitialRebalanceDelayMs;

    /**
     * @return The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time.
     * 
     */
    public Optional<Output<Integer>> groupInitialRebalanceDelayMs() {
        return Optional.ofNullable(this.groupInitialRebalanceDelayMs);
    }

    /**
     * The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
     * 
     */
    @Import(name="groupMaxSessionTimeoutMs")
    private @Nullable Output<Integer> groupMaxSessionTimeoutMs;

    /**
     * @return The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
     * 
     */
    public Optional<Output<Integer>> groupMaxSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMaxSessionTimeoutMs);
    }

    /**
     * The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
     * 
     */
    @Import(name="groupMinSessionTimeoutMs")
    private @Nullable Output<Integer> groupMinSessionTimeoutMs;

    /**
     * @return The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
     * 
     */
    public Optional<Output<Integer>> groupMinSessionTimeoutMs() {
        return Optional.ofNullable(this.groupMinSessionTimeoutMs);
    }

    /**
     * How long are delete records retained?
     * 
     */
    @Import(name="logCleanerDeleteRetentionMs")
    private @Nullable Output<Integer> logCleanerDeleteRetentionMs;

    /**
     * @return How long are delete records retained?
     * 
     */
    public Optional<Output<Integer>> logCleanerDeleteRetentionMs() {
        return Optional.ofNullable(this.logCleanerDeleteRetentionMs);
    }

    /**
     * The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
     * 
     */
    @Import(name="logCleanerMinCompactionLagMs")
    private @Nullable Output<String> logCleanerMinCompactionLagMs;

    /**
     * @return The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
     * 
     */
    public Optional<Output<String>> logCleanerMinCompactionLagMs() {
        return Optional.ofNullable(this.logCleanerMinCompactionLagMs);
    }

    /**
     * The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used.
     * 
     */
    @Import(name="logFlushIntervalMs")
    private @Nullable Output<String> logFlushIntervalMs;

    /**
     * @return The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used.
     * 
     */
    public Optional<Output<String>> logFlushIntervalMs() {
        return Optional.ofNullable(this.logFlushIntervalMs);
    }

    /**
     * The interval with which Kafka adds an entry to the offset index.
     * 
     */
    @Import(name="logIndexIntervalBytes")
    private @Nullable Output<Integer> logIndexIntervalBytes;

    /**
     * @return The interval with which Kafka adds an entry to the offset index.
     * 
     */
    public Optional<Output<Integer>> logIndexIntervalBytes() {
        return Optional.ofNullable(this.logIndexIntervalBytes);
    }

    /**
     * This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests.
     * 
     */
    @Import(name="logMessageDownconversionEnable")
    private @Nullable Output<Boolean> logMessageDownconversionEnable;

    /**
     * @return This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests.
     * 
     */
    public Optional<Output<Boolean>> logMessageDownconversionEnable() {
        return Optional.ofNullable(this.logMessageDownconversionEnable);
    }

    /**
     * The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message.
     * 
     */
    @Import(name="logMessageTimestampDifferenceMaxMs")
    private @Nullable Output<String> logMessageTimestampDifferenceMaxMs;

    /**
     * @return The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message.
     * 
     */
    public Optional<Output<String>> logMessageTimestampDifferenceMaxMs() {
        return Optional.ofNullable(this.logMessageTimestampDifferenceMaxMs);
    }

    /**
     * Controls whether to preallocate a file when creating a new segment.
     * 
     */
    @Import(name="logPreallocate")
    private @Nullable Output<Boolean> logPreallocate;

    /**
     * @return Controls whether to preallocate a file when creating a new segment.
     * 
     */
    public Optional<Output<Boolean>> logPreallocate() {
        return Optional.ofNullable(this.logPreallocate);
    }

    /**
     * The maximum size of the log before deleting messages.
     * 
     */
    @Import(name="logRetentionBytes")
    private @Nullable Output<String> logRetentionBytes;

    /**
     * @return The maximum size of the log before deleting messages.
     * 
     */
    public Optional<Output<String>> logRetentionBytes() {
        return Optional.ofNullable(this.logRetentionBytes);
    }

    /**
     * The number of hours to keep a log file before deleting it.
     * 
     */
    @Import(name="logRetentionHours")
    private @Nullable Output<Integer> logRetentionHours;

    /**
     * @return The number of hours to keep a log file before deleting it.
     * 
     */
    public Optional<Output<Integer>> logRetentionHours() {
        return Optional.ofNullable(this.logRetentionHours);
    }

    /**
     * The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
     * 
     */
    @Import(name="logRetentionMs")
    private @Nullable Output<String> logRetentionMs;

    /**
     * @return The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
     * 
     */
    public Optional<Output<String>> logRetentionMs() {
        return Optional.ofNullable(this.logRetentionMs);
    }

    /**
     * The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used.
     * 
     */
    @Import(name="logRollJitterMs")
    private @Nullable Output<String> logRollJitterMs;

    /**
     * @return The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used.
     * 
     */
    public Optional<Output<String>> logRollJitterMs() {
        return Optional.ofNullable(this.logRollJitterMs);
    }

    /**
     * The amount of time to wait before deleting a file from the filesystem.
     * 
     */
    @Import(name="logSegmentDeleteDelayMs")
    private @Nullable Output<Integer> logSegmentDeleteDelayMs;

    /**
     * @return The amount of time to wait before deleting a file from the filesystem.
     * 
     */
    public Optional<Output<Integer>> logSegmentDeleteDelayMs() {
        return Optional.ofNullable(this.logSegmentDeleteDelayMs);
    }

    /**
     * The maximum size of message that the server can receive.
     * 
     */
    @Import(name="messageMaxBytes")
    private @Nullable Output<Integer> messageMaxBytes;

    /**
     * @return The maximum size of message that the server can receive.
     * 
     */
    public Optional<Output<Integer>> messageMaxBytes() {
        return Optional.ofNullable(this.messageMaxBytes);
    }

    private DatabaseKafkaConfigArgs() {}

    private DatabaseKafkaConfigArgs(DatabaseKafkaConfigArgs $) {
        this.autoCreateTopicsEnable = $.autoCreateTopicsEnable;
        this.clusterId = $.clusterId;
        this.groupInitialRebalanceDelayMs = $.groupInitialRebalanceDelayMs;
        this.groupMaxSessionTimeoutMs = $.groupMaxSessionTimeoutMs;
        this.groupMinSessionTimeoutMs = $.groupMinSessionTimeoutMs;
        this.logCleanerDeleteRetentionMs = $.logCleanerDeleteRetentionMs;
        this.logCleanerMinCompactionLagMs = $.logCleanerMinCompactionLagMs;
        this.logFlushIntervalMs = $.logFlushIntervalMs;
        this.logIndexIntervalBytes = $.logIndexIntervalBytes;
        this.logMessageDownconversionEnable = $.logMessageDownconversionEnable;
        this.logMessageTimestampDifferenceMaxMs = $.logMessageTimestampDifferenceMaxMs;
        this.logPreallocate = $.logPreallocate;
        this.logRetentionBytes = $.logRetentionBytes;
        this.logRetentionHours = $.logRetentionHours;
        this.logRetentionMs = $.logRetentionMs;
        this.logRollJitterMs = $.logRollJitterMs;
        this.logSegmentDeleteDelayMs = $.logSegmentDeleteDelayMs;
        this.messageMaxBytes = $.messageMaxBytes;
    }

    public static Builder builder() {
        return new Builder();
    }
    public static Builder builder(DatabaseKafkaConfigArgs defaults) {
        return new Builder(defaults);
    }

    public static final class Builder {
        private DatabaseKafkaConfigArgs $;

        public Builder() {
            $ = new DatabaseKafkaConfigArgs();
        }

        public Builder(DatabaseKafkaConfigArgs defaults) {
            $ = new DatabaseKafkaConfigArgs(Objects.requireNonNull(defaults));
        }

        /**
         * @param autoCreateTopicsEnable Enable auto creation of topics.
         * 
         * @return builder
         * 
         */
        public Builder autoCreateTopicsEnable(@Nullable Output<Boolean> autoCreateTopicsEnable) {
            $.autoCreateTopicsEnable = autoCreateTopicsEnable;
            return this;
        }

        /**
         * @param autoCreateTopicsEnable Enable auto creation of topics.
         * 
         * @return builder
         * 
         */
        public Builder autoCreateTopicsEnable(Boolean autoCreateTopicsEnable) {
            return autoCreateTopicsEnable(Output.of(autoCreateTopicsEnable));
        }

        /**
         * @param clusterId The ID of the target Kafka cluster.
         * 
         * @return builder
         * 
         */
        public Builder clusterId(Output<String> clusterId) {
            $.clusterId = clusterId;
            return this;
        }

        /**
         * @param clusterId The ID of the target Kafka cluster.
         * 
         * @return builder
         * 
         */
        public Builder clusterId(String clusterId) {
            return clusterId(Output.of(clusterId));
        }

        /**
         * @param groupInitialRebalanceDelayMs The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time.
         * 
         * @return builder
         * 
         */
        public Builder groupInitialRebalanceDelayMs(@Nullable Output<Integer> groupInitialRebalanceDelayMs) {
            $.groupInitialRebalanceDelayMs = groupInitialRebalanceDelayMs;
            return this;
        }

        /**
         * @param groupInitialRebalanceDelayMs The amount of time, in milliseconds, the group coordinator will wait for more consumers to join a new group before performing the first rebalance. A longer delay means potentially fewer rebalances, but increases the time until processing begins. The default value for this is 3 seconds. During development and testing it might be desirable to set this to 0 in order to not delay test execution time.
         * 
         * @return builder
         * 
         */
        public Builder groupInitialRebalanceDelayMs(Integer groupInitialRebalanceDelayMs) {
            return groupInitialRebalanceDelayMs(Output.of(groupInitialRebalanceDelayMs));
        }

        /**
         * @param groupMaxSessionTimeoutMs The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
         * 
         * @return builder
         * 
         */
        public Builder groupMaxSessionTimeoutMs(@Nullable Output<Integer> groupMaxSessionTimeoutMs) {
            $.groupMaxSessionTimeoutMs = groupMaxSessionTimeoutMs;
            return this;
        }

        /**
         * @param groupMaxSessionTimeoutMs The maximum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
         * 
         * @return builder
         * 
         */
        public Builder groupMaxSessionTimeoutMs(Integer groupMaxSessionTimeoutMs) {
            return groupMaxSessionTimeoutMs(Output.of(groupMaxSessionTimeoutMs));
        }

        /**
         * @param groupMinSessionTimeoutMs The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
         * 
         * @return builder
         * 
         */
        public Builder groupMinSessionTimeoutMs(@Nullable Output<Integer> groupMinSessionTimeoutMs) {
            $.groupMinSessionTimeoutMs = groupMinSessionTimeoutMs;
            return this;
        }

        /**
         * @param groupMinSessionTimeoutMs The minimum allowed session timeout for registered consumers. Longer timeouts give consumers more time to process messages in between heartbeats at the cost of a longer time to detect failures.
         * 
         * @return builder
         * 
         */
        public Builder groupMinSessionTimeoutMs(Integer groupMinSessionTimeoutMs) {
            return groupMinSessionTimeoutMs(Output.of(groupMinSessionTimeoutMs));
        }

        /**
         * @param logCleanerDeleteRetentionMs How long are delete records retained?
         * 
         * @return builder
         * 
         */
        public Builder logCleanerDeleteRetentionMs(@Nullable Output<Integer> logCleanerDeleteRetentionMs) {
            $.logCleanerDeleteRetentionMs = logCleanerDeleteRetentionMs;
            return this;
        }

        /**
         * @param logCleanerDeleteRetentionMs How long are delete records retained?
         * 
         * @return builder
         * 
         */
        public Builder logCleanerDeleteRetentionMs(Integer logCleanerDeleteRetentionMs) {
            return logCleanerDeleteRetentionMs(Output.of(logCleanerDeleteRetentionMs));
        }

        /**
         * @param logCleanerMinCompactionLagMs The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
         * 
         * @return builder
         * 
         */
        public Builder logCleanerMinCompactionLagMs(@Nullable Output<String> logCleanerMinCompactionLagMs) {
            $.logCleanerMinCompactionLagMs = logCleanerMinCompactionLagMs;
            return this;
        }

        /**
         * @param logCleanerMinCompactionLagMs The minimum time a message will remain uncompacted in the log. Only applicable for logs that are being compacted.
         * 
         * @return builder
         * 
         */
        public Builder logCleanerMinCompactionLagMs(String logCleanerMinCompactionLagMs) {
            return logCleanerMinCompactionLagMs(Output.of(logCleanerMinCompactionLagMs));
        }

        /**
         * @param logFlushIntervalMs The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used.
         * 
         * @return builder
         * 
         */
        public Builder logFlushIntervalMs(@Nullable Output<String> logFlushIntervalMs) {
            $.logFlushIntervalMs = logFlushIntervalMs;
            return this;
        }

        /**
         * @param logFlushIntervalMs The maximum time in ms that a message in any topic is kept in memory before flushed to disk. If not set, the value in log.flush.scheduler.interval.ms is used.
         * 
         * @return builder
         * 
         */
        public Builder logFlushIntervalMs(String logFlushIntervalMs) {
            return logFlushIntervalMs(Output.of(logFlushIntervalMs));
        }

        /**
         * @param logIndexIntervalBytes The interval with which Kafka adds an entry to the offset index.
         * 
         * @return builder
         * 
         */
        public Builder logIndexIntervalBytes(@Nullable Output<Integer> logIndexIntervalBytes) {
            $.logIndexIntervalBytes = logIndexIntervalBytes;
            return this;
        }

        /**
         * @param logIndexIntervalBytes The interval with which Kafka adds an entry to the offset index.
         * 
         * @return builder
         * 
         */
        public Builder logIndexIntervalBytes(Integer logIndexIntervalBytes) {
            return logIndexIntervalBytes(Output.of(logIndexIntervalBytes));
        }

        /**
         * @param logMessageDownconversionEnable This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests.
         * 
         * @return builder
         * 
         */
        public Builder logMessageDownconversionEnable(@Nullable Output<Boolean> logMessageDownconversionEnable) {
            $.logMessageDownconversionEnable = logMessageDownconversionEnable;
            return this;
        }

        /**
         * @param logMessageDownconversionEnable This configuration controls whether down-conversion of message formats is enabled to satisfy consume requests.
         * 
         * @return builder
         * 
         */
        public Builder logMessageDownconversionEnable(Boolean logMessageDownconversionEnable) {
            return logMessageDownconversionEnable(Output.of(logMessageDownconversionEnable));
        }

        /**
         * @param logMessageTimestampDifferenceMaxMs The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message.
         * 
         * @return builder
         * 
         */
        public Builder logMessageTimestampDifferenceMaxMs(@Nullable Output<String> logMessageTimestampDifferenceMaxMs) {
            $.logMessageTimestampDifferenceMaxMs = logMessageTimestampDifferenceMaxMs;
            return this;
        }

        /**
         * @param logMessageTimestampDifferenceMaxMs The maximum difference allowed between the timestamp when a broker receives a message and the timestamp specified in the message.
         * 
         * @return builder
         * 
         */
        public Builder logMessageTimestampDifferenceMaxMs(String logMessageTimestampDifferenceMaxMs) {
            return logMessageTimestampDifferenceMaxMs(Output.of(logMessageTimestampDifferenceMaxMs));
        }

        /**
         * @param logPreallocate Controls whether to preallocate a file when creating a new segment.
         * 
         * @return builder
         * 
         */
        public Builder logPreallocate(@Nullable Output<Boolean> logPreallocate) {
            $.logPreallocate = logPreallocate;
            return this;
        }

        /**
         * @param logPreallocate Controls whether to preallocate a file when creating a new segment.
         * 
         * @return builder
         * 
         */
        public Builder logPreallocate(Boolean logPreallocate) {
            return logPreallocate(Output.of(logPreallocate));
        }

        /**
         * @param logRetentionBytes The maximum size of the log before deleting messages.
         * 
         * @return builder
         * 
         */
        public Builder logRetentionBytes(@Nullable Output<String> logRetentionBytes) {
            $.logRetentionBytes = logRetentionBytes;
            return this;
        }

        /**
         * @param logRetentionBytes The maximum size of the log before deleting messages.
         * 
         * @return builder
         * 
         */
        public Builder logRetentionBytes(String logRetentionBytes) {
            return logRetentionBytes(Output.of(logRetentionBytes));
        }

        /**
         * @param logRetentionHours The number of hours to keep a log file before deleting it.
         * 
         * @return builder
         * 
         */
        public Builder logRetentionHours(@Nullable Output<Integer> logRetentionHours) {
            $.logRetentionHours = logRetentionHours;
            return this;
        }

        /**
         * @param logRetentionHours The number of hours to keep a log file before deleting it.
         * 
         * @return builder
         * 
         */
        public Builder logRetentionHours(Integer logRetentionHours) {
            return logRetentionHours(Output.of(logRetentionHours));
        }

        /**
         * @param logRetentionMs The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
         * 
         * @return builder
         * 
         */
        public Builder logRetentionMs(@Nullable Output<String> logRetentionMs) {
            $.logRetentionMs = logRetentionMs;
            return this;
        }

        /**
         * @param logRetentionMs The number of milliseconds to keep a log file before deleting it (in milliseconds), If not set, the value in log.retention.minutes is used. If set to -1, no time limit is applied.
         * 
         * @return builder
         * 
         */
        public Builder logRetentionMs(String logRetentionMs) {
            return logRetentionMs(Output.of(logRetentionMs));
        }

        /**
         * @param logRollJitterMs The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used.
         * 
         * @return builder
         * 
         */
        public Builder logRollJitterMs(@Nullable Output<String> logRollJitterMs) {
            $.logRollJitterMs = logRollJitterMs;
            return this;
        }

        /**
         * @param logRollJitterMs The maximum jitter to subtract from logRollTimeMillis (in milliseconds). If not set, the value in log.roll.jitter.hours is used.
         * 
         * @return builder
         * 
         */
        public Builder logRollJitterMs(String logRollJitterMs) {
            return logRollJitterMs(Output.of(logRollJitterMs));
        }

        /**
         * @param logSegmentDeleteDelayMs The amount of time to wait before deleting a file from the filesystem.
         * 
         * @return builder
         * 
         */
        public Builder logSegmentDeleteDelayMs(@Nullable Output<Integer> logSegmentDeleteDelayMs) {
            $.logSegmentDeleteDelayMs = logSegmentDeleteDelayMs;
            return this;
        }

        /**
         * @param logSegmentDeleteDelayMs The amount of time to wait before deleting a file from the filesystem.
         * 
         * @return builder
         * 
         */
        public Builder logSegmentDeleteDelayMs(Integer logSegmentDeleteDelayMs) {
            return logSegmentDeleteDelayMs(Output.of(logSegmentDeleteDelayMs));
        }

        /**
         * @param messageMaxBytes The maximum size of message that the server can receive.
         * 
         * @return builder
         * 
         */
        public Builder messageMaxBytes(@Nullable Output<Integer> messageMaxBytes) {
            $.messageMaxBytes = messageMaxBytes;
            return this;
        }

        /**
         * @param messageMaxBytes The maximum size of message that the server can receive.
         * 
         * @return builder
         * 
         */
        public Builder messageMaxBytes(Integer messageMaxBytes) {
            return messageMaxBytes(Output.of(messageMaxBytes));
        }

        public DatabaseKafkaConfigArgs build() {
            if ($.clusterId == null) {
                throw new MissingRequiredPropertyException("DatabaseKafkaConfigArgs", "clusterId");
            }
            return $;
        }
    }

}
