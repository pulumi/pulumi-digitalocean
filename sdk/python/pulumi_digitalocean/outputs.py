# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from . import outputs
from ._enums import *

__all__ = [
    'AppDedicatedIp',
    'AppSpec',
    'AppSpecAlert',
    'AppSpecAlertDestinations',
    'AppSpecAlertDestinationsSlackWebhook',
    'AppSpecDatabase',
    'AppSpecDomainName',
    'AppSpecEgress',
    'AppSpecEnv',
    'AppSpecFunction',
    'AppSpecFunctionAlert',
    'AppSpecFunctionAlertDestinations',
    'AppSpecFunctionAlertDestinationsSlackWebhook',
    'AppSpecFunctionBitbucket',
    'AppSpecFunctionCors',
    'AppSpecFunctionCorsAllowOrigins',
    'AppSpecFunctionEnv',
    'AppSpecFunctionGit',
    'AppSpecFunctionGithub',
    'AppSpecFunctionGitlab',
    'AppSpecFunctionLogDestination',
    'AppSpecFunctionLogDestinationDatadog',
    'AppSpecFunctionLogDestinationLogtail',
    'AppSpecFunctionLogDestinationOpenSearch',
    'AppSpecFunctionLogDestinationOpenSearchBasicAuth',
    'AppSpecFunctionLogDestinationPapertrail',
    'AppSpecFunctionRoute',
    'AppSpecIngress',
    'AppSpecIngressRule',
    'AppSpecIngressRuleComponent',
    'AppSpecIngressRuleCors',
    'AppSpecIngressRuleCorsAllowOrigins',
    'AppSpecIngressRuleMatch',
    'AppSpecIngressRuleMatchAuthority',
    'AppSpecIngressRuleMatchPath',
    'AppSpecIngressRuleRedirect',
    'AppSpecJob',
    'AppSpecJobAlert',
    'AppSpecJobAlertDestinations',
    'AppSpecJobAlertDestinationsSlackWebhook',
    'AppSpecJobBitbucket',
    'AppSpecJobEnv',
    'AppSpecJobGit',
    'AppSpecJobGithub',
    'AppSpecJobGitlab',
    'AppSpecJobImage',
    'AppSpecJobImageDeployOnPush',
    'AppSpecJobLogDestination',
    'AppSpecJobLogDestinationDatadog',
    'AppSpecJobLogDestinationLogtail',
    'AppSpecJobLogDestinationOpenSearch',
    'AppSpecJobLogDestinationOpenSearchBasicAuth',
    'AppSpecJobLogDestinationPapertrail',
    'AppSpecJobTermination',
    'AppSpecMaintenance',
    'AppSpecService',
    'AppSpecServiceAlert',
    'AppSpecServiceAlertDestinations',
    'AppSpecServiceAlertDestinationsSlackWebhook',
    'AppSpecServiceAutoscaling',
    'AppSpecServiceAutoscalingMetrics',
    'AppSpecServiceAutoscalingMetricsCpu',
    'AppSpecServiceBitbucket',
    'AppSpecServiceCors',
    'AppSpecServiceCorsAllowOrigins',
    'AppSpecServiceEnv',
    'AppSpecServiceGit',
    'AppSpecServiceGithub',
    'AppSpecServiceGitlab',
    'AppSpecServiceHealthCheck',
    'AppSpecServiceImage',
    'AppSpecServiceImageDeployOnPush',
    'AppSpecServiceLogDestination',
    'AppSpecServiceLogDestinationDatadog',
    'AppSpecServiceLogDestinationLogtail',
    'AppSpecServiceLogDestinationOpenSearch',
    'AppSpecServiceLogDestinationOpenSearchBasicAuth',
    'AppSpecServiceLogDestinationPapertrail',
    'AppSpecServiceRoute',
    'AppSpecServiceTermination',
    'AppSpecStaticSite',
    'AppSpecStaticSiteBitbucket',
    'AppSpecStaticSiteCors',
    'AppSpecStaticSiteCorsAllowOrigins',
    'AppSpecStaticSiteEnv',
    'AppSpecStaticSiteGit',
    'AppSpecStaticSiteGithub',
    'AppSpecStaticSiteGitlab',
    'AppSpecStaticSiteRoute',
    'AppSpecVpc',
    'AppSpecWorker',
    'AppSpecWorkerAlert',
    'AppSpecWorkerAlertDestinations',
    'AppSpecWorkerAlertDestinationsSlackWebhook',
    'AppSpecWorkerAutoscaling',
    'AppSpecWorkerAutoscalingMetrics',
    'AppSpecWorkerAutoscalingMetricsCpu',
    'AppSpecWorkerBitbucket',
    'AppSpecWorkerEnv',
    'AppSpecWorkerGit',
    'AppSpecWorkerGithub',
    'AppSpecWorkerGitlab',
    'AppSpecWorkerImage',
    'AppSpecWorkerImageDeployOnPush',
    'AppSpecWorkerLogDestination',
    'AppSpecWorkerLogDestinationDatadog',
    'AppSpecWorkerLogDestinationLogtail',
    'AppSpecWorkerLogDestinationOpenSearch',
    'AppSpecWorkerLogDestinationOpenSearchBasicAuth',
    'AppSpecWorkerLogDestinationPapertrail',
    'AppSpecWorkerTermination',
    'DatabaseClusterBackupRestore',
    'DatabaseClusterMaintenanceWindow',
    'DatabaseFirewallRule',
    'DatabaseKafkaTopicConfig',
    'DatabaseOnlineMigrationSource',
    'DatabasePostgresqlConfigPgbouncer',
    'DatabasePostgresqlConfigTimescaledb',
    'DatabaseUserSetting',
    'DatabaseUserSettingAcl',
    'DatabaseUserSettingOpensearchAcl',
    'DropletAutoscaleConfig',
    'DropletAutoscaleCurrentUtilization',
    'DropletAutoscaleDropletTemplate',
    'DropletBackupPolicy',
    'FirewallInboundRule',
    'FirewallOutboundRule',
    'FirewallPendingChange',
    'GenaiAgentAgentGuardrail',
    'GenaiAgentAnthropicApiKey',
    'GenaiAgentApiKey',
    'GenaiAgentApiKeyInfo',
    'GenaiAgentChatbot',
    'GenaiAgentChatbotIdentifier',
    'GenaiAgentChildAgent',
    'GenaiAgentChildAgentAnthropicApiKey',
    'GenaiAgentChildAgentApiKey',
    'GenaiAgentChildAgentApiKeyInfo',
    'GenaiAgentChildAgentChatbot',
    'GenaiAgentChildAgentChatbotIdentifier',
    'GenaiAgentChildAgentDeployment',
    'GenaiAgentDeployment',
    'GenaiAgentFunction',
    'GenaiAgentKnowledgeBase',
    'GenaiAgentKnowledgeBaseLastIndexingJob',
    'GenaiAgentModel',
    'GenaiAgentModelAgreement',
    'GenaiAgentModelVersion',
    'GenaiAgentOpenAiApiKey',
    'GenaiAgentParentAgent',
    'GenaiAgentParentAgentAnthropicApiKey',
    'GenaiAgentParentAgentApiKey',
    'GenaiAgentParentAgentApiKeyInfo',
    'GenaiAgentParentAgentChatbot',
    'GenaiAgentParentAgentChatbotIdentifier',
    'GenaiAgentParentAgentDeployment',
    'GenaiAgentTemplate',
    'GenaiAgentTemplateKnowledgeBase',
    'GenaiAgentTemplateKnowledgeBaseLastIndexingJob',
    'GenaiAgentTemplateModel',
    'GenaiAgentTemplateModelAgreement',
    'GenaiAgentTemplateModelVersion',
    'GenaiKnowledgeBaseDataSource',
    'GenaiKnowledgeBaseDataSourceFileUploadDataSource',
    'GenaiKnowledgeBaseDataSourceLastIndexingJob',
    'GenaiKnowledgeBaseDataSourceSpacesDataSource',
    'GenaiKnowledgeBaseDataSourceWebCrawlerDataSource',
    'GenaiKnowledgeBaseLastIndexingJob',
    'GenaiOpenaiApiKeyModel',
    'GenaiOpenaiApiKeyModelAgreement',
    'GenaiOpenaiApiKeyModelVersion',
    'KubernetesClusterAmdGpuDeviceMetricsExporterPlugin',
    'KubernetesClusterAmdGpuDevicePlugin',
    'KubernetesClusterClusterAutoscalerConfiguration',
    'KubernetesClusterControlPlaneFirewall',
    'KubernetesClusterKubeConfig',
    'KubernetesClusterMaintenancePolicy',
    'KubernetesClusterNodePool',
    'KubernetesClusterNodePoolNode',
    'KubernetesClusterNodePoolTaint',
    'KubernetesClusterRoutingAgent',
    'KubernetesNodePoolNode',
    'KubernetesNodePoolTaint',
    'LoadBalancerDomain',
    'LoadBalancerFirewall',
    'LoadBalancerForwardingRule',
    'LoadBalancerGlbSettings',
    'LoadBalancerGlbSettingsCdn',
    'LoadBalancerHealthcheck',
    'LoadBalancerStickySessions',
    'MonitorAlertAlerts',
    'MonitorAlertAlertsSlack',
    'PartnerAttachmentBgp',
    'SpacesBucketCorsConfigurationCorsRule',
    'SpacesBucketCorsRule',
    'SpacesBucketLifecycleRule',
    'SpacesBucketLifecycleRuleExpiration',
    'SpacesBucketLifecycleRuleNoncurrentVersionExpiration',
    'SpacesBucketVersioning',
    'SpacesKeyGrant',
    'UptimeAlertNotification',
    'UptimeAlertNotificationSlack',
    'VpcNatGatewayEgress',
    'VpcNatGatewayEgressPublicGateway',
    'VpcNatGatewayVpc',
    'GetAppDedicatedIpResult',
    'GetAppSpecResult',
    'GetAppSpecAlertResult',
    'GetAppSpecAlertDestinationsResult',
    'GetAppSpecAlertDestinationsSlackWebhookResult',
    'GetAppSpecDatabaseResult',
    'GetAppSpecDomainResult',
    'GetAppSpecEgressResult',
    'GetAppSpecEnvResult',
    'GetAppSpecFunctionResult',
    'GetAppSpecFunctionAlertResult',
    'GetAppSpecFunctionAlertDestinationsResult',
    'GetAppSpecFunctionAlertDestinationsSlackWebhookResult',
    'GetAppSpecFunctionBitbucketResult',
    'GetAppSpecFunctionCorsResult',
    'GetAppSpecFunctionCorsAllowOriginsResult',
    'GetAppSpecFunctionEnvResult',
    'GetAppSpecFunctionGitResult',
    'GetAppSpecFunctionGithubResult',
    'GetAppSpecFunctionGitlabResult',
    'GetAppSpecFunctionLogDestinationResult',
    'GetAppSpecFunctionLogDestinationDatadogResult',
    'GetAppSpecFunctionLogDestinationLogtailResult',
    'GetAppSpecFunctionLogDestinationOpenSearchResult',
    'GetAppSpecFunctionLogDestinationOpenSearchBasicAuthResult',
    'GetAppSpecFunctionLogDestinationPapertrailResult',
    'GetAppSpecFunctionRouteResult',
    'GetAppSpecIngressResult',
    'GetAppSpecIngressRuleResult',
    'GetAppSpecIngressRuleComponentResult',
    'GetAppSpecIngressRuleCorsResult',
    'GetAppSpecIngressRuleCorsAllowOriginsResult',
    'GetAppSpecIngressRuleMatchResult',
    'GetAppSpecIngressRuleMatchAuthorityResult',
    'GetAppSpecIngressRuleMatchPathResult',
    'GetAppSpecIngressRuleRedirectResult',
    'GetAppSpecJobResult',
    'GetAppSpecJobAlertResult',
    'GetAppSpecJobAlertDestinationsResult',
    'GetAppSpecJobAlertDestinationsSlackWebhookResult',
    'GetAppSpecJobBitbucketResult',
    'GetAppSpecJobEnvResult',
    'GetAppSpecJobGitResult',
    'GetAppSpecJobGithubResult',
    'GetAppSpecJobGitlabResult',
    'GetAppSpecJobImageResult',
    'GetAppSpecJobImageDeployOnPushResult',
    'GetAppSpecJobLogDestinationResult',
    'GetAppSpecJobLogDestinationDatadogResult',
    'GetAppSpecJobLogDestinationLogtailResult',
    'GetAppSpecJobLogDestinationOpenSearchResult',
    'GetAppSpecJobLogDestinationOpenSearchBasicAuthResult',
    'GetAppSpecJobLogDestinationPapertrailResult',
    'GetAppSpecJobTerminationResult',
    'GetAppSpecMaintenanceResult',
    'GetAppSpecServiceResult',
    'GetAppSpecServiceAlertResult',
    'GetAppSpecServiceAlertDestinationsResult',
    'GetAppSpecServiceAlertDestinationsSlackWebhookResult',
    'GetAppSpecServiceAutoscalingResult',
    'GetAppSpecServiceAutoscalingMetricsResult',
    'GetAppSpecServiceAutoscalingMetricsCpuResult',
    'GetAppSpecServiceBitbucketResult',
    'GetAppSpecServiceCorsResult',
    'GetAppSpecServiceCorsAllowOriginsResult',
    'GetAppSpecServiceEnvResult',
    'GetAppSpecServiceGitResult',
    'GetAppSpecServiceGithubResult',
    'GetAppSpecServiceGitlabResult',
    'GetAppSpecServiceHealthCheckResult',
    'GetAppSpecServiceImageResult',
    'GetAppSpecServiceImageDeployOnPushResult',
    'GetAppSpecServiceLogDestinationResult',
    'GetAppSpecServiceLogDestinationDatadogResult',
    'GetAppSpecServiceLogDestinationLogtailResult',
    'GetAppSpecServiceLogDestinationOpenSearchResult',
    'GetAppSpecServiceLogDestinationOpenSearchBasicAuthResult',
    'GetAppSpecServiceLogDestinationPapertrailResult',
    'GetAppSpecServiceRouteResult',
    'GetAppSpecServiceTerminationResult',
    'GetAppSpecStaticSiteResult',
    'GetAppSpecStaticSiteBitbucketResult',
    'GetAppSpecStaticSiteCorsResult',
    'GetAppSpecStaticSiteCorsAllowOriginsResult',
    'GetAppSpecStaticSiteEnvResult',
    'GetAppSpecStaticSiteGitResult',
    'GetAppSpecStaticSiteGithubResult',
    'GetAppSpecStaticSiteGitlabResult',
    'GetAppSpecStaticSiteRouteResult',
    'GetAppSpecVpcResult',
    'GetAppSpecWorkerResult',
    'GetAppSpecWorkerAlertResult',
    'GetAppSpecWorkerAlertDestinationsResult',
    'GetAppSpecWorkerAlertDestinationsSlackWebhookResult',
    'GetAppSpecWorkerAutoscalingResult',
    'GetAppSpecWorkerAutoscalingMetricsResult',
    'GetAppSpecWorkerAutoscalingMetricsCpuResult',
    'GetAppSpecWorkerBitbucketResult',
    'GetAppSpecWorkerEnvResult',
    'GetAppSpecWorkerGitResult',
    'GetAppSpecWorkerGithubResult',
    'GetAppSpecWorkerGitlabResult',
    'GetAppSpecWorkerImageResult',
    'GetAppSpecWorkerImageDeployOnPushResult',
    'GetAppSpecWorkerLogDestinationResult',
    'GetAppSpecWorkerLogDestinationDatadogResult',
    'GetAppSpecWorkerLogDestinationLogtailResult',
    'GetAppSpecWorkerLogDestinationOpenSearchResult',
    'GetAppSpecWorkerLogDestinationOpenSearchBasicAuthResult',
    'GetAppSpecWorkerLogDestinationPapertrailResult',
    'GetAppSpecWorkerTerminationResult',
    'GetDatabaseClusterMaintenanceWindowResult',
    'GetDatabaseUserSettingResult',
    'GetDatabaseUserSettingAclResult',
    'GetDatabaseUserSettingOpensearchAclResult',
    'GetDomainsDomainResult',
    'GetDomainsFilterResult',
    'GetDomainsSortResult',
    'GetDropletAutoscaleConfigResult',
    'GetDropletAutoscaleCurrentUtilizationResult',
    'GetDropletAutoscaleDropletTemplateResult',
    'GetDropletsDropletResult',
    'GetDropletsFilterResult',
    'GetDropletsSortResult',
    'GetFirewallInboundRuleResult',
    'GetFirewallOutboundRuleResult',
    'GetFirewallPendingChangeResult',
    'GetGenaiAgentAgentGuardrailResult',
    'GetGenaiAgentAnthropicApiKeyResult',
    'GetGenaiAgentApiKeyResult',
    'GetGenaiAgentApiKeyInfoResult',
    'GetGenaiAgentChatbotResult',
    'GetGenaiAgentChatbotIdentifierResult',
    'GetGenaiAgentChildAgentResult',
    'GetGenaiAgentChildAgentAnthropicApiKeyResult',
    'GetGenaiAgentChildAgentApiKeyResult',
    'GetGenaiAgentChildAgentApiKeyInfoResult',
    'GetGenaiAgentChildAgentChatbotResult',
    'GetGenaiAgentChildAgentChatbotIdentifierResult',
    'GetGenaiAgentChildAgentDeploymentResult',
    'GetGenaiAgentDeploymentResult',
    'GetGenaiAgentFunctionResult',
    'GetGenaiAgentKnowledgeBaseResult',
    'GetGenaiAgentKnowledgeBaseLastIndexingJobResult',
    'GetGenaiAgentModelResult',
    'GetGenaiAgentModelAgreementResult',
    'GetGenaiAgentModelVersionResult',
    'GetGenaiAgentOpenAiApiKeyResult',
    'GetGenaiAgentParentAgentResult',
    'GetGenaiAgentParentAgentAnthropicApiKeyResult',
    'GetGenaiAgentParentAgentApiKeyResult',
    'GetGenaiAgentParentAgentApiKeyInfoResult',
    'GetGenaiAgentParentAgentChatbotResult',
    'GetGenaiAgentParentAgentChatbotIdentifierResult',
    'GetGenaiAgentParentAgentDeploymentResult',
    'GetGenaiAgentTemplateResult',
    'GetGenaiAgentTemplateKnowledgeBaseResult',
    'GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobResult',
    'GetGenaiAgentTemplateModelResult',
    'GetGenaiAgentTemplateModelAgreementResult',
    'GetGenaiAgentTemplateModelVersionResult',
    'GetGenaiAgentVersionsAgentVersionResult',
    'GetGenaiAgentVersionsAgentVersionAttachedChildAgentResult',
    'GetGenaiAgentVersionsAgentVersionAttachedFunctionResult',
    'GetGenaiAgentVersionsAgentVersionAttachedGuardrailResult',
    'GetGenaiAgentVersionsAgentVersionAttachedKnowledgeBaseResult',
    'GetGenaiAgentVersionsFilterResult',
    'GetGenaiAgentVersionsSortResult',
    'GetGenaiAgentsAgentResult',
    'GetGenaiAgentsAgentAgentGuardrailResult',
    'GetGenaiAgentsAgentAnthropicApiKeyResult',
    'GetGenaiAgentsAgentApiKeyResult',
    'GetGenaiAgentsAgentApiKeyInfoResult',
    'GetGenaiAgentsAgentChatbotResult',
    'GetGenaiAgentsAgentChatbotIdentifierResult',
    'GetGenaiAgentsAgentChildAgentResult',
    'GetGenaiAgentsAgentChildAgentAnthropicApiKeyResult',
    'GetGenaiAgentsAgentChildAgentApiKeyResult',
    'GetGenaiAgentsAgentChildAgentApiKeyInfoResult',
    'GetGenaiAgentsAgentChildAgentChatbotResult',
    'GetGenaiAgentsAgentChildAgentChatbotIdentifierResult',
    'GetGenaiAgentsAgentChildAgentDeploymentResult',
    'GetGenaiAgentsAgentDeploymentResult',
    'GetGenaiAgentsAgentFunctionResult',
    'GetGenaiAgentsAgentKnowledgeBaseResult',
    'GetGenaiAgentsAgentKnowledgeBaseLastIndexingJobResult',
    'GetGenaiAgentsAgentModelResult',
    'GetGenaiAgentsAgentModelAgreementResult',
    'GetGenaiAgentsAgentModelVersionResult',
    'GetGenaiAgentsAgentOpenAiApiKeyResult',
    'GetGenaiAgentsAgentParentAgentResult',
    'GetGenaiAgentsAgentParentAgentAnthropicApiKeyResult',
    'GetGenaiAgentsAgentParentAgentApiKeyResult',
    'GetGenaiAgentsAgentParentAgentApiKeyInfoResult',
    'GetGenaiAgentsAgentParentAgentChatbotResult',
    'GetGenaiAgentsAgentParentAgentChatbotIdentifierResult',
    'GetGenaiAgentsAgentParentAgentDeploymentResult',
    'GetGenaiAgentsAgentTemplateResult',
    'GetGenaiAgentsAgentTemplateKnowledgeBaseResult',
    'GetGenaiAgentsAgentTemplateKnowledgeBaseLastIndexingJobResult',
    'GetGenaiAgentsAgentTemplateModelResult',
    'GetGenaiAgentsAgentTemplateModelAgreementResult',
    'GetGenaiAgentsAgentTemplateModelVersionResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentAgentGuardrailResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentAnthropicApiKeyResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentApiKeyResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentApiKeyInfoResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChatbotResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChatbotIdentifierResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChildAgentResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChildAgentAnthropicApiKeyResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyInfoResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotIdentifierResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentChildAgentDeploymentResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentDeploymentResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentFunctionResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseLastIndexingJobResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentModelResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentModelAgreementResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentModelVersionResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentOpenAiApiKeyResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentParentAgentResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentParentAgentAnthropicApiKeyResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyInfoResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotIdentifierResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentParentAgentDeploymentResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentTemplateResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseLastIndexingJobResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelAgreementResult',
    'GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelVersionResult',
    'GetGenaiAgentsFilterResult',
    'GetGenaiAgentsSortResult',
    'GetGenaiKnowledgeBaseDataSourcesDatasourceResult',
    'GetGenaiKnowledgeBaseDataSourcesDatasourceFileUploadDataSourceResult',
    'GetGenaiKnowledgeBaseDataSourcesDatasourceLastIndexingJobResult',
    'GetGenaiKnowledgeBaseDataSourcesDatasourceSpacesDataSourceResult',
    'GetGenaiKnowledgeBaseDataSourcesDatasourceWebCrawlerDataSourceResult',
    'GetGenaiKnowledgeBaseLastIndexingJobResult',
    'GetGenaiKnowledgeBasesFilterResult',
    'GetGenaiKnowledgeBasesKnowledgeBaseResult',
    'GetGenaiKnowledgeBasesKnowledgeBaseLastIndexingJobResult',
    'GetGenaiKnowledgeBasesSortResult',
    'GetGenaiOpenaiApiKeyModelResult',
    'GetGenaiOpenaiApiKeyModelAgreementResult',
    'GetGenaiOpenaiApiKeyModelVersionResult',
    'GetGenaiOpenaiApiKeysFilterResult',
    'GetGenaiOpenaiApiKeysOpenaiApiKeyResult',
    'GetGenaiOpenaiApiKeysOpenaiApiKeyModelResult',
    'GetGenaiOpenaiApiKeysOpenaiApiKeyModelAgreementResult',
    'GetGenaiOpenaiApiKeysOpenaiApiKeyModelVersionResult',
    'GetGenaiOpenaiApiKeysSortResult',
    'GetImagesFilterResult',
    'GetImagesImageResult',
    'GetImagesSortResult',
    'GetKubernetesClusterAmdGpuDeviceMetricsExporterPluginResult',
    'GetKubernetesClusterAmdGpuDevicePluginResult',
    'GetKubernetesClusterClusterAutoscalerConfigurationResult',
    'GetKubernetesClusterControlPlaneFirewallResult',
    'GetKubernetesClusterKubeConfigResult',
    'GetKubernetesClusterMaintenancePolicyResult',
    'GetKubernetesClusterNodePoolResult',
    'GetKubernetesClusterNodePoolNodeResult',
    'GetKubernetesClusterNodePoolTaintResult',
    'GetKubernetesClusterRoutingAgentResult',
    'GetLoadBalancerDomainResult',
    'GetLoadBalancerFirewallResult',
    'GetLoadBalancerForwardingRuleResult',
    'GetLoadBalancerGlbSettingResult',
    'GetLoadBalancerGlbSettingCdnResult',
    'GetLoadBalancerHealthcheckResult',
    'GetLoadBalancerStickySessionResult',
    'GetPartnerAttachmentBgpResult',
    'GetProjectsFilterResult',
    'GetProjectsProjectResult',
    'GetProjectsSortResult',
    'GetRecordsFilterResult',
    'GetRecordsRecordResult',
    'GetRecordsSortResult',
    'GetRegionsFilterResult',
    'GetRegionsRegionResult',
    'GetRegionsSortResult',
    'GetSizesFilterResult',
    'GetSizesSizeResult',
    'GetSizesSortResult',
    'GetSpacesBucketsBucketResult',
    'GetSpacesBucketsFilterResult',
    'GetSpacesBucketsSortResult',
    'GetSpacesKeyGrantResult',
    'GetSshKeysFilterResult',
    'GetSshKeysSortResult',
    'GetSshKeysSshKeyResult',
    'GetTagsFilterResult',
    'GetTagsSortResult',
    'GetTagsTagResult',
    'GetVpcNatGatewayEgressResult',
    'GetVpcNatGatewayEgressPublicGatewayResult',
    'GetVpcNatGatewayVpcResult',
]

@pulumi.output_type
class AppDedicatedIp(dict):
    def __init__(__self__, *,
                 id: Optional[_builtins.str] = None,
                 ip: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str id: The ID of the app.
        :param _builtins.str ip: The IP address of the dedicated egress IP.
        :param _builtins.str status: The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The ID of the app.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[_builtins.str]:
        """
        The IP address of the dedicated egress IP.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class AppSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableEdgeCache":
            suggest = "disable_edge_cache"
        elif key == "disableEmailObfuscation":
            suggest = "disable_email_obfuscation"
        elif key == "domainNames":
            suggest = "domain_names"
        elif key == "enhancedThreatControlEnabled":
            suggest = "enhanced_threat_control_enabled"
        elif key == "staticSites":
            suggest = "static_sites"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.AppSpecAlert']] = None,
                 databases: Optional[Sequence['outputs.AppSpecDatabase']] = None,
                 disable_edge_cache: Optional[_builtins.bool] = None,
                 disable_email_obfuscation: Optional[_builtins.bool] = None,
                 domain_names: Optional[Sequence['outputs.AppSpecDomainName']] = None,
                 domains: Optional[Sequence[_builtins.str]] = None,
                 egresses: Optional[Sequence['outputs.AppSpecEgress']] = None,
                 enhanced_threat_control_enabled: Optional[_builtins.bool] = None,
                 envs: Optional[Sequence['outputs.AppSpecEnv']] = None,
                 features: Optional[Sequence[_builtins.str]] = None,
                 functions: Optional[Sequence['outputs.AppSpecFunction']] = None,
                 ingress: Optional['outputs.AppSpecIngress'] = None,
                 jobs: Optional[Sequence['outputs.AppSpecJob']] = None,
                 maintenance: Optional['outputs.AppSpecMaintenance'] = None,
                 region: Optional[_builtins.str] = None,
                 services: Optional[Sequence['outputs.AppSpecService']] = None,
                 static_sites: Optional[Sequence['outputs.AppSpecStaticSite']] = None,
                 vpcs: Optional[Sequence['outputs.AppSpecVpc']] = None,
                 workers: Optional[Sequence['outputs.AppSpecWorker']] = None):
        """
        :param _builtins.str name: The name of the component.
        :param Sequence['AppSpecAlertArgs'] alerts: Describes an alert policy for the component.
        :param _builtins.bool disable_edge_cache: A boolean indicating whether to disable the edge cache for this app. Default: `false`. Available only for non-static sites. Requires custom domains and applies to all the domains of the app.
        :param _builtins.bool disable_email_obfuscation: A boolean indicating whether to disable email obfuscation for this app. Default: `false`. Requires custom domains and applies to all the domains of the app.
        :param Sequence['AppSpecDomainNameArgs'] domain_names: Describes a domain where the application will be made available.
        :param Sequence['AppSpecEgressArgs'] egresses: Specification for app egress configurations.
        :param _builtins.bool enhanced_threat_control_enabled: A boolean, when set to `true`, enables enhanced analyzing of incoming traffic to prevent layer 7 DDoS attacks. Default: `false`. Requires custom domains and applies to all the domains of the app.
        :param Sequence['AppSpecEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param Sequence[_builtins.str] features: A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/reference/apps/list-buildpacks/)
        :param 'AppSpecIngressArgs' ingress: Specification for component routing, rewrites, and redirects.
        :param 'AppSpecMaintenanceArgs' maintenance: Specification to configure maintenance settings for the app, such as maintenance mode and archiving the app.
        :param _builtins.str region: The slug for the DigitalOcean data center region hosting the app.
        :param Sequence['AppSpecVpcArgs'] vpcs: Specification for VPC.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if disable_edge_cache is not None:
            pulumi.set(__self__, "disable_edge_cache", disable_edge_cache)
        if disable_email_obfuscation is not None:
            pulumi.set(__self__, "disable_email_obfuscation", disable_email_obfuscation)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if egresses is not None:
            pulumi.set(__self__, "egresses", egresses)
        if enhanced_threat_control_enabled is not None:
            pulumi.set(__self__, "enhanced_threat_control_enabled", enhanced_threat_control_enabled)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if maintenance is not None:
            pulumi.set(__self__, "maintenance", maintenance)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if static_sites is not None:
            pulumi.set(__self__, "static_sites", static_sites)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.AppSpecAlert']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Optional[Sequence['outputs.AppSpecDatabase']]:
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter(name="disableEdgeCache")
    def disable_edge_cache(self) -> Optional[_builtins.bool]:
        """
        A boolean indicating whether to disable the edge cache for this app. Default: `false`. Available only for non-static sites. Requires custom domains and applies to all the domains of the app.
        """
        return pulumi.get(self, "disable_edge_cache")

    @_builtins.property
    @pulumi.getter(name="disableEmailObfuscation")
    def disable_email_obfuscation(self) -> Optional[_builtins.bool]:
        """
        A boolean indicating whether to disable email obfuscation for this app. Default: `false`. Requires custom domains and applies to all the domains of the app.
        """
        return pulumi.get(self, "disable_email_obfuscation")

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[Sequence['outputs.AppSpecDomainName']]:
        """
        Describes a domain where the application will be made available.
        """
        return pulumi.get(self, "domain_names")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute has been replaced by `domain` which supports additional functionality.""")
    def domains(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def egresses(self) -> Optional[Sequence['outputs.AppSpecEgress']]:
        """
        Specification for app egress configurations.
        """
        return pulumi.get(self, "egresses")

    @_builtins.property
    @pulumi.getter(name="enhancedThreatControlEnabled")
    def enhanced_threat_control_enabled(self) -> Optional[_builtins.bool]:
        """
        A boolean, when set to `true`, enables enhanced analyzing of incoming traffic to prevent layer 7 DDoS attacks. Default: `false`. Requires custom domains and applies to all the domains of the app.
        """
        return pulumi.get(self, "enhanced_threat_control_enabled")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppSpecEnv']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def features(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/reference/apps/list-buildpacks/)
        """
        return pulumi.get(self, "features")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.AppSpecFunction']]:
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional['outputs.AppSpecIngress']:
        """
        Specification for component routing, rewrites, and redirects.
        """
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[Sequence['outputs.AppSpecJob']]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def maintenance(self) -> Optional['outputs.AppSpecMaintenance']:
        """
        Specification to configure maintenance settings for the app, such as maintenance mode and archiving the app.
        """
        return pulumi.get(self, "maintenance")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The slug for the DigitalOcean data center region hosting the app.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.AppSpecService']]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="staticSites")
    def static_sites(self) -> Optional[Sequence['outputs.AppSpecStaticSite']]:
        return pulumi.get(self, "static_sites")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.AppSpecVpc']]:
        """
        Specification for VPC.
        """
        return pulumi.get(self, "vpcs")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[Sequence['outputs.AppSpecWorker']]:
        return pulumi.get(self, "workers")


@pulumi.output_type
class AppSpecAlert(dict):
    def __init__(__self__, *,
                 rule: _builtins.str,
                 destinations: Optional['outputs.AppSpecAlertDestinations'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param 'AppSpecAlertDestinationsArgs' destinations: Specification for alert destination.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "rule", rule)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.AppSpecAlertDestinations']:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AppSpecAlertDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slackWebhooks":
            suggest = "slack_webhooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecAlertDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecAlertDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecAlertDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.AppSpecAlertDestinationsSlackWebhook']] = None):
        """
        :param Sequence[_builtins.str] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param Sequence['AppSpecAlertDestinationsSlackWebhookArgs'] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.AppSpecAlertDestinationsSlackWebhook']]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class AppSpecAlertDestinationsSlackWebhook(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AppSpecDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterName":
            suggest = "cluster_name"
        elif key == "dbName":
            suggest = "db_name"
        elif key == "dbUser":
            suggest = "db_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_name: Optional[_builtins.str] = None,
                 db_name: Optional[_builtins.str] = None,
                 db_user: Optional[_builtins.str] = None,
                 engine: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 production: Optional[_builtins.bool] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str db_name: The name of the MySQL or PostgreSQL database to configure.
        :param _builtins.str db_user: The name of the MySQL or PostgreSQL user to configure.
               
               This resource supports customized create timeouts. The default timeout is 30 minutes.
        :param _builtins.str engine: The database engine to use (`MYSQL`, `PG`, `REDIS`, `MONGODB`, `KAFKA`, or `OPENSEARCH`).
        :param _builtins.str name: The name of the component.
        :param _builtins.bool production: Whether this is a production or dev database.
        :param _builtins.str version: The version of the database engine.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if production is not None:
            pulumi.set(__self__, "production", production)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The name of the MySQL or PostgreSQL database to configure.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[_builtins.str]:
        """
        The name of the MySQL or PostgreSQL user to configure.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        return pulumi.get(self, "db_user")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        The database engine to use (`MYSQL`, `PG`, `REDIS`, `MONGODB`, `KAFKA`, or `OPENSEARCH`).
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def production(self) -> Optional[_builtins.bool]:
        """
        Whether this is a production or dev database.
        """
        return pulumi.get(self, "production")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the database engine.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class AppSpecDomainName(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: Optional[_builtins.str] = None,
                 wildcard: Optional[_builtins.bool] = None,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The hostname for the domain.
        :param _builtins.str type: The domain type, which can be one of the following:
               - `DEFAULT`: The default .ondigitalocean.app domain assigned to this app.
               - `PRIMARY`: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
               - `ALIAS`: A non-primary domain.
        :param _builtins.bool wildcard: A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
        :param _builtins.str zone: If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
        pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The hostname for the domain.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The domain type, which can be one of the following:
        - `DEFAULT`: The default .ondigitalocean.app domain assigned to this app.
        - `PRIMARY`: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
        - `ALIAS`: A non-primary domain.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def wildcard(self) -> Optional[_builtins.bool]:
        """
        A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
        """
        return pulumi.get(self, "wildcard")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class AppSpecEgress(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The app egress type: `AUTOASSIGN`, `DEDICATED_IP`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The app egress type: `AUTOASSIGN`, `DEDICATED_IP`
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AppSpecEnv(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppSpecFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "logDestinations":
            suggest = "log_destinations"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.AppSpecFunctionAlert']] = None,
                 bitbucket: Optional['outputs.AppSpecFunctionBitbucket'] = None,
                 cors: Optional['outputs.AppSpecFunctionCors'] = None,
                 envs: Optional[Sequence['outputs.AppSpecFunctionEnv']] = None,
                 git: Optional['outputs.AppSpecFunctionGit'] = None,
                 github: Optional['outputs.AppSpecFunctionGithub'] = None,
                 gitlab: Optional['outputs.AppSpecFunctionGitlab'] = None,
                 log_destinations: Optional[Sequence['outputs.AppSpecFunctionLogDestination']] = None,
                 routes: Optional[Sequence['outputs.AppSpecFunctionRoute']] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the component.
        :param Sequence['AppSpecFunctionAlertArgs'] alerts: Describes an alert policy for the component.
        :param 'AppSpecFunctionBitbucketArgs' bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'AppSpecFunctionCorsArgs' cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param Sequence['AppSpecFunctionEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'AppSpecFunctionGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param 'AppSpecFunctionGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param 'AppSpecFunctionGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param Sequence['AppSpecFunctionLogDestinationArgs'] log_destinations: Describes a log forwarding destination.
        :param Sequence['AppSpecFunctionRouteArgs'] routes: An HTTP paths that should be routed to this component.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.AppSpecFunctionAlert']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.AppSpecFunctionBitbucket']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional['outputs.AppSpecFunctionCors']:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppSpecFunctionEnv']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppSpecFunctionGit']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppSpecFunctionGithub']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppSpecFunctionGitlab']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[Sequence['outputs.AppSpecFunctionLogDestination']]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[Sequence['outputs.AppSpecFunctionRoute']]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class AppSpecFunctionAlert(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 rule: _builtins.str,
                 value: _builtins.float,
                 window: _builtins.str,
                 destinations: Optional['outputs.AppSpecFunctionAlertDestinations'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.float value: The threshold for the type of the warning.
        :param _builtins.str window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param 'AppSpecFunctionAlertDestinationsArgs' destinations: Specification for alert destination.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> _builtins.str:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.AppSpecFunctionAlertDestinations']:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AppSpecFunctionAlertDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slackWebhooks":
            suggest = "slack_webhooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionAlertDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionAlertDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionAlertDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.AppSpecFunctionAlertDestinationsSlackWebhook']] = None):
        """
        :param Sequence[_builtins.str] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param Sequence['AppSpecFunctionAlertDestinationsSlackWebhookArgs'] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.AppSpecFunctionAlertDestinationsSlackWebhook']]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class AppSpecFunctionAlertDestinationsSlackWebhook(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AppSpecFunctionBitbucket(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionBitbucket. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionBitbucket.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionBitbucket.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecFunctionCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional['outputs.AppSpecFunctionCorsAllowOrigins'] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param 'AppSpecFunctionCorsAllowOriginsArgs' allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional['outputs.AppSpecFunctionCorsAllowOrigins']:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class AppSpecFunctionCorsAllowOrigins(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Exact string match.
        :param _builtins.str prefix: Prefix-based match.
        :param _builtins.str regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AppSpecFunctionEnv(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppSpecFunctionGit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoCloneUrl":
            suggest = "repo_clone_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionGit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionGit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionGit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class AppSpecFunctionGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecFunctionGitlab(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionGitlab. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionGitlab.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionGitlab.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecFunctionLogDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openSearch":
            suggest = "open_search"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionLogDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionLogDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionLogDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.AppSpecFunctionLogDestinationDatadog'] = None,
                 logtail: Optional['outputs.AppSpecFunctionLogDestinationLogtail'] = None,
                 open_search: Optional['outputs.AppSpecFunctionLogDestinationOpenSearch'] = None,
                 papertrail: Optional['outputs.AppSpecFunctionLogDestinationPapertrail'] = None):
        """
        :param _builtins.str name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param 'AppSpecFunctionLogDestinationDatadogArgs' datadog: Datadog configuration.
        :param 'AppSpecFunctionLogDestinationLogtailArgs' logtail: Logtail configuration.
        :param 'AppSpecFunctionLogDestinationOpenSearchArgs' open_search: OpenSearch configuration.
        :param 'AppSpecFunctionLogDestinationPapertrailArgs' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.AppSpecFunctionLogDestinationDatadog']:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.AppSpecFunctionLogDestinationLogtail']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.AppSpecFunctionLogDestinationOpenSearch']:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.AppSpecFunctionLogDestinationPapertrail']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class AppSpecFunctionLogDestinationDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionLogDestinationDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionLogDestinationDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionLogDestinationDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppSpecFunctionLogDestinationLogtail(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class AppSpecFunctionLogDestinationOpenSearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "indexName":
            suggest = "index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionLogDestinationOpenSearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionLogDestinationOpenSearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionLogDestinationOpenSearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth: 'outputs.AppSpecFunctionLogDestinationOpenSearchBasicAuth',
                 cluster_name: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 index_name: Optional[_builtins.str] = None):
        """
        :param 'AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs' basic_auth: Basic authentication details.
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str endpoint: OpenSearch endpoint.
        :param _builtins.str index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.AppSpecFunctionLogDestinationOpenSearchBasicAuth':
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")


@pulumi.output_type
class AppSpecFunctionLogDestinationOpenSearchBasicAuth(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for basic authentication.
        :param _builtins.str user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class AppSpecFunctionLogDestinationPapertrail(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        :param _builtins.str endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppSpecFunctionRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preservePathPrefix":
            suggest = "preserve_path_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecFunctionRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecFunctionRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecFunctionRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 preserve_path_prefix: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: Paths must start with `/` and must be unique within the app.
        :param _builtins.bool preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.bool]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")


@pulumi.output_type
class AppSpecIngress(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.AppSpecIngressRule']] = None):
        """
        :param Sequence['AppSpecIngressRuleArgs'] rules: Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.AppSpecIngressRule']]:
        """
        Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class AppSpecIngressRule(dict):
    def __init__(__self__, *,
                 component: Optional['outputs.AppSpecIngressRuleComponent'] = None,
                 cors: Optional['outputs.AppSpecIngressRuleCors'] = None,
                 match: Optional['outputs.AppSpecIngressRuleMatch'] = None,
                 redirect: Optional['outputs.AppSpecIngressRuleRedirect'] = None):
        """
        :param 'AppSpecIngressRuleComponentArgs' component: The component to route to. Only one of `component` or `redirect` may be set.
        :param 'AppSpecIngressRuleCorsArgs' cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param 'AppSpecIngressRuleMatchArgs' match: The match configuration for the rule
        :param 'AppSpecIngressRuleRedirectArgs' redirect: The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional['outputs.AppSpecIngressRuleComponent']:
        """
        The component to route to. Only one of `component` or `redirect` may be set.
        """
        return pulumi.get(self, "component")

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional['outputs.AppSpecIngressRuleCors']:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional['outputs.AppSpecIngressRuleMatch']:
        """
        The match configuration for the rule
        """
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.AppSpecIngressRuleRedirect']:
        """
        The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
        return pulumi.get(self, "redirect")


@pulumi.output_type
class AppSpecIngressRuleComponent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preservePathPrefix":
            suggest = "preserve_path_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecIngressRuleComponent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecIngressRuleComponent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecIngressRuleComponent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 preserve_path_prefix: Optional[_builtins.bool] = None,
                 rewrite: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the component to route to.
        :param _builtins.bool preserve_path_prefix: An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
        :param _builtins.str rewrite: An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with `preserve_path_prefix`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)
        if rewrite is not None:
            pulumi.set(__self__, "rewrite", rewrite)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the component to route to.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.bool]:
        """
        An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @_builtins.property
    @pulumi.getter
    def rewrite(self) -> Optional[_builtins.str]:
        """
        An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with `preserve_path_prefix`.
        """
        return pulumi.get(self, "rewrite")


@pulumi.output_type
class AppSpecIngressRuleCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecIngressRuleCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecIngressRuleCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecIngressRuleCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional['outputs.AppSpecIngressRuleCorsAllowOrigins'] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        :param 'AppSpecIngressRuleCorsAllowOriginsArgs' allow_origins: The `Access-Control-Allow-Origin` can be
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional['outputs.AppSpecIngressRuleCorsAllowOrigins']:
        """
        The `Access-Control-Allow-Origin` can be
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class AppSpecIngressRuleCorsAllowOrigins(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        :param _builtins.str prefix: The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        :param _builtins.str regex: The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AppSpecIngressRuleMatch(dict):
    def __init__(__self__, *,
                 authority: Optional['outputs.AppSpecIngressRuleMatchAuthority'] = None,
                 path: Optional['outputs.AppSpecIngressRuleMatchPath'] = None):
        """
        :param 'AppSpecIngressRuleMatchAuthorityArgs' authority: The authority (domain) to match on.
        :param 'AppSpecIngressRuleMatchPathArgs' path: The path to match on.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional['outputs.AppSpecIngressRuleMatchAuthority']:
        """
        The authority (domain) to match on.
        """
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional['outputs.AppSpecIngressRuleMatchPath']:
        """
        The path to match on.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class AppSpecIngressRuleMatchAuthority(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Exact match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact match.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class AppSpecIngressRuleMatchPath(dict):
    def __init__(__self__, *,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str prefix: Prefix-based match.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class AppSpecIngressRuleRedirect(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectCode":
            suggest = "redirect_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecIngressRuleRedirect. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecIngressRuleRedirect.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecIngressRuleRedirect.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 authority: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 redirect_code: Optional[_builtins.int] = None,
                 scheme: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str authority: The authority/host to redirect to. This can be a hostname or IP address.
        :param _builtins.int port: The port to redirect to.
        :param _builtins.int redirect_code: The redirect code to use. Supported values are `300`, `301`, `302`, `303`, `304`, `307`, `308`.
        :param _builtins.str scheme: The scheme to redirect to. Supported values are `http` or `https`
        :param _builtins.str uri: An optional URI path to redirect to.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional[_builtins.str]:
        """
        The authority/host to redirect to. This can be a hostname or IP address.
        """
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port to redirect to.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[_builtins.int]:
        """
        The redirect code to use. Supported values are `300`, `301`, `302`, `303`, `304`, `307`, `308`.
        """
        return pulumi.get(self, "redirect_code")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        """
        The scheme to redirect to. Supported values are `http` or `https`
        """
        return pulumi.get(self, "scheme")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        An optional URI path to redirect to.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class AppSpecJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "environmentSlug":
            suggest = "environment_slug"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceSizeSlug":
            suggest = "instance_size_slug"
        elif key == "logDestinations":
            suggest = "log_destinations"
        elif key == "runCommand":
            suggest = "run_command"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.AppSpecJobAlert']] = None,
                 bitbucket: Optional['outputs.AppSpecJobBitbucket'] = None,
                 build_command: Optional[_builtins.str] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.AppSpecJobEnv']] = None,
                 git: Optional['outputs.AppSpecJobGit'] = None,
                 github: Optional['outputs.AppSpecJobGithub'] = None,
                 gitlab: Optional['outputs.AppSpecJobGitlab'] = None,
                 image: Optional['outputs.AppSpecJobImage'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 log_destinations: Optional[Sequence['outputs.AppSpecJobLogDestination']] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None,
                 termination: Optional['outputs.AppSpecJobTermination'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param Sequence['AppSpecJobAlertArgs'] alerts: Describes an alert policy for the component.
        :param 'AppSpecJobBitbucketArgs' bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app.
        :param Sequence['AppSpecJobEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'AppSpecJobGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param 'AppSpecJobGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param 'AppSpecJobGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param 'AppSpecJobImageArgs' image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to.
        :param _builtins.str instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param _builtins.str kind: The type of job and when it will be run during the deployment process. It may be one of:
               - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
               - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
               - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
               - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        :param Sequence['AppSpecJobLogDestinationArgs'] log_destinations: Describes a log forwarding destination.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        :param 'AppSpecJobTerminationArgs' termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.AppSpecJobAlert']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.AppSpecJobBitbucket']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppSpecJobEnv']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppSpecJobGit']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppSpecJobGithub']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppSpecJobGitlab']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.AppSpecJobImage']:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[_builtins.str]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        The type of job and when it will be run during the deployment process. It may be one of:
        - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
        - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
        - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
        - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[Sequence['outputs.AppSpecJobLogDestination']]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional['outputs.AppSpecJobTermination']:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")


@pulumi.output_type
class AppSpecJobAlert(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 rule: _builtins.str,
                 value: _builtins.float,
                 window: _builtins.str,
                 destinations: Optional['outputs.AppSpecJobAlertDestinations'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.float value: The threshold for the type of the warning.
        :param _builtins.str window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param 'AppSpecJobAlertDestinationsArgs' destinations: Specification for alert destination.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> _builtins.str:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.AppSpecJobAlertDestinations']:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AppSpecJobAlertDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slackWebhooks":
            suggest = "slack_webhooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobAlertDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobAlertDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobAlertDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.AppSpecJobAlertDestinationsSlackWebhook']] = None):
        """
        :param Sequence[_builtins.str] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param Sequence['AppSpecJobAlertDestinationsSlackWebhookArgs'] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.AppSpecJobAlertDestinationsSlackWebhook']]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class AppSpecJobAlertDestinationsSlackWebhook(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AppSpecJobBitbucket(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobBitbucket. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobBitbucket.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobBitbucket.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecJobEnv(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppSpecJobGit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoCloneUrl":
            suggest = "repo_clone_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobGit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobGit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobGit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class AppSpecJobGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecJobGitlab(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobGitlab. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobGitlab.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobGitlab.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecJobImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryType":
            suggest = "registry_type"
        elif key == "deployOnPushes":
            suggest = "deploy_on_pushes"
        elif key == "registryCredentials":
            suggest = "registry_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_type: _builtins.str,
                 repository: _builtins.str,
                 deploy_on_pushes: Optional[Sequence['outputs.AppSpecJobImageDeployOnPush']] = None,
                 digest: Optional[_builtins.str] = None,
                 registry: Optional[_builtins.str] = None,
                 registry_credentials: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param _builtins.str repository: The repository name.
        :param Sequence['AppSpecJobImageDeployOnPushArgs'] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param _builtins.str digest: The image digest. Cannot be specified if `tag` is provided.
        :param _builtins.str registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param _builtins.str registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param _builtins.str tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> _builtins.str:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> _builtins.str:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[Sequence['outputs.AppSpecJobImageDeployOnPush']]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[_builtins.str]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[_builtins.str]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[_builtins.str]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class AppSpecJobImageDeployOnPush(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AppSpecJobLogDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openSearch":
            suggest = "open_search"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobLogDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobLogDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobLogDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.AppSpecJobLogDestinationDatadog'] = None,
                 logtail: Optional['outputs.AppSpecJobLogDestinationLogtail'] = None,
                 open_search: Optional['outputs.AppSpecJobLogDestinationOpenSearch'] = None,
                 papertrail: Optional['outputs.AppSpecJobLogDestinationPapertrail'] = None):
        """
        :param _builtins.str name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param 'AppSpecJobLogDestinationDatadogArgs' datadog: Datadog configuration.
        :param 'AppSpecJobLogDestinationLogtailArgs' logtail: Logtail configuration.
        :param 'AppSpecJobLogDestinationOpenSearchArgs' open_search: OpenSearch configuration.
        :param 'AppSpecJobLogDestinationPapertrailArgs' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.AppSpecJobLogDestinationDatadog']:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.AppSpecJobLogDestinationLogtail']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.AppSpecJobLogDestinationOpenSearch']:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.AppSpecJobLogDestinationPapertrail']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class AppSpecJobLogDestinationDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobLogDestinationDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobLogDestinationDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobLogDestinationDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppSpecJobLogDestinationLogtail(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class AppSpecJobLogDestinationOpenSearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "indexName":
            suggest = "index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobLogDestinationOpenSearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobLogDestinationOpenSearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobLogDestinationOpenSearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth: 'outputs.AppSpecJobLogDestinationOpenSearchBasicAuth',
                 cluster_name: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 index_name: Optional[_builtins.str] = None):
        """
        :param 'AppSpecJobLogDestinationOpenSearchBasicAuthArgs' basic_auth: Basic authentication details.
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str endpoint: OpenSearch endpoint.
        :param _builtins.str index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.AppSpecJobLogDestinationOpenSearchBasicAuth':
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")


@pulumi.output_type
class AppSpecJobLogDestinationOpenSearchBasicAuth(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for basic authentication.
        :param _builtins.str user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class AppSpecJobLogDestinationPapertrail(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        :param _builtins.str endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppSpecJobTermination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriodSeconds":
            suggest = "grace_period_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecJobTermination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecJobTermination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecJobTermination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace_period_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
               
               A `function` component can contain:
        """
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
        return pulumi.get(self, "grace_period_seconds")


@pulumi.output_type
class AppSpecMaintenance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "offlinePageUrl":
            suggest = "offline_page_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecMaintenance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecMaintenance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecMaintenance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 archive: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 offline_page_url: Optional[_builtins.str] = None):
        """
        :param _builtins.bool archive: Indicates whether the app should be archived. Setting this to true implies that enabled is set to true.
        :param _builtins.bool enabled: Indicates whether maintenance mode should be enabled for the app.
        :param _builtins.str offline_page_url: A custom offline page to display when maintenance mode is enabled or the app is archived.
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if offline_page_url is not None:
            pulumi.set(__self__, "offline_page_url", offline_page_url)

    @_builtins.property
    @pulumi.getter
    def archive(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the app should be archived. Setting this to true implies that enabled is set to true.
        """
        return pulumi.get(self, "archive")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether maintenance mode should be enabled for the app.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="offlinePageUrl")
    def offline_page_url(self) -> Optional[_builtins.str]:
        """
        A custom offline page to display when maintenance mode is enabled or the app is archived.
        """
        return pulumi.get(self, "offline_page_url")


@pulumi.output_type
class AppSpecService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "environmentSlug":
            suggest = "environment_slug"
        elif key == "healthCheck":
            suggest = "health_check"
        elif key == "httpPort":
            suggest = "http_port"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceSizeSlug":
            suggest = "instance_size_slug"
        elif key == "internalPorts":
            suggest = "internal_ports"
        elif key == "logDestinations":
            suggest = "log_destinations"
        elif key == "runCommand":
            suggest = "run_command"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.AppSpecServiceAlert']] = None,
                 autoscaling: Optional['outputs.AppSpecServiceAutoscaling'] = None,
                 bitbucket: Optional['outputs.AppSpecServiceBitbucket'] = None,
                 build_command: Optional[_builtins.str] = None,
                 cors: Optional['outputs.AppSpecServiceCors'] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.AppSpecServiceEnv']] = None,
                 git: Optional['outputs.AppSpecServiceGit'] = None,
                 github: Optional['outputs.AppSpecServiceGithub'] = None,
                 gitlab: Optional['outputs.AppSpecServiceGitlab'] = None,
                 health_check: Optional['outputs.AppSpecServiceHealthCheck'] = None,
                 http_port: Optional[_builtins.int] = None,
                 image: Optional['outputs.AppSpecServiceImage'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional[_builtins.str] = None,
                 internal_ports: Optional[Sequence[_builtins.int]] = None,
                 log_destinations: Optional[Sequence['outputs.AppSpecServiceLogDestination']] = None,
                 routes: Optional[Sequence['outputs.AppSpecServiceRoute']] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None,
                 termination: Optional['outputs.AppSpecServiceTermination'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param Sequence['AppSpecServiceAlertArgs'] alerts: Describes an alert policy for the component.
        :param 'AppSpecServiceAutoscalingArgs' autoscaling: Configuration for automatically scaling this component based on metrics.
        :param 'AppSpecServiceBitbucketArgs' bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param 'AppSpecServiceCorsArgs' cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param _builtins.str dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app.
        :param Sequence['AppSpecServiceEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'AppSpecServiceGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param 'AppSpecServiceGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param 'AppSpecServiceGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param 'AppSpecServiceHealthCheckArgs' health_check: A health check to determine the availability of this component.
        :param _builtins.int http_port: The internal port on which this service's run command will listen.
        :param 'AppSpecServiceImageArgs' image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to.
        :param _builtins.str instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param Sequence[_builtins.int] internal_ports: A list of ports on which this service will listen for internal traffic.
        :param Sequence['AppSpecServiceLogDestinationArgs'] log_destinations: Describes a log forwarding destination.
        :param Sequence['AppSpecServiceRouteArgs'] routes: An HTTP paths that should be routed to this component.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        :param 'AppSpecServiceTerminationArgs' termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if internal_ports is not None:
            pulumi.set(__self__, "internal_ports", internal_ports)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.AppSpecServiceAlert']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.AppSpecServiceAutoscaling']:
        """
        Configuration for automatically scaling this component based on metrics.
        """
        return pulumi.get(self, "autoscaling")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.AppSpecServiceBitbucket']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional['outputs.AppSpecServiceCors']:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppSpecServiceEnv']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppSpecServiceGit']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppSpecServiceGithub']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppSpecServiceGitlab']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.AppSpecServiceHealthCheck']:
        """
        A health check to determine the availability of this component.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[_builtins.int]:
        """
        The internal port on which this service's run command will listen.
        """
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.AppSpecServiceImage']:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[_builtins.str]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter(name="internalPorts")
    def internal_ports(self) -> Optional[Sequence[_builtins.int]]:
        """
        A list of ports on which this service will listen for internal traffic.
        """
        return pulumi.get(self, "internal_ports")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[Sequence['outputs.AppSpecServiceLogDestination']]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[Sequence['outputs.AppSpecServiceRoute']]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional['outputs.AppSpecServiceTermination']:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")


@pulumi.output_type
class AppSpecServiceAlert(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 rule: _builtins.str,
                 value: _builtins.float,
                 window: _builtins.str,
                 destinations: Optional['outputs.AppSpecServiceAlertDestinations'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.float value: The threshold for the type of the warning.
        :param _builtins.str window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param 'AppSpecServiceAlertDestinationsArgs' destinations: Specification for alert destination.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> _builtins.str:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.AppSpecServiceAlertDestinations']:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AppSpecServiceAlertDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slackWebhooks":
            suggest = "slack_webhooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceAlertDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceAlertDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceAlertDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.AppSpecServiceAlertDestinationsSlackWebhook']] = None):
        """
        :param Sequence[_builtins.str] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param Sequence['AppSpecServiceAlertDestinationsSlackWebhookArgs'] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.AppSpecServiceAlertDestinationsSlackWebhook']]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class AppSpecServiceAlertDestinationsSlackWebhook(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AppSpecServiceAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: _builtins.int,
                 metrics: 'outputs.AppSpecServiceAutoscalingMetrics',
                 min_instance_count: _builtins.int):
        """
        :param _builtins.int max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count.
        :param 'AppSpecServiceAutoscalingMetricsArgs' metrics: The metrics that the component is scaled on.
        :param _builtins.int min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_instance_count", min_instance_count)

    @_builtins.property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> _builtins.int:
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        return pulumi.get(self, "max_instance_count")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> 'outputs.AppSpecServiceAutoscalingMetrics':
        """
        The metrics that the component is scaled on.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> _builtins.int:
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class AppSpecServiceAutoscalingMetrics(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.AppSpecServiceAutoscalingMetricsCpu'] = None):
        """
        :param 'AppSpecServiceAutoscalingMetricsCpuArgs' cpu: Settings for scaling the component based on CPU utilization.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.AppSpecServiceAutoscalingMetricsCpu']:
        """
        Settings for scaling the component based on CPU utilization.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class AppSpecServiceAutoscalingMetricsCpu(dict):
    def __init__(__self__, *,
                 percent: _builtins.int):
        """
        :param _builtins.int percent: The average target CPU utilization for the component.
        """
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.int:
        """
        The average target CPU utilization for the component.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class AppSpecServiceBitbucket(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceBitbucket. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceBitbucket.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceBitbucket.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecServiceCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional['outputs.AppSpecServiceCorsAllowOrigins'] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param 'AppSpecServiceCorsAllowOriginsArgs' allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional['outputs.AppSpecServiceCorsAllowOrigins']:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class AppSpecServiceCorsAllowOrigins(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Exact string match.
        :param _builtins.str prefix: Prefix-based match.
        :param _builtins.str regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AppSpecServiceEnv(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppSpecServiceGit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoCloneUrl":
            suggest = "repo_clone_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceGit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceGit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceGit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class AppSpecServiceGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecServiceGitlab(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceGitlab. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceGitlab.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceGitlab.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecServiceHealthCheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failureThreshold":
            suggest = "failure_threshold"
        elif key == "httpPath":
            suggest = "http_path"
        elif key == "initialDelaySeconds":
            suggest = "initial_delay_seconds"
        elif key == "periodSeconds":
            suggest = "period_seconds"
        elif key == "successThreshold":
            suggest = "success_threshold"
        elif key == "timeoutSeconds":
            suggest = "timeout_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceHealthCheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceHealthCheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceHealthCheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 failure_threshold: Optional[_builtins.int] = None,
                 http_path: Optional[_builtins.str] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 success_threshold: Optional[_builtins.int] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int failure_threshold: The number of failed health checks before considered unhealthy.
        :param _builtins.str http_path: The route path used for the HTTP health check ping.
        :param _builtins.int initial_delay_seconds: The number of seconds to wait before beginning health checks.
        :param _builtins.int period_seconds: The number of seconds to wait between health checks.
        :param _builtins.int port: The health check will be performed on this port instead of component's HTTP port.
        :param _builtins.int success_threshold: The number of successful health checks before considered healthy.
        :param _builtins.int timeout_seconds: The number of seconds after which the check times out.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[_builtins.int]:
        """
        The number of failed health checks before considered unhealthy.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[_builtins.str]:
        """
        The route path used for the HTTP health check ping.
        """
        return pulumi.get(self, "http_path")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait before beginning health checks.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between health checks.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The health check will be performed on this port instead of component's HTTP port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[_builtins.int]:
        """
        The number of successful health checks before considered healthy.
        """
        return pulumi.get(self, "success_threshold")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds after which the check times out.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class AppSpecServiceImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryType":
            suggest = "registry_type"
        elif key == "deployOnPushes":
            suggest = "deploy_on_pushes"
        elif key == "registryCredentials":
            suggest = "registry_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_type: _builtins.str,
                 repository: _builtins.str,
                 deploy_on_pushes: Optional[Sequence['outputs.AppSpecServiceImageDeployOnPush']] = None,
                 digest: Optional[_builtins.str] = None,
                 registry: Optional[_builtins.str] = None,
                 registry_credentials: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param _builtins.str repository: The repository name.
        :param Sequence['AppSpecServiceImageDeployOnPushArgs'] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param _builtins.str digest: The image digest. Cannot be specified if `tag` is provided.
        :param _builtins.str registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param _builtins.str registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param _builtins.str tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> _builtins.str:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> _builtins.str:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[Sequence['outputs.AppSpecServiceImageDeployOnPush']]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[_builtins.str]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[_builtins.str]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[_builtins.str]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class AppSpecServiceImageDeployOnPush(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AppSpecServiceLogDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openSearch":
            suggest = "open_search"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceLogDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceLogDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceLogDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.AppSpecServiceLogDestinationDatadog'] = None,
                 logtail: Optional['outputs.AppSpecServiceLogDestinationLogtail'] = None,
                 open_search: Optional['outputs.AppSpecServiceLogDestinationOpenSearch'] = None,
                 papertrail: Optional['outputs.AppSpecServiceLogDestinationPapertrail'] = None):
        """
        :param _builtins.str name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param 'AppSpecServiceLogDestinationDatadogArgs' datadog: Datadog configuration.
        :param 'AppSpecServiceLogDestinationLogtailArgs' logtail: Logtail configuration.
        :param 'AppSpecServiceLogDestinationOpenSearchArgs' open_search: OpenSearch configuration.
        :param 'AppSpecServiceLogDestinationPapertrailArgs' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.AppSpecServiceLogDestinationDatadog']:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.AppSpecServiceLogDestinationLogtail']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.AppSpecServiceLogDestinationOpenSearch']:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.AppSpecServiceLogDestinationPapertrail']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class AppSpecServiceLogDestinationDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceLogDestinationDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceLogDestinationDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceLogDestinationDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppSpecServiceLogDestinationLogtail(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class AppSpecServiceLogDestinationOpenSearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "indexName":
            suggest = "index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceLogDestinationOpenSearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceLogDestinationOpenSearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceLogDestinationOpenSearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth: 'outputs.AppSpecServiceLogDestinationOpenSearchBasicAuth',
                 cluster_name: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 index_name: Optional[_builtins.str] = None):
        """
        :param 'AppSpecServiceLogDestinationOpenSearchBasicAuthArgs' basic_auth: Basic authentication details.
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str endpoint: OpenSearch endpoint.
        :param _builtins.str index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.AppSpecServiceLogDestinationOpenSearchBasicAuth':
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")


@pulumi.output_type
class AppSpecServiceLogDestinationOpenSearchBasicAuth(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for basic authentication.
        :param _builtins.str user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class AppSpecServiceLogDestinationPapertrail(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        :param _builtins.str endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppSpecServiceRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preservePathPrefix":
            suggest = "preserve_path_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 preserve_path_prefix: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: Paths must start with `/` and must be unique within the app.
        :param _builtins.bool preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.bool]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")


@pulumi.output_type
class AppSpecServiceTermination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "drainSeconds":
            suggest = "drain_seconds"
        elif key == "gracePeriodSeconds":
            suggest = "grace_period_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecServiceTermination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecServiceTermination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecServiceTermination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drain_seconds: Optional[_builtins.int] = None,
                 grace_period_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int drain_seconds: The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110.
               
               A `static_site` can contain:
        :param _builtins.int grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
               
               A `function` component can contain:
        """
        if drain_seconds is not None:
            pulumi.set(__self__, "drain_seconds", drain_seconds)
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="drainSeconds")
    def drain_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110.

        A `static_site` can contain:
        """
        return pulumi.get(self, "drain_seconds")

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
        return pulumi.get(self, "grace_period_seconds")


@pulumi.output_type
class AppSpecStaticSite(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "catchallDocument":
            suggest = "catchall_document"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "environmentSlug":
            suggest = "environment_slug"
        elif key == "errorDocument":
            suggest = "error_document"
        elif key == "indexDocument":
            suggest = "index_document"
        elif key == "outputDir":
            suggest = "output_dir"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecStaticSite. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecStaticSite.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecStaticSite.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 bitbucket: Optional['outputs.AppSpecStaticSiteBitbucket'] = None,
                 build_command: Optional[_builtins.str] = None,
                 catchall_document: Optional[_builtins.str] = None,
                 cors: Optional['outputs.AppSpecStaticSiteCors'] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.AppSpecStaticSiteEnv']] = None,
                 error_document: Optional[_builtins.str] = None,
                 git: Optional['outputs.AppSpecStaticSiteGit'] = None,
                 github: Optional['outputs.AppSpecStaticSiteGithub'] = None,
                 gitlab: Optional['outputs.AppSpecStaticSiteGitlab'] = None,
                 index_document: Optional[_builtins.str] = None,
                 output_dir: Optional[_builtins.str] = None,
                 routes: Optional[Sequence['outputs.AppSpecStaticSiteRoute']] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the component.
        :param 'AppSpecStaticSiteBitbucketArgs' bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str catchall_document: The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        :param 'AppSpecStaticSiteCorsArgs' cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param _builtins.str dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app.
        :param Sequence['AppSpecStaticSiteEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param _builtins.str error_document: The name of the error document to use when serving this static site.
        :param 'AppSpecStaticSiteGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param 'AppSpecStaticSiteGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param 'AppSpecStaticSiteGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param _builtins.str index_document: The name of the index document to use when serving this static site.
        :param _builtins.str output_dir: An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        :param Sequence['AppSpecStaticSiteRouteArgs'] routes: An HTTP paths that should be routed to this component.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if catchall_document is not None:
            pulumi.set(__self__, "catchall_document", catchall_document)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if output_dir is not None:
            pulumi.set(__self__, "output_dir", output_dir)
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.AppSpecStaticSiteBitbucket']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="catchallDocument")
    def catchall_document(self) -> Optional[_builtins.str]:
        """
        The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        """
        return pulumi.get(self, "catchall_document")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional['outputs.AppSpecStaticSiteCors']:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppSpecStaticSiteEnv']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[_builtins.str]:
        """
        The name of the error document to use when serving this static site.
        """
        return pulumi.get(self, "error_document")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppSpecStaticSiteGit']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppSpecStaticSiteGithub']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppSpecStaticSiteGitlab']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[_builtins.str]:
        """
        The name of the index document to use when serving this static site.
        """
        return pulumi.get(self, "index_document")

    @_builtins.property
    @pulumi.getter(name="outputDir")
    def output_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        """
        return pulumi.get(self, "output_dir")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[Sequence['outputs.AppSpecStaticSiteRoute']]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class AppSpecStaticSiteBitbucket(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecStaticSiteBitbucket. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecStaticSiteBitbucket.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecStaticSiteBitbucket.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecStaticSiteCors(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowCredentials":
            suggest = "allow_credentials"
        elif key == "allowHeaders":
            suggest = "allow_headers"
        elif key == "allowMethods":
            suggest = "allow_methods"
        elif key == "allowOrigins":
            suggest = "allow_origins"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAge":
            suggest = "max_age"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecStaticSiteCors. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecStaticSiteCors.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecStaticSiteCors.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional['outputs.AppSpecStaticSiteCorsAllowOrigins'] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param 'AppSpecStaticSiteCorsAllowOriginsArgs' allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional['outputs.AppSpecStaticSiteCorsAllowOrigins']:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class AppSpecStaticSiteCorsAllowOrigins(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: Exact string match.
        :param _builtins.str prefix: Prefix-based match.
        :param _builtins.str regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class AppSpecStaticSiteEnv(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppSpecStaticSiteGit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoCloneUrl":
            suggest = "repo_clone_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecStaticSiteGit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecStaticSiteGit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecStaticSiteGit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class AppSpecStaticSiteGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecStaticSiteGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecStaticSiteGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecStaticSiteGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecStaticSiteGitlab(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecStaticSiteGitlab. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecStaticSiteGitlab.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecStaticSiteGitlab.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecStaticSiteRoute(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preservePathPrefix":
            suggest = "preserve_path_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecStaticSiteRoute. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecStaticSiteRoute.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecStaticSiteRoute.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 preserve_path_prefix: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: Paths must start with `/` and must be unique within the app.
        :param _builtins.bool preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.bool]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")


@pulumi.output_type
class AppSpecVpc(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the VPC.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class AppSpecWorker(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buildCommand":
            suggest = "build_command"
        elif key == "dockerfilePath":
            suggest = "dockerfile_path"
        elif key == "environmentSlug":
            suggest = "environment_slug"
        elif key == "instanceCount":
            suggest = "instance_count"
        elif key == "instanceSizeSlug":
            suggest = "instance_size_slug"
        elif key == "logDestinations":
            suggest = "log_destinations"
        elif key == "runCommand":
            suggest = "run_command"
        elif key == "sourceDir":
            suggest = "source_dir"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorker. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorker.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorker.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.AppSpecWorkerAlert']] = None,
                 autoscaling: Optional['outputs.AppSpecWorkerAutoscaling'] = None,
                 bitbucket: Optional['outputs.AppSpecWorkerBitbucket'] = None,
                 build_command: Optional[_builtins.str] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.AppSpecWorkerEnv']] = None,
                 git: Optional['outputs.AppSpecWorkerGit'] = None,
                 github: Optional['outputs.AppSpecWorkerGithub'] = None,
                 gitlab: Optional['outputs.AppSpecWorkerGitlab'] = None,
                 image: Optional['outputs.AppSpecWorkerImage'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional[_builtins.str] = None,
                 log_destinations: Optional[Sequence['outputs.AppSpecWorkerLogDestination']] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None,
                 termination: Optional['outputs.AppSpecWorkerTermination'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param Sequence['AppSpecWorkerAlertArgs'] alerts: Describes an alert policy for the component.
        :param 'AppSpecWorkerAutoscalingArgs' autoscaling: Configuration for automatically scaling this component based on metrics.
        :param 'AppSpecWorkerBitbucketArgs' bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app.
        :param Sequence['AppSpecWorkerEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'AppSpecWorkerGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param 'AppSpecWorkerGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param 'AppSpecWorkerGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param 'AppSpecWorkerImageArgs' image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to.
        :param _builtins.str instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param Sequence['AppSpecWorkerLogDestinationArgs'] log_destinations: Describes a log forwarding destination.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        :param 'AppSpecWorkerTerminationArgs' termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.AppSpecWorkerAlert']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.AppSpecWorkerAutoscaling']:
        """
        Configuration for automatically scaling this component based on metrics.
        """
        return pulumi.get(self, "autoscaling")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.AppSpecWorkerBitbucket']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.AppSpecWorkerEnv']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.AppSpecWorkerGit']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.AppSpecWorkerGithub']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.AppSpecWorkerGitlab']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.AppSpecWorkerImage']:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[_builtins.str]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[Sequence['outputs.AppSpecWorkerLogDestination']]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional['outputs.AppSpecWorkerTermination']:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")


@pulumi.output_type
class AppSpecWorkerAlert(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 rule: _builtins.str,
                 value: _builtins.float,
                 window: _builtins.str,
                 destinations: Optional['outputs.AppSpecWorkerAlertDestinations'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.float value: The threshold for the type of the warning.
        :param _builtins.str window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param 'AppSpecWorkerAlertDestinationsArgs' destinations: Specification for alert destination.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> _builtins.str:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.AppSpecWorkerAlertDestinations']:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AppSpecWorkerAlertDestinations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "slackWebhooks":
            suggest = "slack_webhooks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerAlertDestinations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerAlertDestinations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerAlertDestinations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.AppSpecWorkerAlertDestinationsSlackWebhook']] = None):
        """
        :param Sequence[_builtins.str] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param Sequence['AppSpecWorkerAlertDestinationsSlackWebhookArgs'] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.AppSpecWorkerAlertDestinationsSlackWebhook']]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class AppSpecWorkerAlertDestinationsSlackWebhook(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AppSpecWorkerAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxInstanceCount":
            suggest = "max_instance_count"
        elif key == "minInstanceCount":
            suggest = "min_instance_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_instance_count: _builtins.int,
                 metrics: 'outputs.AppSpecWorkerAutoscalingMetrics',
                 min_instance_count: _builtins.int):
        """
        :param _builtins.int max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count.
        :param 'AppSpecWorkerAutoscalingMetricsArgs' metrics: The metrics that the component is scaled on.
        :param _builtins.int min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_instance_count", min_instance_count)

    @_builtins.property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> _builtins.int:
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        return pulumi.get(self, "max_instance_count")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> 'outputs.AppSpecWorkerAutoscalingMetrics':
        """
        The metrics that the component is scaled on.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> _builtins.int:
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class AppSpecWorkerAutoscalingMetrics(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.AppSpecWorkerAutoscalingMetricsCpu'] = None):
        """
        :param 'AppSpecWorkerAutoscalingMetricsCpuArgs' cpu: Settings for scaling the component based on CPU utilization.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.AppSpecWorkerAutoscalingMetricsCpu']:
        """
        Settings for scaling the component based on CPU utilization.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class AppSpecWorkerAutoscalingMetricsCpu(dict):
    def __init__(__self__, *,
                 percent: _builtins.int):
        """
        :param _builtins.int percent: The average target CPU utilization for the component.
        """
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.int:
        """
        The average target CPU utilization for the component.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class AppSpecWorkerBitbucket(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerBitbucket. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerBitbucket.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerBitbucket.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecWorkerEnv(dict):
    def __init__(__self__, *,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class AppSpecWorkerGit(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "repoCloneUrl":
            suggest = "repo_clone_url"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerGit. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerGit.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerGit.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class AppSpecWorkerGithub(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerGithub. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerGithub.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerGithub.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecWorkerGitlab(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deployOnPush":
            suggest = "deploy_on_push"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerGitlab. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerGitlab.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerGitlab.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class AppSpecWorkerImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryType":
            suggest = "registry_type"
        elif key == "deployOnPushes":
            suggest = "deploy_on_pushes"
        elif key == "registryCredentials":
            suggest = "registry_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_type: _builtins.str,
                 repository: _builtins.str,
                 deploy_on_pushes: Optional[Sequence['outputs.AppSpecWorkerImageDeployOnPush']] = None,
                 digest: Optional[_builtins.str] = None,
                 registry: Optional[_builtins.str] = None,
                 registry_credentials: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param _builtins.str registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param _builtins.str repository: The repository name.
        :param Sequence['AppSpecWorkerImageDeployOnPushArgs'] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param _builtins.str digest: The image digest. Cannot be specified if `tag` is provided.
        :param _builtins.str registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param _builtins.str registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param _builtins.str tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> _builtins.str:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> _builtins.str:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[Sequence['outputs.AppSpecWorkerImageDeployOnPush']]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[_builtins.str]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[_builtins.str]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[_builtins.str]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class AppSpecWorkerImageDeployOnPush(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class AppSpecWorkerLogDestination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openSearch":
            suggest = "open_search"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerLogDestination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerLogDestination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerLogDestination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.AppSpecWorkerLogDestinationDatadog'] = None,
                 logtail: Optional['outputs.AppSpecWorkerLogDestinationLogtail'] = None,
                 open_search: Optional['outputs.AppSpecWorkerLogDestinationOpenSearch'] = None,
                 papertrail: Optional['outputs.AppSpecWorkerLogDestinationPapertrail'] = None):
        """
        :param _builtins.str name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param 'AppSpecWorkerLogDestinationDatadogArgs' datadog: Datadog configuration.
        :param 'AppSpecWorkerLogDestinationLogtailArgs' logtail: Logtail configuration.
        :param 'AppSpecWorkerLogDestinationOpenSearchArgs' open_search: OpenSearch configuration.
        :param 'AppSpecWorkerLogDestinationPapertrailArgs' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.AppSpecWorkerLogDestinationDatadog']:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.AppSpecWorkerLogDestinationLogtail']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.AppSpecWorkerLogDestinationOpenSearch']:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.AppSpecWorkerLogDestinationPapertrail']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class AppSpecWorkerLogDestinationDatadog(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerLogDestinationDatadog. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerLogDestinationDatadog.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerLogDestinationDatadog.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppSpecWorkerLogDestinationLogtail(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class AppSpecWorkerLogDestinationOpenSearch(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "basicAuth":
            suggest = "basic_auth"
        elif key == "clusterName":
            suggest = "cluster_name"
        elif key == "indexName":
            suggest = "index_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerLogDestinationOpenSearch. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerLogDestinationOpenSearch.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerLogDestinationOpenSearch.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 basic_auth: 'outputs.AppSpecWorkerLogDestinationOpenSearchBasicAuth',
                 cluster_name: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 index_name: Optional[_builtins.str] = None):
        """
        :param 'AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs' basic_auth: Basic authentication details.
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str endpoint: OpenSearch endpoint.
        :param _builtins.str index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.AppSpecWorkerLogDestinationOpenSearchBasicAuth':
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")


@pulumi.output_type
class AppSpecWorkerLogDestinationOpenSearchBasicAuth(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for basic authentication.
        :param _builtins.str user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class AppSpecWorkerLogDestinationPapertrail(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        :param _builtins.str endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class AppSpecWorkerTermination(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gracePeriodSeconds":
            suggest = "grace_period_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppSpecWorkerTermination. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppSpecWorkerTermination.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppSpecWorkerTermination.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grace_period_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
               
               A `function` component can contain:
        """
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
        return pulumi.get(self, "grace_period_seconds")


@pulumi.output_type
class DatabaseClusterBackupRestore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseName":
            suggest = "database_name"
        elif key == "backupCreatedAt":
            suggest = "backup_created_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseClusterBackupRestore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseClusterBackupRestore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseClusterBackupRestore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_name: _builtins.str,
                 backup_created_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_name: The name of an existing database cluster from which the backup will be restored.
        :param _builtins.str backup_created_at: The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.
               
               This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        pulumi.set(__self__, "database_name", database_name)
        if backup_created_at is not None:
            pulumi.set(__self__, "backup_created_at", backup_created_at)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> _builtins.str:
        """
        The name of an existing database cluster from which the backup will be restored.
        """
        return pulumi.get(self, "database_name")

    @_builtins.property
    @pulumi.getter(name="backupCreatedAt")
    def backup_created_at(self) -> Optional[_builtins.str]:
        """
        The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        return pulumi.get(self, "backup_created_at")


@pulumi.output_type
class DatabaseClusterMaintenanceWindow(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hour: _builtins.str):
        """
        :param _builtins.str day: The day of the week on which to apply maintenance updates. May be one of `monday` through `sunday`.
        :param _builtins.str hour: The hour in UTC at which maintenance updates will be applied as a string in 24 hour format, e.g. `13:00`.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        The day of the week on which to apply maintenance updates. May be one of `monday` through `sunday`.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> _builtins.str:
        """
        The hour in UTC at which maintenance updates will be applied as a string in 24 hour format, e.g. `13:00`.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class DatabaseFirewallRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseFirewallRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseFirewallRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseFirewallRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 value: _builtins.str,
                 created_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, `tag`, or `app`.
        :param _builtins.str value: The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        :param _builtins.str created_at: The date and time when the firewall rule was created.
        :param _builtins.str uuid: A unique identifier for the firewall rule.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, `tag`, or `app`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The date and time when the firewall rule was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        A unique identifier for the firewall rule.
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class DatabaseKafkaTopicConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cleanupPolicy":
            suggest = "cleanup_policy"
        elif key == "compressionType":
            suggest = "compression_type"
        elif key == "deleteRetentionMs":
            suggest = "delete_retention_ms"
        elif key == "fileDeleteDelayMs":
            suggest = "file_delete_delay_ms"
        elif key == "flushMessages":
            suggest = "flush_messages"
        elif key == "flushMs":
            suggest = "flush_ms"
        elif key == "indexIntervalBytes":
            suggest = "index_interval_bytes"
        elif key == "maxCompactionLagMs":
            suggest = "max_compaction_lag_ms"
        elif key == "maxMessageBytes":
            suggest = "max_message_bytes"
        elif key == "messageDownConversionEnable":
            suggest = "message_down_conversion_enable"
        elif key == "messageFormatVersion":
            suggest = "message_format_version"
        elif key == "messageTimestampDifferenceMaxMs":
            suggest = "message_timestamp_difference_max_ms"
        elif key == "messageTimestampType":
            suggest = "message_timestamp_type"
        elif key == "minCleanableDirtyRatio":
            suggest = "min_cleanable_dirty_ratio"
        elif key == "minCompactionLagMs":
            suggest = "min_compaction_lag_ms"
        elif key == "minInsyncReplicas":
            suggest = "min_insync_replicas"
        elif key == "retentionBytes":
            suggest = "retention_bytes"
        elif key == "retentionMs":
            suggest = "retention_ms"
        elif key == "segmentBytes":
            suggest = "segment_bytes"
        elif key == "segmentIndexBytes":
            suggest = "segment_index_bytes"
        elif key == "segmentJitterMs":
            suggest = "segment_jitter_ms"
        elif key == "segmentMs":
            suggest = "segment_ms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseKafkaTopicConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseKafkaTopicConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseKafkaTopicConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cleanup_policy: Optional[_builtins.str] = None,
                 compression_type: Optional[_builtins.str] = None,
                 delete_retention_ms: Optional[_builtins.str] = None,
                 file_delete_delay_ms: Optional[_builtins.str] = None,
                 flush_messages: Optional[_builtins.str] = None,
                 flush_ms: Optional[_builtins.str] = None,
                 index_interval_bytes: Optional[_builtins.str] = None,
                 max_compaction_lag_ms: Optional[_builtins.str] = None,
                 max_message_bytes: Optional[_builtins.str] = None,
                 message_down_conversion_enable: Optional[_builtins.bool] = None,
                 message_format_version: Optional[_builtins.str] = None,
                 message_timestamp_difference_max_ms: Optional[_builtins.str] = None,
                 message_timestamp_type: Optional[_builtins.str] = None,
                 min_cleanable_dirty_ratio: Optional[_builtins.float] = None,
                 min_compaction_lag_ms: Optional[_builtins.str] = None,
                 min_insync_replicas: Optional[_builtins.int] = None,
                 preallocate: Optional[_builtins.bool] = None,
                 retention_bytes: Optional[_builtins.str] = None,
                 retention_ms: Optional[_builtins.str] = None,
                 segment_bytes: Optional[_builtins.str] = None,
                 segment_index_bytes: Optional[_builtins.str] = None,
                 segment_jitter_ms: Optional[_builtins.str] = None,
                 segment_ms: Optional[_builtins.str] = None):
        """
        :param _builtins.str cleanup_policy: The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
               This may be one of "delete", "compact", or "compact_delete".
        :param _builtins.str compression_type: The topic compression codecs used for a given topic.
               This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        :param _builtins.str delete_retention_ms: The amount of time, in ms, that deleted records are retained.
        :param _builtins.str file_delete_delay_ms: The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        :param _builtins.str flush_messages: The number of messages accumulated on a topic partition before they are flushed to disk.
        :param _builtins.str flush_ms: The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        :param _builtins.str index_interval_bytes: The interval, in bytes, in which entries are added to the offset index.
        :param _builtins.str max_compaction_lag_ms: The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        :param _builtins.str max_message_bytes: The maximum size, in bytes, of a message.
        :param _builtins.bool message_down_conversion_enable: Determines whether down-conversion of message formats for consumers is enabled.
        :param _builtins.str message_format_version: The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        :param _builtins.str message_timestamp_difference_max_ms: The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        :param _builtins.str message_timestamp_type: Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        :param _builtins.float min_cleanable_dirty_ratio: A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        :param _builtins.int min_insync_replicas: The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
        :param _builtins.bool preallocate: Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        :param _builtins.str retention_bytes: The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        :param _builtins.str retention_ms: The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        :param _builtins.str segment_bytes: The maximum size, in bytes, of a single topic log file.
        :param _builtins.str segment_index_bytes: The maximum size, in bytes, of the offset index.
        :param _builtins.str segment_jitter_ms: The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        :param _builtins.str segment_ms: The maximum time, in ms, before the topic log will flush to disk.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if index_interval_bytes is not None:
            pulumi.set(__self__, "index_interval_bytes", index_interval_bytes)
        if max_compaction_lag_ms is not None:
            pulumi.set(__self__, "max_compaction_lag_ms", max_compaction_lag_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if message_down_conversion_enable is not None:
            pulumi.set(__self__, "message_down_conversion_enable", message_down_conversion_enable)
        if message_format_version is not None:
            pulumi.set(__self__, "message_format_version", message_format_version)
        if message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "message_timestamp_difference_max_ms", message_timestamp_difference_max_ms)
        if message_timestamp_type is not None:
            pulumi.set(__self__, "message_timestamp_type", message_timestamp_type)
        if min_cleanable_dirty_ratio is not None:
            pulumi.set(__self__, "min_cleanable_dirty_ratio", min_cleanable_dirty_ratio)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)
        if segment_index_bytes is not None:
            pulumi.set(__self__, "segment_index_bytes", segment_index_bytes)
        if segment_jitter_ms is not None:
            pulumi.set(__self__, "segment_jitter_ms", segment_jitter_ms)
        if segment_ms is not None:
            pulumi.set(__self__, "segment_ms", segment_ms)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[_builtins.str]:
        """
        The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
        This may be one of "delete", "compact", or "compact_delete".
        """
        return pulumi.get(self, "cleanup_policy")

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[_builtins.str]:
        """
        The topic compression codecs used for a given topic.
        This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        """
        return pulumi.get(self, "compression_type")

    @_builtins.property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[_builtins.str]:
        """
        The amount of time, in ms, that deleted records are retained.
        """
        return pulumi.get(self, "delete_retention_ms")

    @_builtins.property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[_builtins.str]:
        """
        The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        """
        return pulumi.get(self, "file_delete_delay_ms")

    @_builtins.property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[_builtins.str]:
        """
        The number of messages accumulated on a topic partition before they are flushed to disk.
        """
        return pulumi.get(self, "flush_messages")

    @_builtins.property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[_builtins.str]:
        """
        The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        """
        return pulumi.get(self, "flush_ms")

    @_builtins.property
    @pulumi.getter(name="indexIntervalBytes")
    def index_interval_bytes(self) -> Optional[_builtins.str]:
        """
        The interval, in bytes, in which entries are added to the offset index.
        """
        return pulumi.get(self, "index_interval_bytes")

    @_builtins.property
    @pulumi.getter(name="maxCompactionLagMs")
    def max_compaction_lag_ms(self) -> Optional[_builtins.str]:
        """
        The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        """
        return pulumi.get(self, "max_compaction_lag_ms")

    @_builtins.property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[_builtins.str]:
        """
        The maximum size, in bytes, of a message.
        """
        return pulumi.get(self, "max_message_bytes")

    @_builtins.property
    @pulumi.getter(name="messageDownConversionEnable")
    def message_down_conversion_enable(self) -> Optional[_builtins.bool]:
        """
        Determines whether down-conversion of message formats for consumers is enabled.
        """
        return pulumi.get(self, "message_down_conversion_enable")

    @_builtins.property
    @pulumi.getter(name="messageFormatVersion")
    def message_format_version(self) -> Optional[_builtins.str]:
        """
        The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        """
        return pulumi.get(self, "message_format_version")

    @_builtins.property
    @pulumi.getter(name="messageTimestampDifferenceMaxMs")
    def message_timestamp_difference_max_ms(self) -> Optional[_builtins.str]:
        """
        The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        """
        return pulumi.get(self, "message_timestamp_difference_max_ms")

    @_builtins.property
    @pulumi.getter(name="messageTimestampType")
    def message_timestamp_type(self) -> Optional[_builtins.str]:
        """
        Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        """
        return pulumi.get(self, "message_timestamp_type")

    @_builtins.property
    @pulumi.getter(name="minCleanableDirtyRatio")
    def min_cleanable_dirty_ratio(self) -> Optional[_builtins.float]:
        """
        A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        """
        return pulumi.get(self, "min_cleanable_dirty_ratio")

    @_builtins.property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @_builtins.property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[_builtins.int]:
        """
        The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
        """
        return pulumi.get(self, "min_insync_replicas")

    @_builtins.property
    @pulumi.getter
    def preallocate(self) -> Optional[_builtins.bool]:
        """
        Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        """
        return pulumi.get(self, "preallocate")

    @_builtins.property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[_builtins.str]:
        """
        The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        """
        return pulumi.get(self, "retention_bytes")

    @_builtins.property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[_builtins.str]:
        """
        The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        """
        return pulumi.get(self, "retention_ms")

    @_builtins.property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[_builtins.str]:
        """
        The maximum size, in bytes, of a single topic log file.
        """
        return pulumi.get(self, "segment_bytes")

    @_builtins.property
    @pulumi.getter(name="segmentIndexBytes")
    def segment_index_bytes(self) -> Optional[_builtins.str]:
        """
        The maximum size, in bytes, of the offset index.
        """
        return pulumi.get(self, "segment_index_bytes")

    @_builtins.property
    @pulumi.getter(name="segmentJitterMs")
    def segment_jitter_ms(self) -> Optional[_builtins.str]:
        """
        The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        """
        return pulumi.get(self, "segment_jitter_ms")

    @_builtins.property
    @pulumi.getter(name="segmentMs")
    def segment_ms(self) -> Optional[_builtins.str]:
        """
        The maximum time, in ms, before the topic log will flush to disk.
        """
        return pulumi.get(self, "segment_ms")


@pulumi.output_type
class DatabaseOnlineMigrationSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dbName":
            suggest = "db_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseOnlineMigrationSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseOnlineMigrationSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseOnlineMigrationSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 db_name: _builtins.str,
                 host: _builtins.str,
                 password: _builtins.str,
                 port: _builtins.int,
                 username: _builtins.str):
        """
        :param _builtins.str db_name: The name of the default database
        :param _builtins.str host: The FQDN pointing to the database cluster's current primary node.
        :param _builtins.str password: A randomly generated password for the default user.
        :param _builtins.int port: The port on which the database cluster is listening.
        :param _builtins.str username: The default user for the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> _builtins.str:
        """
        The name of the default database
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter
    def password(self) -> _builtins.str:
        """
        A randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        The default user for the database.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class DatabasePostgresqlConfigPgbouncer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autodbIdleTimeout":
            suggest = "autodb_idle_timeout"
        elif key == "autodbMaxDbConnections":
            suggest = "autodb_max_db_connections"
        elif key == "autodbPoolMode":
            suggest = "autodb_pool_mode"
        elif key == "autodbPoolSize":
            suggest = "autodb_pool_size"
        elif key == "ignoreStartupParameters":
            suggest = "ignore_startup_parameters"
        elif key == "minPoolSize":
            suggest = "min_pool_size"
        elif key == "serverIdleTimeout":
            suggest = "server_idle_timeout"
        elif key == "serverLifetime":
            suggest = "server_lifetime"
        elif key == "serverResetQueryAlways":
            suggest = "server_reset_query_always"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabasePostgresqlConfigPgbouncer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabasePostgresqlConfigPgbouncer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabasePostgresqlConfigPgbouncer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[_builtins.int] = None,
                 autodb_max_db_connections: Optional[_builtins.int] = None,
                 autodb_pool_mode: Optional[_builtins.str] = None,
                 autodb_pool_size: Optional[_builtins.int] = None,
                 ignore_startup_parameters: Optional[Sequence[_builtins.str]] = None,
                 min_pool_size: Optional[_builtins.int] = None,
                 server_idle_timeout: Optional[_builtins.int] = None,
                 server_lifetime: Optional[_builtins.int] = None,
                 server_reset_query_always: Optional[_builtins.bool] = None):
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @_builtins.property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "autodb_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "autodb_max_db_connections")

    @_builtins.property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "autodb_pool_mode")

    @_builtins.property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "autodb_pool_size")

    @_builtins.property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "ignore_startup_parameters")

    @_builtins.property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "min_pool_size")

    @_builtins.property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "server_idle_timeout")

    @_builtins.property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "server_lifetime")

    @_builtins.property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "server_reset_query_always")


@pulumi.output_type
class DatabasePostgresqlConfigTimescaledb(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxBackgroundWorkers":
            suggest = "max_background_workers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabasePostgresqlConfigTimescaledb. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabasePostgresqlConfigTimescaledb.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabasePostgresqlConfigTimescaledb.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_background_workers: Optional[_builtins.int] = None):
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @_builtins.property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "max_background_workers")


@pulumi.output_type
class DatabaseUserSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "opensearchAcls":
            suggest = "opensearch_acls"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatabaseUserSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatabaseUserSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatabaseUserSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 acls: Optional[Sequence['outputs.DatabaseUserSettingAcl']] = None,
                 opensearch_acls: Optional[Sequence['outputs.DatabaseUserSettingOpensearchAcl']] = None):
        """
        :param Sequence['DatabaseUserSettingAclArgs'] acls: A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:
               
               An individual ACL includes the following:
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if opensearch_acls is not None:
            pulumi.set(__self__, "opensearch_acls", opensearch_acls)

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Optional[Sequence['outputs.DatabaseUserSettingAcl']]:
        """
        A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:

        An individual ACL includes the following:
        """
        return pulumi.get(self, "acls")

    @_builtins.property
    @pulumi.getter(name="opensearchAcls")
    def opensearch_acls(self) -> Optional[Sequence['outputs.DatabaseUserSettingOpensearchAcl']]:
        return pulumi.get(self, "opensearch_acls")


@pulumi.output_type
class DatabaseUserSettingAcl(dict):
    def __init__(__self__, *,
                 permission: _builtins.str,
                 topic: _builtins.str,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str permission: The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        :param _builtins.str topic: A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "*", "<prefix>*", or "<literal>". "*" is a special value indicating a wildcard that matches on all topics. "<prefix>*" defines a regex that matches all topics with the prefix. "<literal>" performs an exact match on a topic name and only applies to that topic.
        :param _builtins.str id: An identifier for the ACL, this will be automatically assigned when you create an ACL entry
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "topic", topic)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        """
        A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "*", "<prefix>*", or "<literal>". "*" is a special value indicating a wildcard that matches on all topics. "<prefix>*" defines a regex that matches all topics with the prefix. "<literal>" performs an exact match on a topic name and only applies to that topic.
        """
        return pulumi.get(self, "topic")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        An identifier for the ACL, this will be automatically assigned when you create an ACL entry
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class DatabaseUserSettingOpensearchAcl(dict):
    def __init__(__self__, *,
                 index: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str permission: The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.str:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class DropletAutoscaleConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cooldownMinutes":
            suggest = "cooldown_minutes"
        elif key == "maxInstances":
            suggest = "max_instances"
        elif key == "minInstances":
            suggest = "min_instances"
        elif key == "targetCpuUtilization":
            suggest = "target_cpu_utilization"
        elif key == "targetMemoryUtilization":
            suggest = "target_memory_utilization"
        elif key == "targetNumberInstances":
            suggest = "target_number_instances"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DropletAutoscaleConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DropletAutoscaleConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DropletAutoscaleConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cooldown_minutes: Optional[_builtins.int] = None,
                 max_instances: Optional[_builtins.int] = None,
                 min_instances: Optional[_builtins.int] = None,
                 target_cpu_utilization: Optional[_builtins.float] = None,
                 target_memory_utilization: Optional[_builtins.float] = None,
                 target_number_instances: Optional[_builtins.int] = None):
        """
        :param _builtins.int cooldown_minutes: The cooldown duration between scaling events for the Droplet Autoscale pool.
        :param _builtins.int max_instances: The maximum number of instances to maintain in the Droplet Autoscale pool.
        :param _builtins.int min_instances: The minimum number of instances to maintain in the Droplet Autoscale pool.
        :param _builtins.float target_cpu_utilization: The target average CPU load (in range `[0, 1]`) to maintain in the Droplet Autoscale pool.
        :param _builtins.float target_memory_utilization: The target average Memory load (in range `[0, 1]`) to maintain in the Droplet Autoscale 
               pool.
        :param _builtins.int target_number_instances: The static number of instances to maintain in the pool Droplet Autoscale pool. This
               argument cannot be used with any other config options.
        """
        if cooldown_minutes is not None:
            pulumi.set(__self__, "cooldown_minutes", cooldown_minutes)
        if max_instances is not None:
            pulumi.set(__self__, "max_instances", max_instances)
        if min_instances is not None:
            pulumi.set(__self__, "min_instances", min_instances)
        if target_cpu_utilization is not None:
            pulumi.set(__self__, "target_cpu_utilization", target_cpu_utilization)
        if target_memory_utilization is not None:
            pulumi.set(__self__, "target_memory_utilization", target_memory_utilization)
        if target_number_instances is not None:
            pulumi.set(__self__, "target_number_instances", target_number_instances)

    @_builtins.property
    @pulumi.getter(name="cooldownMinutes")
    def cooldown_minutes(self) -> Optional[_builtins.int]:
        """
        The cooldown duration between scaling events for the Droplet Autoscale pool.
        """
        return pulumi.get(self, "cooldown_minutes")

    @_builtins.property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> Optional[_builtins.int]:
        """
        The maximum number of instances to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "max_instances")

    @_builtins.property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> Optional[_builtins.int]:
        """
        The minimum number of instances to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "min_instances")

    @_builtins.property
    @pulumi.getter(name="targetCpuUtilization")
    def target_cpu_utilization(self) -> Optional[_builtins.float]:
        """
        The target average CPU load (in range `[0, 1]`) to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "target_cpu_utilization")

    @_builtins.property
    @pulumi.getter(name="targetMemoryUtilization")
    def target_memory_utilization(self) -> Optional[_builtins.float]:
        """
        The target average Memory load (in range `[0, 1]`) to maintain in the Droplet Autoscale 
        pool.
        """
        return pulumi.get(self, "target_memory_utilization")

    @_builtins.property
    @pulumi.getter(name="targetNumberInstances")
    def target_number_instances(self) -> Optional[_builtins.int]:
        """
        The static number of instances to maintain in the pool Droplet Autoscale pool. This
        argument cannot be used with any other config options.
        """
        return pulumi.get(self, "target_number_instances")


@pulumi.output_type
class DropletAutoscaleCurrentUtilization(dict):
    def __init__(__self__, *,
                 cpu: Optional[_builtins.float] = None,
                 memory: Optional[_builtins.float] = None):
        """
        :param _builtins.float cpu: Average CPU utilization
        :param _builtins.float memory: Average Memory utilization
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[_builtins.float]:
        """
        Average CPU utilization
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[_builtins.float]:
        """
        Average Memory utilization
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class DropletAutoscaleDropletTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sshKeys":
            suggest = "ssh_keys"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "userData":
            suggest = "user_data"
        elif key == "vpcUuid":
            suggest = "vpc_uuid"
        elif key == "withDropletAgent":
            suggest = "with_droplet_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DropletAutoscaleDropletTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DropletAutoscaleDropletTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DropletAutoscaleDropletTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image: _builtins.str,
                 region: _builtins.str,
                 size: _builtins.str,
                 ssh_keys: Sequence[_builtins.str],
                 ipv6: Optional[_builtins.bool] = None,
                 project_id: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_data: Optional[_builtins.str] = None,
                 vpc_uuid: Optional[_builtins.str] = None,
                 with_droplet_agent: Optional[_builtins.bool] = None):
        """
        :param _builtins.str image: Image slug of the Droplet Autoscale pool underlying resource(s).
        :param _builtins.str region: Region slug of the Droplet Autoscale pool underlying resource(s).
        :param _builtins.str size: Size slug of the Droplet Autoscale pool underlying resource(s).
        :param Sequence[_builtins.str] ssh_keys: SSH fingerprints to add to the Droplet Autoscale pool underlying resource(s).
        :param _builtins.bool ipv6: Boolean flag to enable IPv6 networking on the Droplet Autoscale pool underlying resource(s).
        :param _builtins.str project_id: Project UUID to create the Droplet Autoscale pool underlying resource(s).
        :param Sequence[_builtins.str] tags: List of tags to add to the Droplet Autoscale pool underlying resource(s).
        :param _builtins.str user_data: Custom user data that can be added to the Droplet Autoscale pool underlying resource(s). This can be a 
               cloud init script that user may configure to setup their application workload.
        :param _builtins.str vpc_uuid: VPC UUID to create the Droplet Autoscale pool underlying resource(s). If not provided, this is inferred
               from the specified `region` (default VPC).
        :param _builtins.bool with_droplet_agent: Boolean flag to enable metric agent on the Droplet Autoscale pool underlying resource(s). The
               metric agent enables collecting resource utilization metrics, which allows making resource based scaling decisions.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vpc_uuid is not None:
            pulumi.set(__self__, "vpc_uuid", vpc_uuid)
        if with_droplet_agent is not None:
            pulumi.set(__self__, "with_droplet_agent", with_droplet_agent)

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        Image slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Size slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[_builtins.str]:
        """
        SSH fingerprints to add to the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "ssh_keys")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[_builtins.bool]:
        """
        Boolean flag to enable IPv6 networking on the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project UUID to create the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags to add to the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[_builtins.str]:
        """
        Custom user data that can be added to the Droplet Autoscale pool underlying resource(s). This can be a 
        cloud init script that user may configure to setup their application workload.
        """
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> Optional[_builtins.str]:
        """
        VPC UUID to create the Droplet Autoscale pool underlying resource(s). If not provided, this is inferred
        from the specified `region` (default VPC).
        """
        return pulumi.get(self, "vpc_uuid")

    @_builtins.property
    @pulumi.getter(name="withDropletAgent")
    def with_droplet_agent(self) -> Optional[_builtins.bool]:
        """
        Boolean flag to enable metric agent on the Droplet Autoscale pool underlying resource(s). The
        metric agent enables collecting resource utilization metrics, which allows making resource based scaling decisions.
        """
        return pulumi.get(self, "with_droplet_agent")


@pulumi.output_type
class DropletBackupPolicy(dict):
    def __init__(__self__, *,
                 hour: Optional[_builtins.int] = None,
                 plan: Optional[_builtins.str] = None,
                 weekday: Optional[_builtins.str] = None):
        """
        :param _builtins.int hour: The hour of the day that the backup window will start (`0`, `4`, `8`, `12`, `16`, `20`).
        :param _builtins.str plan: The backup plan used for the Droplet. The plan can be either `daily` or `weekly`.
        :param _builtins.str weekday: The day of the week on which the backup will occur (`SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`).
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if weekday is not None:
            pulumi.set(__self__, "weekday", weekday)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[_builtins.int]:
        """
        The hour of the day that the backup window will start (`0`, `4`, `8`, `12`, `16`, `20`).
        """
        return pulumi.get(self, "hour")

    @_builtins.property
    @pulumi.getter
    def plan(self) -> Optional[_builtins.str]:
        """
        The backup plan used for the Droplet. The plan can be either `daily` or `weekly`.
        """
        return pulumi.get(self, "plan")

    @_builtins.property
    @pulumi.getter
    def weekday(self) -> Optional[_builtins.str]:
        """
        The day of the week on which the backup will occur (`SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`).
        """
        return pulumi.get(self, "weekday")


@pulumi.output_type
class FirewallInboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portRange":
            suggest = "port_range"
        elif key == "sourceAddresses":
            suggest = "source_addresses"
        elif key == "sourceDropletIds":
            suggest = "source_droplet_ids"
        elif key == "sourceKubernetesIds":
            suggest = "source_kubernetes_ids"
        elif key == "sourceLoadBalancerUids":
            suggest = "source_load_balancer_uids"
        elif key == "sourceTags":
            suggest = "source_tags"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallInboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallInboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallInboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: _builtins.str,
                 port_range: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_droplet_ids: Optional[Sequence[_builtins.int]] = None,
                 source_kubernetes_ids: Optional[Sequence[_builtins.str]] = None,
                 source_load_balancer_uids: Optional[Sequence[_builtins.str]] = None,
                 source_tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param _builtins.str port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        :param Sequence[_builtins.str] source_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
               inbound traffic will be accepted.
        :param Sequence[_builtins.int] source_droplet_ids: An array containing the IDs of
               the Droplets from which the inbound traffic will be accepted.
        :param Sequence[_builtins.str] source_kubernetes_ids: An array containing the IDs of
               the Kubernetes clusters from which the inbound traffic will be accepted.
        :param Sequence[_builtins.str] source_load_balancer_uids: An array containing the IDs
               of the Load Balancers from which the inbound traffic will be accepted.
        :param Sequence[_builtins.str] source_tags: An array containing the names of Tags
               corresponding to groups of Droplets from which the inbound traffic
               will be accepted.
        """
        pulumi.set(__self__, "protocol", protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_droplet_ids is not None:
            pulumi.set(__self__, "source_droplet_ids", source_droplet_ids)
        if source_kubernetes_ids is not None:
            pulumi.set(__self__, "source_kubernetes_ids", source_kubernetes_ids)
        if source_load_balancer_uids is not None:
            pulumi.set(__self__, "source_load_balancer_uids", source_load_balancer_uids)
        if source_tags is not None:
            pulumi.set(__self__, "source_tags", source_tags)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourceDropletIds")
    def source_droplet_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_droplet_ids")

    @_builtins.property
    @pulumi.getter(name="sourceKubernetesIds")
    def source_kubernetes_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the IDs of
        the Kubernetes clusters from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_kubernetes_ids")

    @_builtins.property
    @pulumi.getter(name="sourceLoadBalancerUids")
    def source_load_balancer_uids(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_load_balancer_uids")

    @_builtins.property
    @pulumi.getter(name="sourceTags")
    def source_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets from which the inbound traffic
        will be accepted.
        """
        return pulumi.get(self, "source_tags")


@pulumi.output_type
class FirewallOutboundRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationAddresses":
            suggest = "destination_addresses"
        elif key == "destinationDropletIds":
            suggest = "destination_droplet_ids"
        elif key == "destinationKubernetesIds":
            suggest = "destination_kubernetes_ids"
        elif key == "destinationLoadBalancerUids":
            suggest = "destination_load_balancer_uids"
        elif key == "destinationTags":
            suggest = "destination_tags"
        elif key == "portRange":
            suggest = "port_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallOutboundRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallOutboundRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallOutboundRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 protocol: _builtins.str,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_droplet_ids: Optional[Sequence[_builtins.int]] = None,
                 destination_kubernetes_ids: Optional[Sequence[_builtins.str]] = None,
                 destination_load_balancer_uids: Optional[Sequence[_builtins.str]] = None,
                 destination_tags: Optional[Sequence[_builtins.str]] = None,
                 port_range: Optional[_builtins.str] = None):
        """
        :param _builtins.str protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param Sequence[_builtins.str] destination_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
               outbound traffic will be allowed.
        :param Sequence[_builtins.int] destination_droplet_ids: An array containing the IDs of
               the Droplets to which the outbound traffic will be allowed.
        :param Sequence[_builtins.str] destination_kubernetes_ids: An array containing the IDs of
               the Kubernetes clusters to which the outbound traffic will be allowed.
        :param Sequence[_builtins.str] destination_load_balancer_uids: An array containing the IDs
               of the Load Balancers to which the outbound traffic will be allowed.
        :param Sequence[_builtins.str] destination_tags: An array containing the names of Tags
               corresponding to groups of Droplets to which the outbound traffic will
               be allowed.
        :param _builtins.str port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        """
        pulumi.set(__self__, "protocol", protocol)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_droplet_ids is not None:
            pulumi.set(__self__, "destination_droplet_ids", destination_droplet_ids)
        if destination_kubernetes_ids is not None:
            pulumi.set(__self__, "destination_kubernetes_ids", destination_kubernetes_ids)
        if destination_load_balancer_uids is not None:
            pulumi.set(__self__, "destination_load_balancer_uids", destination_load_balancer_uids)
        if destination_tags is not None:
            pulumi.set(__self__, "destination_tags", destination_tags)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationDropletIds")
    def destination_droplet_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_droplet_ids")

    @_builtins.property
    @pulumi.getter(name="destinationKubernetesIds")
    def destination_kubernetes_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the IDs of
        the Kubernetes clusters to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_kubernetes_ids")

    @_builtins.property
    @pulumi.getter(name="destinationLoadBalancerUids")
    def destination_load_balancer_uids(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_load_balancer_uids")

    @_builtins.property
    @pulumi.getter(name="destinationTags")
    def destination_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        """
        return pulumi.get(self, "destination_tags")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")


@pulumi.output_type
class FirewallPendingChange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dropletId":
            suggest = "droplet_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in FirewallPendingChange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        FirewallPendingChange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        FirewallPendingChange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 droplet_id: Optional[_builtins.int] = None,
                 removing: Optional[_builtins.bool] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str status: A status string indicating the current state of the Firewall.
               This can be "waiting", "succeeded", or "failed".
        """
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if removing is not None:
            pulumi.set(__self__, "removing", removing)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "droplet_id")

    @_builtins.property
    @pulumi.getter
    def removing(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "removing")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        A status string indicating the current state of the Firewall.
        This can be "waiting", "succeeded", or "failed".
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GenaiAgentAgentGuardrail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentUuid":
            suggest = "agent_uuid"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "defaultResponse":
            suggest = "default_response"
        elif key == "guardrailUuid":
            suggest = "guardrail_uuid"
        elif key == "isAttached":
            suggest = "is_attached"
        elif key == "isDefault":
            suggest = "is_default"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentAgentGuardrail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentAgentGuardrail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentAgentGuardrail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_uuid: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 default_response: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 is_attached: Optional[_builtins.bool] = None,
                 is_default: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_uuid: Agent UUID for the Guardrail
        :param _builtins.str created_at: Created At timestamp for the Guardrail
        :param _builtins.str default_response: Default response for the Guardrail
        :param _builtins.str description: Description of the Guardrail
        :param _builtins.str guardrail_uuid: Guardrail UUID
        :param _builtins.bool is_attached: Indicates if the Guardrail is attached
        :param _builtins.bool is_default: Indicates if the Guardrail is default
        :param _builtins.str name: Name of Guardrail
        :param _builtins.int priority: Priority of the Guardrail
        :param _builtins.str type: Type of the Guardrail
        :param _builtins.str updated_at: Updated At timestamp for the Guardrail
        :param _builtins.str uuid: Guardrail UUID
        """
        if agent_uuid is not None:
            pulumi.set(__self__, "agent_uuid", agent_uuid)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if default_response is not None:
            pulumi.set(__self__, "default_response", default_response)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if is_attached is not None:
            pulumi.set(__self__, "is_attached", is_attached)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="agentUuid")
    def agent_uuid(self) -> Optional[_builtins.str]:
        """
        Agent UUID for the Guardrail
        """
        return pulumi.get(self, "agent_uuid")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Guardrail
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="defaultResponse")
    def default_response(self) -> Optional[_builtins.str]:
        """
        Default response for the Guardrail
        """
        return pulumi.get(self, "default_response")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Guardrail
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "guardrail_uuid")

    @_builtins.property
    @pulumi.getter(name="isAttached")
    def is_attached(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Guardrail is attached
        """
        return pulumi.get(self, "is_attached")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Guardrail is default
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of Guardrail
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Priority of the Guardrail
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the Guardrail
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the Guardrail
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentAnthropicApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "deletedAt":
            suggest = "deleted_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentAnthropicApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentAnthropicApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentAnthropicApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GenaiAgentApiKeyInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "deletedAt":
            suggest = "deleted_at"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentApiKeyInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentApiKeyInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentApiKeyInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentChatbot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buttonBackgroundColor":
            suggest = "button_background_color"
        elif key == "primaryColor":
            suggest = "primary_color"
        elif key == "secondaryColor":
            suggest = "secondary_color"
        elif key == "startingMessage":
            suggest = "starting_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChatbot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChatbot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChatbot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GenaiAgentChatbotIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chatbotId":
            suggest = "chatbot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChatbotIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChatbotIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChatbotIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chatbot_id: Optional[_builtins.str] = None):
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GenaiAgentChildAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelUuid":
            suggest = "model_uuid"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "agentId":
            suggest = "agent_id"
        elif key == "anthropicApiKeys":
            suggest = "anthropic_api_keys"
        elif key == "apiKeyInfos":
            suggest = "api_key_infos"
        elif key == "apiKeys":
            suggest = "api_keys"
        elif key == "chatbotIdentifiers":
            suggest = "chatbot_identifiers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChildAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChildAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChildAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 agent_id: Optional[_builtins.str] = None,
                 anthropic_api_keys: Optional[Sequence['outputs.GenaiAgentChildAgentAnthropicApiKey']] = None,
                 api_key_infos: Optional[Sequence['outputs.GenaiAgentChildAgentApiKeyInfo']] = None,
                 api_keys: Optional[Sequence['outputs.GenaiAgentChildAgentApiKey']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GenaiAgentChildAgentChatbotIdentifier']] = None,
                 chatbots: Optional[Sequence['outputs.GenaiAgentChildAgentChatbot']] = None,
                 deployments: Optional[Sequence['outputs.GenaiAgentChildAgentDeployment']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param _builtins.str name: Name of the Agent
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param _builtins.str agent_id: ID of the child agent
        :param Sequence['GenaiAgentChildAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GenaiAgentChildAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GenaiAgentChildAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GenaiAgentChildAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GenaiAgentChildAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GenaiAgentChildAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        """
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[_builtins.str]:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GenaiAgentChildAgentAnthropicApiKey']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GenaiAgentChildAgentApiKeyInfo']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GenaiAgentChildAgentApiKey']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GenaiAgentChildAgentChatbotIdentifier']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GenaiAgentChildAgentChatbot']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GenaiAgentChildAgentDeployment']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GenaiAgentChildAgentAnthropicApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "deletedAt":
            suggest = "deleted_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChildAgentAnthropicApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChildAgentAnthropicApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChildAgentAnthropicApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentChildAgentApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChildAgentApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChildAgentApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChildAgentApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GenaiAgentChildAgentApiKeyInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "deletedAt":
            suggest = "deleted_at"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChildAgentApiKeyInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChildAgentApiKeyInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChildAgentApiKeyInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentChildAgentChatbot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buttonBackgroundColor":
            suggest = "button_background_color"
        elif key == "primaryColor":
            suggest = "primary_color"
        elif key == "secondaryColor":
            suggest = "secondary_color"
        elif key == "startingMessage":
            suggest = "starting_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChildAgentChatbot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChildAgentChatbot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChildAgentChatbot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GenaiAgentChildAgentChatbotIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chatbotId":
            suggest = "chatbot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChildAgentChatbotIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChildAgentChatbotIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChildAgentChatbotIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chatbot_id: Optional[_builtins.str] = None):
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GenaiAgentChildAgentDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentChildAgentDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentChildAgentDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentChildAgentDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GenaiAgentDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GenaiAgentFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "guardrailUuid":
            suggest = "guardrail_uuid"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 faasname: Optional[_builtins.str] = None,
                 faasnamespace: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        :param _builtins.str created_at: Created At timestamp for the Function
        :param _builtins.str description: Description of the Function
        :param _builtins.str faasname: Name of function
        :param _builtins.str faasnamespace: Namespace of function
        :param _builtins.str guardrail_uuid: Guardrail UUID for the Function
        :param _builtins.str name: Name of function
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if faasname is not None:
            pulumi.set(__self__, "faasname", faasname)
        if faasnamespace is not None:
            pulumi.set(__self__, "faasnamespace", faasnamespace)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Function
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Function
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def faasname(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "faasname")

    @_builtins.property
    @pulumi.getter
    def faasnamespace(self) -> Optional[_builtins.str]:
        """
        Namespace of function
        """
        return pulumi.get(self, "faasnamespace")

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID for the Function
        """
        return pulumi.get(self, "guardrail_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentKnowledgeBase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addedToAgentAt":
            suggest = "added_to_agent_at"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "databaseId":
            suggest = "database_id"
        elif key == "embeddingModelUuid":
            suggest = "embedding_model_uuid"
        elif key == "isPublic":
            suggest = "is_public"
        elif key == "lastIndexingJobs":
            suggest = "last_indexing_jobs"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentKnowledgeBase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentKnowledgeBase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentKnowledgeBase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 added_to_agent_at: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_jobs: Optional[Sequence['outputs.GenaiAgentKnowledgeBaseLastIndexingJob']] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 updated_at: Optional[_builtins.str] = None,
                 user_id: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GenaiAgentKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str user_id: User ID of the Knowledge Base
        :param _builtins.str uuid: UUID of the Knowledge Base
        """
        if added_to_agent_at is not None:
            pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['outputs.GenaiAgentKnowledgeBaseLastIndexingJob']]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentKnowledgeBaseLastIndexingJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedDatasources":
            suggest = "completed_datasources"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "dataSourceUuids":
            suggest = "data_source_uuids"
        elif key == "finishedAt":
            suggest = "finished_at"
        elif key == "knowledgeBaseUuid":
            suggest = "knowledge_base_uuid"
        elif key == "startedAt":
            suggest = "started_at"
        elif key == "totalDatasources":
            suggest = "total_datasources"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentKnowledgeBaseLastIndexingJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentKnowledgeBaseLastIndexingJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentKnowledgeBaseLastIndexingJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_datasources: Optional[_builtins.int] = None,
                 created_at: Optional[_builtins.str] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 finished_at: Optional[_builtins.str] = None,
                 knowledge_base_uuid: Optional[_builtins.str] = None,
                 phase: Optional[_builtins.str] = None,
                 started_at: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if knowledge_base_uuid is not None:
            pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "inferenceName":
            suggest = "inference_name"
        elif key == "inferenceVersion":
            suggest = "inference_version"
        elif key == "isFoundational":
            suggest = "is_foundational"
        elif key == "parentUuid":
            suggest = "parent_uuid"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "uploadComplete":
            suggest = "upload_complete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agreements: Optional[Sequence['outputs.GenaiAgentModelAgreement']] = None,
                 created_at: Optional[_builtins.str] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GenaiAgentModelVersion']] = None):
        """
        :param Sequence['GenaiAgentModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GenaiAgentModelVersionArgs'] versions: URL of the Model
        """
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GenaiAgentModelAgreement']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GenaiAgentModelVersion']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GenaiAgentModelAgreement(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentModelVersion(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GenaiAgentOpenAiApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "deletedAt":
            suggest = "deleted_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentOpenAiApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentOpenAiApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentOpenAiApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentParentAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelUuid":
            suggest = "model_uuid"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "agentId":
            suggest = "agent_id"
        elif key == "anthropicApiKeys":
            suggest = "anthropic_api_keys"
        elif key == "apiKeyInfos":
            suggest = "api_key_infos"
        elif key == "apiKeys":
            suggest = "api_keys"
        elif key == "chatbotIdentifiers":
            suggest = "chatbot_identifiers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentParentAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentParentAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentParentAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 agent_id: Optional[_builtins.str] = None,
                 anthropic_api_keys: Optional[Sequence['outputs.GenaiAgentParentAgentAnthropicApiKey']] = None,
                 api_key_infos: Optional[Sequence['outputs.GenaiAgentParentAgentApiKeyInfo']] = None,
                 api_keys: Optional[Sequence['outputs.GenaiAgentParentAgentApiKey']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GenaiAgentParentAgentChatbotIdentifier']] = None,
                 chatbots: Optional[Sequence['outputs.GenaiAgentParentAgentChatbot']] = None,
                 deployments: Optional[Sequence['outputs.GenaiAgentParentAgentDeployment']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param _builtins.str name: Name of the Agent
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param _builtins.str agent_id: ID of the child agent
        :param Sequence['GenaiAgentParentAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GenaiAgentParentAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GenaiAgentParentAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GenaiAgentParentAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GenaiAgentParentAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GenaiAgentParentAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        """
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[_builtins.str]:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GenaiAgentParentAgentAnthropicApiKey']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GenaiAgentParentAgentApiKeyInfo']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GenaiAgentParentAgentApiKey']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GenaiAgentParentAgentChatbotIdentifier']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GenaiAgentParentAgentChatbot']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GenaiAgentParentAgentDeployment']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GenaiAgentParentAgentAnthropicApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "deletedAt":
            suggest = "deleted_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentParentAgentAnthropicApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentParentAgentAnthropicApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentParentAgentAnthropicApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentParentAgentApiKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKey":
            suggest = "api_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentParentAgentApiKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentParentAgentApiKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentParentAgentApiKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GenaiAgentParentAgentApiKeyInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "createdBy":
            suggest = "created_by"
        elif key == "deletedAt":
            suggest = "deleted_at"
        elif key == "secretKey":
            suggest = "secret_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentParentAgentApiKeyInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentParentAgentApiKeyInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentParentAgentApiKeyInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 created_by: Optional[_builtins.str] = None,
                 deleted_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[_builtins.str]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentParentAgentChatbot(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "buttonBackgroundColor":
            suggest = "button_background_color"
        elif key == "primaryColor":
            suggest = "primary_color"
        elif key == "secondaryColor":
            suggest = "secondary_color"
        elif key == "startingMessage":
            suggest = "starting_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentParentAgentChatbot. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentParentAgentChatbot.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentParentAgentChatbot.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GenaiAgentParentAgentChatbotIdentifier(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chatbotId":
            suggest = "chatbot_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentParentAgentChatbotIdentifier. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentParentAgentChatbotIdentifier.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentParentAgentChatbotIdentifier.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chatbot_id: Optional[_builtins.str] = None):
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GenaiAgentParentAgentDeployment(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentParentAgentDeployment. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentParentAgentDeployment.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentParentAgentDeployment.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GenaiAgentTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "knowledgeBases":
            suggest = "knowledge_bases"
        elif key == "maxTokens":
            suggest = "max_tokens"
        elif key == "topP":
            suggest = "top_p"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 instruction: Optional[_builtins.str] = None,
                 k: Optional[_builtins.int] = None,
                 knowledge_bases: Optional[Sequence['outputs.GenaiAgentTemplateKnowledgeBase']] = None,
                 max_tokens: Optional[_builtins.int] = None,
                 models: Optional[Sequence['outputs.GenaiAgentTemplateModel']] = None,
                 name: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str description: Description of the Agent Template
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.int k: K value for the Agent Template
        :param Sequence['GenaiAgentTemplateKnowledgeBaseArgs'] knowledge_bases: List of Knowledge Bases
        :param _builtins.int max_tokens: Maximum tokens allowed
        :param Sequence['GenaiAgentTemplateModelArgs'] models: Model of the Agent Template
        :param _builtins.str name: Name of the Agent Template
        :param _builtins.float temperature: Agent temperature setting
        :param _builtins.float top_p: Top P sampling parameter
        :param _builtins.str updated_at: Updated At timestamp for the Agent Template
        :param _builtins.str uuid: uuid of the Agent Template
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)
        if k is not None:
            pulumi.set(__self__, "k", k)
        if knowledge_bases is not None:
            pulumi.set(__self__, "knowledge_bases", knowledge_bases)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Agent Template
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[_builtins.str]:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.int]:
        """
        K value for the Agent Template
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> Optional[Sequence['outputs.GenaiAgentTemplateKnowledgeBase']]:
        """
        List of Knowledge Bases
        """
        return pulumi.get(self, "knowledge_bases")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.int]:
        """
        Maximum tokens allowed
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[Sequence['outputs.GenaiAgentTemplateModel']]:
        """
        Model of the Agent Template
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Agent Template
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Agent temperature setting
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Top P sampling parameter
        """
        return pulumi.get(self, "top_p")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the Agent Template
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        uuid of the Agent Template
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentTemplateKnowledgeBase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addedToAgentAt":
            suggest = "added_to_agent_at"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "databaseId":
            suggest = "database_id"
        elif key == "embeddingModelUuid":
            suggest = "embedding_model_uuid"
        elif key == "isPublic":
            suggest = "is_public"
        elif key == "lastIndexingJobs":
            suggest = "last_indexing_jobs"
        elif key == "projectId":
            suggest = "project_id"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "userId":
            suggest = "user_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentTemplateKnowledgeBase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentTemplateKnowledgeBase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentTemplateKnowledgeBase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 added_to_agent_at: Optional[_builtins.str] = None,
                 created_at: Optional[_builtins.str] = None,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_jobs: Optional[Sequence['outputs.GenaiAgentTemplateKnowledgeBaseLastIndexingJob']] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 updated_at: Optional[_builtins.str] = None,
                 user_id: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str user_id: User ID of the Knowledge Base
        :param _builtins.str uuid: UUID of the Knowledge Base
        """
        if added_to_agent_at is not None:
            pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['outputs.GenaiAgentTemplateKnowledgeBaseLastIndexingJob']]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentTemplateKnowledgeBaseLastIndexingJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedDatasources":
            suggest = "completed_datasources"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "dataSourceUuids":
            suggest = "data_source_uuids"
        elif key == "finishedAt":
            suggest = "finished_at"
        elif key == "knowledgeBaseUuid":
            suggest = "knowledge_base_uuid"
        elif key == "startedAt":
            suggest = "started_at"
        elif key == "totalDatasources":
            suggest = "total_datasources"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentTemplateKnowledgeBaseLastIndexingJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentTemplateKnowledgeBaseLastIndexingJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentTemplateKnowledgeBaseLastIndexingJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_datasources: Optional[_builtins.int] = None,
                 created_at: Optional[_builtins.str] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 finished_at: Optional[_builtins.str] = None,
                 knowledge_base_uuid: Optional[_builtins.str] = None,
                 phase: Optional[_builtins.str] = None,
                 started_at: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if knowledge_base_uuid is not None:
            pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentTemplateModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "inferenceName":
            suggest = "inference_name"
        elif key == "inferenceVersion":
            suggest = "inference_version"
        elif key == "isFoundational":
            suggest = "is_foundational"
        elif key == "parentUuid":
            suggest = "parent_uuid"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "uploadComplete":
            suggest = "upload_complete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiAgentTemplateModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiAgentTemplateModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiAgentTemplateModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agreements: Optional[Sequence['outputs.GenaiAgentTemplateModelAgreement']] = None,
                 created_at: Optional[_builtins.str] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GenaiAgentTemplateModelVersion']] = None):
        """
        :param Sequence['GenaiAgentTemplateModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GenaiAgentTemplateModelVersionArgs'] versions: URL of the Model
        """
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GenaiAgentTemplateModelAgreement']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GenaiAgentTemplateModelVersion']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GenaiAgentTemplateModelAgreement(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiAgentTemplateModelVersion(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GenaiKnowledgeBaseDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "fileUploadDataSources":
            suggest = "file_upload_data_sources"
        elif key == "lastIndexingJobs":
            suggest = "last_indexing_jobs"
        elif key == "spacesDataSources":
            suggest = "spaces_data_sources"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "webCrawlerDataSources":
            suggest = "web_crawler_data_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiKnowledgeBaseDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiKnowledgeBaseDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiKnowledgeBaseDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 file_upload_data_sources: Optional[Sequence['outputs.GenaiKnowledgeBaseDataSourceFileUploadDataSource']] = None,
                 last_indexing_jobs: Optional[Sequence['outputs.GenaiKnowledgeBaseDataSourceLastIndexingJob']] = None,
                 spaces_data_sources: Optional[Sequence['outputs.GenaiKnowledgeBaseDataSourceSpacesDataSource']] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 web_crawler_data_sources: Optional[Sequence['outputs.GenaiKnowledgeBaseDataSourceWebCrawlerDataSource']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param Sequence['GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgs'] file_upload_data_sources: File upload data source configuration
        :param Sequence['GenaiKnowledgeBaseDataSourceLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the data source
        :param Sequence['GenaiKnowledgeBaseDataSourceSpacesDataSourceArgs'] spaces_data_sources: Spaces data source configuration
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param Sequence['GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgs'] web_crawler_data_sources: Web crawler data source configuration
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if file_upload_data_sources is not None:
            pulumi.set(__self__, "file_upload_data_sources", file_upload_data_sources)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if spaces_data_sources is not None:
            pulumi.set(__self__, "spaces_data_sources", spaces_data_sources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if web_crawler_data_sources is not None:
            pulumi.set(__self__, "web_crawler_data_sources", web_crawler_data_sources)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="fileUploadDataSources")
    def file_upload_data_sources(self) -> Optional[Sequence['outputs.GenaiKnowledgeBaseDataSourceFileUploadDataSource']]:
        """
        File upload data source configuration
        """
        return pulumi.get(self, "file_upload_data_sources")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['outputs.GenaiKnowledgeBaseDataSourceLastIndexingJob']]:
        """
        Last indexing job for the data source
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter(name="spacesDataSources")
    def spaces_data_sources(self) -> Optional[Sequence['outputs.GenaiKnowledgeBaseDataSourceSpacesDataSource']]:
        """
        Spaces data source configuration
        """
        return pulumi.get(self, "spaces_data_sources")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="webCrawlerDataSources")
    def web_crawler_data_sources(self) -> Optional[Sequence['outputs.GenaiKnowledgeBaseDataSourceWebCrawlerDataSource']]:
        """
        Web crawler data source configuration
        """
        return pulumi.get(self, "web_crawler_data_sources")


@pulumi.output_type
class GenaiKnowledgeBaseDataSourceFileUploadDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "originalFileName":
            suggest = "original_file_name"
        elif key == "sizeInBytes":
            suggest = "size_in_bytes"
        elif key == "storedObjectKey":
            suggest = "stored_object_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiKnowledgeBaseDataSourceFileUploadDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiKnowledgeBaseDataSourceFileUploadDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiKnowledgeBaseDataSourceFileUploadDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 original_file_name: Optional[_builtins.str] = None,
                 size_in_bytes: Optional[_builtins.str] = None,
                 stored_object_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str original_file_name: The original name of the uploaded file
        :param _builtins.str size_in_bytes: The size of the file in bytes
        :param _builtins.str stored_object_key: The stored object key for the file
        """
        if original_file_name is not None:
            pulumi.set(__self__, "original_file_name", original_file_name)
        if size_in_bytes is not None:
            pulumi.set(__self__, "size_in_bytes", size_in_bytes)
        if stored_object_key is not None:
            pulumi.set(__self__, "stored_object_key", stored_object_key)

    @_builtins.property
    @pulumi.getter(name="originalFileName")
    def original_file_name(self) -> Optional[_builtins.str]:
        """
        The original name of the uploaded file
        """
        return pulumi.get(self, "original_file_name")

    @_builtins.property
    @pulumi.getter(name="sizeInBytes")
    def size_in_bytes(self) -> Optional[_builtins.str]:
        """
        The size of the file in bytes
        """
        return pulumi.get(self, "size_in_bytes")

    @_builtins.property
    @pulumi.getter(name="storedObjectKey")
    def stored_object_key(self) -> Optional[_builtins.str]:
        """
        The stored object key for the file
        """
        return pulumi.get(self, "stored_object_key")


@pulumi.output_type
class GenaiKnowledgeBaseDataSourceLastIndexingJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedDatasources":
            suggest = "completed_datasources"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "dataSourceUuids":
            suggest = "data_source_uuids"
        elif key == "finishedAt":
            suggest = "finished_at"
        elif key == "knowledgeBaseUuid":
            suggest = "knowledge_base_uuid"
        elif key == "startedAt":
            suggest = "started_at"
        elif key == "totalDatasources":
            suggest = "total_datasources"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiKnowledgeBaseDataSourceLastIndexingJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiKnowledgeBaseDataSourceLastIndexingJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiKnowledgeBaseDataSourceLastIndexingJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_datasources: Optional[_builtins.int] = None,
                 created_at: Optional[_builtins.str] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 finished_at: Optional[_builtins.str] = None,
                 knowledge_base_uuid: Optional[_builtins.str] = None,
                 phase: Optional[_builtins.str] = None,
                 started_at: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if knowledge_base_uuid is not None:
            pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiKnowledgeBaseDataSourceSpacesDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bucketName":
            suggest = "bucket_name"
        elif key == "itemPath":
            suggest = "item_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiKnowledgeBaseDataSourceSpacesDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiKnowledgeBaseDataSourceSpacesDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiKnowledgeBaseDataSourceSpacesDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket_name: Optional[_builtins.str] = None,
                 item_path: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket_name: The name of the Spaces bucket
        :param _builtins.str item_path: The path to the item in the bucket
        :param _builtins.str region: The region of the Spaces bucket
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if item_path is not None:
            pulumi.set(__self__, "item_path", item_path)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        The name of the Spaces bucket
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="itemPath")
    def item_path(self) -> Optional[_builtins.str]:
        """
        The path to the item in the bucket
        """
        return pulumi.get(self, "item_path")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the Spaces bucket
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GenaiKnowledgeBaseDataSourceWebCrawlerDataSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "baseUrl":
            suggest = "base_url"
        elif key == "crawlingOption":
            suggest = "crawling_option"
        elif key == "embedMedia":
            suggest = "embed_media"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiKnowledgeBaseDataSourceWebCrawlerDataSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiKnowledgeBaseDataSourceWebCrawlerDataSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiKnowledgeBaseDataSourceWebCrawlerDataSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 base_url: Optional[_builtins.str] = None,
                 crawling_option: Optional[_builtins.str] = None,
                 embed_media: Optional[_builtins.bool] = None):
        """
        :param _builtins.str base_url: The base URL to crawl
        :param _builtins.str crawling_option: Options for specifying how URLs found on pages should be handled. 
               - UNKNOWN: Default unknown value
               - SCOPED: Only include the base URL.
               - PATH: Crawl the base URL and linked pages within the URL path.
               - DOMAIN: Crawl the base URL and linked pages within the same domain.
               - SUBDOMAINS: Crawl the base URL and linked pages for any subdomain.
        :param _builtins.bool embed_media: Whether to embed media content
        """
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if crawling_option is not None:
            pulumi.set(__self__, "crawling_option", crawling_option)
        if embed_media is not None:
            pulumi.set(__self__, "embed_media", embed_media)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[_builtins.str]:
        """
        The base URL to crawl
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="crawlingOption")
    def crawling_option(self) -> Optional[_builtins.str]:
        """
        Options for specifying how URLs found on pages should be handled. 
        - UNKNOWN: Default unknown value
        - SCOPED: Only include the base URL.
        - PATH: Crawl the base URL and linked pages within the URL path.
        - DOMAIN: Crawl the base URL and linked pages within the same domain.
        - SUBDOMAINS: Crawl the base URL and linked pages for any subdomain.
        """
        return pulumi.get(self, "crawling_option")

    @_builtins.property
    @pulumi.getter(name="embedMedia")
    def embed_media(self) -> Optional[_builtins.bool]:
        """
        Whether to embed media content
        """
        return pulumi.get(self, "embed_media")


@pulumi.output_type
class GenaiKnowledgeBaseLastIndexingJob(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "completedDatasources":
            suggest = "completed_datasources"
        elif key == "createdAt":
            suggest = "created_at"
        elif key == "dataSourceUuids":
            suggest = "data_source_uuids"
        elif key == "finishedAt":
            suggest = "finished_at"
        elif key == "knowledgeBaseUuid":
            suggest = "knowledge_base_uuid"
        elif key == "startedAt":
            suggest = "started_at"
        elif key == "totalDatasources":
            suggest = "total_datasources"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiKnowledgeBaseLastIndexingJob. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiKnowledgeBaseLastIndexingJob.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiKnowledgeBaseLastIndexingJob.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 completed_datasources: Optional[_builtins.int] = None,
                 created_at: Optional[_builtins.str] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 finished_at: Optional[_builtins.str] = None,
                 knowledge_base_uuid: Optional[_builtins.str] = None,
                 phase: Optional[_builtins.str] = None,
                 started_at: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 updated_at: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if knowledge_base_uuid is not None:
            pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiOpenaiApiKeyModel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "inferenceName":
            suggest = "inference_name"
        elif key == "inferenceVersion":
            suggest = "inference_version"
        elif key == "isFoundational":
            suggest = "is_foundational"
        elif key == "parentUuid":
            suggest = "parent_uuid"
        elif key == "updatedAt":
            suggest = "updated_at"
        elif key == "uploadComplete":
            suggest = "upload_complete"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GenaiOpenaiApiKeyModel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GenaiOpenaiApiKeyModel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GenaiOpenaiApiKeyModel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agreements: Optional[Sequence['outputs.GenaiOpenaiApiKeyModelAgreement']] = None,
                 created_at: Optional[_builtins.str] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GenaiOpenaiApiKeyModelVersion']] = None):
        """
        :param Sequence['GenaiOpenaiApiKeyModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GenaiOpenaiApiKeyModelVersionArgs'] versions: URL of the Model
        """
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GenaiOpenaiApiKeyModelAgreement']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GenaiOpenaiApiKeyModelVersion']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GenaiOpenaiApiKeyModelAgreement(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GenaiOpenaiApiKeyModelVersion(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class KubernetesClusterAmdGpuDeviceMetricsExporterPlugin(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Boolean flag whether the component is enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Boolean flag whether the component is enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class KubernetesClusterAmdGpuDevicePlugin(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Boolean flag whether the component should be enabled or not.
               `amd_gpu_device_metrics_exporter_plugin` - (Optional) Block containing options for the AMD GPU device metrics exporter component. If not specified, the component will not be installed in the cluster.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Boolean flag whether the component should be enabled or not.
        `amd_gpu_device_metrics_exporter_plugin` - (Optional) Block containing options for the AMD GPU device metrics exporter component. If not specified, the component will not be installed in the cluster.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class KubernetesClusterClusterAutoscalerConfiguration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleDownUnneededTime":
            suggest = "scale_down_unneeded_time"
        elif key == "scaleDownUtilizationThreshold":
            suggest = "scale_down_utilization_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterClusterAutoscalerConfiguration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterClusterAutoscalerConfiguration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterClusterAutoscalerConfiguration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expanders: Optional[Sequence[_builtins.str]] = None,
                 scale_down_unneeded_time: Optional[_builtins.str] = None,
                 scale_down_utilization_threshold: Optional[_builtins.float] = None):
        """
        :param _builtins.str scale_down_unneeded_time: String setting how long a node should be unneeded before it's eligible for scale down.
               
               This resource supports customized create timeouts. The default timeout is 30 minutes.
        :param _builtins.float scale_down_utilization_threshold: Float setting the Node utilization level, defined as sum of requested resources divided by capacity, in which a node can be considered for scale down.
        """
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if scale_down_unneeded_time is not None:
            pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "expanders")

    @_builtins.property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[_builtins.str]:
        """
        String setting how long a node should be unneeded before it's eligible for scale down.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @_builtins.property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[_builtins.float]:
        """
        Float setting the Node utilization level, defined as sum of requested resources divided by capacity, in which a node can be considered for scale down.
        """
        return pulumi.get(self, "scale_down_utilization_threshold")


@pulumi.output_type
class KubernetesClusterControlPlaneFirewall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedAddresses":
            suggest = "allowed_addresses"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterControlPlaneFirewall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterControlPlaneFirewall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterControlPlaneFirewall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_addresses: Sequence[_builtins.str],
                 enabled: _builtins.bool):
        """
        :param Sequence[_builtins.str] allowed_addresses: A list of addresses allowed (CIDR notation).
        :param _builtins.bool enabled: Boolean flag whether the firewall should be enabled or not.
        """
        pulumi.set(__self__, "allowed_addresses", allowed_addresses)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="allowedAddresses")
    def allowed_addresses(self) -> Sequence[_builtins.str]:
        """
        A list of addresses allowed (CIDR notation).
        """
        return pulumi.get(self, "allowed_addresses")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Boolean flag whether the firewall should be enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class KubernetesClusterKubeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clusterCaCertificate":
            suggest = "cluster_ca_certificate"
        elif key == "expiresAt":
            suggest = "expires_at"
        elif key == "rawConfig":
            suggest = "raw_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterKubeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterKubeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterKubeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_certificate: Optional[_builtins.str] = None,
                 client_key: Optional[_builtins.str] = None,
                 cluster_ca_certificate: Optional[_builtins.str] = None,
                 expires_at: Optional[_builtins.str] = None,
                 host: Optional[_builtins.str] = None,
                 raw_config: Optional[_builtins.str] = None,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_certificate: The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param _builtins.str client_key: The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param _builtins.str cluster_ca_certificate: The base64 encoded public certificate for the cluster's certificate authority.
        :param _builtins.str expires_at: The date and time when the credentials will expire and need to be regenerated.
        :param _builtins.str host: The URL of the API server on the Kubernetes master node.
        :param _builtins.str raw_config: The full contents of the Kubernetes cluster's kubeconfig file.
        :param _builtins.str token: The DigitalOcean API access token used by clients to access the cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if raw_config is not None:
            pulumi.set(__self__, "raw_config", raw_config)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[_builtins.str]:
        """
        The base64 encoded public certificate for the cluster's certificate authority.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[_builtins.str]:
        """
        The date and time when the credentials will expire and need to be regenerated.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[_builtins.str]:
        """
        The URL of the API server on the Kubernetes master node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="rawConfig")
    def raw_config(self) -> Optional[_builtins.str]:
        """
        The full contents of the Kubernetes cluster's kubeconfig file.
        """
        return pulumi.get(self, "raw_config")

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        The DigitalOcean API access token used by clients to access the cluster.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class KubernetesClusterMaintenancePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterMaintenancePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterMaintenancePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterMaintenancePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 day: Optional[_builtins.str] = None,
                 duration: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str day: The day of the maintenance window policy. May be one of "monday" through "sunday", or "any" to indicate an arbitrary week day.
        :param _builtins.str duration: A string denoting the duration of the service window, e.g., "04:00".
        :param _builtins.str start_time: The start time in UTC of the maintenance window policy in 24-hour clock format / HH:MM notation (e.g., 15:00).
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.str]:
        """
        The day of the maintenance window policy. May be one of "monday" through "sunday", or "any" to indicate an arbitrary week day.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[_builtins.str]:
        """
        A string denoting the duration of the service window, e.g., "04:00".
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The start time in UTC of the maintenance window policy in 24-hour clock format / HH:MM notation (e.g., 15:00).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class KubernetesClusterNodePool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "actualNodeCount":
            suggest = "actual_node_count"
        elif key == "autoScale":
            suggest = "auto_scale"
        elif key == "maxNodes":
            suggest = "max_nodes"
        elif key == "minNodes":
            suggest = "min_nodes"
        elif key == "nodeCount":
            suggest = "node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 size: _builtins.str,
                 actual_node_count: Optional[_builtins.int] = None,
                 auto_scale: Optional[_builtins.bool] = None,
                 id: Optional[_builtins.str] = None,
                 labels: Optional[Mapping[str, _builtins.str]] = None,
                 max_nodes: Optional[_builtins.int] = None,
                 min_nodes: Optional[_builtins.int] = None,
                 node_count: Optional[_builtins.int] = None,
                 nodes: Optional[Sequence['outputs.KubernetesClusterNodePoolNode']] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 taints: Optional[Sequence['outputs.KubernetesClusterNodePoolTaint']] = None):
        """
        :param _builtins.str name: A name for the node pool.
        :param _builtins.str size: The slug identifier for the type of Droplet to be used as workers in the node pool.
        :param _builtins.int actual_node_count: A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        :param _builtins.bool auto_scale: Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        :param _builtins.str id: A unique ID that can be used to identify and reference the node.
        :param Mapping[str, _builtins.str] labels: A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        :param _builtins.int max_nodes: If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        :param _builtins.int min_nodes: If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        :param _builtins.int node_count: The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        :param Sequence['KubernetesClusterNodePoolNodeArgs'] nodes: A list of nodes in the pool. Each node exports the following attributes:
        :param Sequence[_builtins.str] tags: A list of tag names applied to the node pool.
        :param Sequence['KubernetesClusterNodePoolTaintArgs'] taints: A block representing a taint applied to all nodes in the pool. Each taint exports the following attributes (taints must be unique by key and effect pair):
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if actual_node_count is not None:
            pulumi.set(__self__, "actual_node_count", actual_node_count)
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_nodes is not None:
            pulumi.set(__self__, "max_nodes", max_nodes)
        if min_nodes is not None:
            pulumi.set(__self__, "min_nodes", min_nodes)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        The slug identifier for the type of Droplet to be used as workers in the node pool.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="actualNodeCount")
    def actual_node_count(self) -> Optional[_builtins.int]:
        """
        A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        """
        return pulumi.get(self, "actual_node_count")

    @_builtins.property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional[_builtins.bool]:
        """
        Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        """
        return pulumi.get(self, "auto_scale")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[_builtins.int]:
        """
        If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        """
        return pulumi.get(self, "max_nodes")

    @_builtins.property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[_builtins.int]:
        """
        If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        """
        return pulumi.get(self, "min_nodes")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[_builtins.int]:
        """
        The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[Sequence['outputs.KubernetesClusterNodePoolNode']]:
        """
        A list of nodes in the pool. Each node exports the following attributes:
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of tag names applied to the node pool.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.KubernetesClusterNodePoolTaint']]:
        """
        A block representing a taint applied to all nodes in the pool. Each taint exports the following attributes (taints must be unique by key and effect pair):
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class KubernetesClusterNodePoolNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "dropletId":
            suggest = "droplet_id"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesClusterNodePoolNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesClusterNodePoolNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesClusterNodePoolNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 droplet_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: The date and time when the node was created.
        :param _builtins.str droplet_id: The id of the node's droplet
        :param _builtins.str id: A unique ID that can be used to identify and reference the node.
        :param _builtins.str name: A name for the Kubernetes cluster.
        :param _builtins.str status: A string indicating the current status of the individual node.
        :param _builtins.str updated_at: The date and time when the node was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[_builtins.str]:
        """
        The id of the node's droplet
        """
        return pulumi.get(self, "droplet_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A name for the Kubernetes cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class KubernetesClusterNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        :param _builtins.str key: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        :param _builtins.str value: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class KubernetesClusterRoutingAgent(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        """
        :param _builtins.bool enabled: Boolean flag whether the routing-agent should be enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Boolean flag whether the routing-agent should be enabled or not.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class KubernetesNodePoolNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createdAt":
            suggest = "created_at"
        elif key == "dropletId":
            suggest = "droplet_id"
        elif key == "updatedAt":
            suggest = "updated_at"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in KubernetesNodePoolNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        KubernetesNodePoolNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        KubernetesNodePoolNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 created_at: Optional[_builtins.str] = None,
                 droplet_id: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 updated_at: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: The date and time when the node was created.
        :param _builtins.str droplet_id: The id of the node's droplet
        :param _builtins.str id: A unique ID that can be used to identify and reference the node.
        :param _builtins.str name: A name for the node pool.
        :param _builtins.str status: A string indicating the current status of the individual node.
        :param _builtins.str updated_at: The date and time when the node was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[_builtins.str]:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[_builtins.str]:
        """
        The id of the node's droplet
        """
        return pulumi.get(self, "droplet_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[_builtins.str]:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class KubernetesNodePoolTaint(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        :param _builtins.str key: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        :param _builtins.str value: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class LoadBalancerDomain(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "certificateId":
            suggest = "certificate_id"
        elif key == "certificateName":
            suggest = "certificate_name"
        elif key == "isManaged":
            suggest = "is_managed"
        elif key == "sslValidationErrorReasons":
            suggest = "ssl_validation_error_reasons"
        elif key == "verificationErrorReasons":
            suggest = "verification_error_reasons"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerDomain. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerDomain.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerDomain.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 certificate_id: Optional[_builtins.str] = None,
                 certificate_name: Optional[_builtins.str] = None,
                 is_managed: Optional[_builtins.bool] = None,
                 ssl_validation_error_reasons: Optional[Sequence[_builtins.str]] = None,
                 verification_error_reasons: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: The domain name to be used for ingressing traffic to a Global Load Balancer.
        :param _builtins.str certificate_id: **Deprecated** The certificate ID to be used for TLS handshaking.
        :param _builtins.str certificate_name: The certificate name to be used for TLS handshaking.
        :param _builtins.bool is_managed: Control flag to specify whether the domain is managed by DigitalOcean.
        :param Sequence[_builtins.str] ssl_validation_error_reasons: list of domain SSL validation errors
        :param Sequence[_builtins.str] verification_error_reasons: list of domain verification errors
        """
        pulumi.set(__self__, "name", name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if is_managed is not None:
            pulumi.set(__self__, "is_managed", is_managed)
        if ssl_validation_error_reasons is not None:
            pulumi.set(__self__, "ssl_validation_error_reasons", ssl_validation_error_reasons)
        if verification_error_reasons is not None:
            pulumi.set(__self__, "verification_error_reasons", verification_error_reasons)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The domain name to be used for ingressing traffic to a Global Load Balancer.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        **Deprecated** The certificate ID to be used for TLS handshaking.
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[_builtins.str]:
        """
        The certificate name to be used for TLS handshaking.
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="isManaged")
    def is_managed(self) -> Optional[_builtins.bool]:
        """
        Control flag to specify whether the domain is managed by DigitalOcean.
        """
        return pulumi.get(self, "is_managed")

    @_builtins.property
    @pulumi.getter(name="sslValidationErrorReasons")
    def ssl_validation_error_reasons(self) -> Optional[Sequence[_builtins.str]]:
        """
        list of domain SSL validation errors
        """
        return pulumi.get(self, "ssl_validation_error_reasons")

    @_builtins.property
    @pulumi.getter(name="verificationErrorReasons")
    def verification_error_reasons(self) -> Optional[Sequence[_builtins.str]]:
        """
        list of domain verification errors
        """
        return pulumi.get(self, "verification_error_reasons")


@pulumi.output_type
class LoadBalancerFirewall(dict):
    def __init__(__self__, *,
                 allows: Optional[Sequence[_builtins.str]] = None,
                 denies: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] allows: A list of strings describing allow rules. Must be colon delimited strings of the form `{type}:{source}`
               * Ex. `deny = ["cidr:1.2.0.0/16", "ip:2.3.4.5"]` or `allow = ["ip:1.2.3.4", "cidr:2.3.4.0/24"]`
        :param Sequence[_builtins.str] denies: A list of strings describing deny rules. Must be colon delimited strings of the form `{type}:{source}`
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)

    @_builtins.property
    @pulumi.getter
    def allows(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of strings describing allow rules. Must be colon delimited strings of the form `{type}:{source}`
        * Ex. `deny = ["cidr:1.2.0.0/16", "ip:2.3.4.5"]` or `allow = ["ip:1.2.3.4", "cidr:2.3.4.0/24"]`
        """
        return pulumi.get(self, "allows")

    @_builtins.property
    @pulumi.getter
    def denies(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of strings describing deny rules. Must be colon delimited strings of the form `{type}:{source}`
        """
        return pulumi.get(self, "denies")


@pulumi.output_type
class LoadBalancerForwardingRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entryPort":
            suggest = "entry_port"
        elif key == "entryProtocol":
            suggest = "entry_protocol"
        elif key == "targetPort":
            suggest = "target_port"
        elif key == "targetProtocol":
            suggest = "target_protocol"
        elif key == "certificateId":
            suggest = "certificate_id"
        elif key == "certificateName":
            suggest = "certificate_name"
        elif key == "tlsPassthrough":
            suggest = "tls_passthrough"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerForwardingRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerForwardingRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerForwardingRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entry_port: _builtins.int,
                 entry_protocol: _builtins.str,
                 target_port: _builtins.int,
                 target_protocol: _builtins.str,
                 certificate_id: Optional[_builtins.str] = None,
                 certificate_name: Optional[_builtins.str] = None,
                 tls_passthrough: Optional[_builtins.bool] = None):
        """
        :param _builtins.int entry_port: An integer representing the port on which the Load Balancer instance will listen.
        :param _builtins.str entry_protocol: The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`.
        :param _builtins.int target_port: An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        :param _builtins.str target_protocol: The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`.
        :param _builtins.str certificate_id: **Deprecated** The ID of the TLS certificate to be used for SSL termination. Use `certificate_name` instead.
        :param _builtins.str certificate_name: The unique name of the TLS certificate to be used for SSL termination.
        :param _builtins.bool tls_passthrough: A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
        pulumi.set(__self__, "entry_port", entry_port)
        pulumi.set(__self__, "entry_protocol", entry_protocol)
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if tls_passthrough is not None:
            pulumi.set(__self__, "tls_passthrough", tls_passthrough)

    @_builtins.property
    @pulumi.getter(name="entryPort")
    def entry_port(self) -> _builtins.int:
        """
        An integer representing the port on which the Load Balancer instance will listen.
        """
        return pulumi.get(self, "entry_port")

    @_builtins.property
    @pulumi.getter(name="entryProtocol")
    def entry_protocol(self) -> _builtins.str:
        """
        The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`.
        """
        return pulumi.get(self, "entry_protocol")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> _builtins.int:
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        """
        return pulumi.get(self, "target_port")

    @_builtins.property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> _builtins.str:
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`.
        """
        return pulumi.get(self, "target_protocol")

    @_builtins.property
    @pulumi.getter(name="certificateId")
    @_utilities.deprecated("""Certificate IDs may change, for example when a Let's Encrypt certificate is auto-renewed. Please specify 'certificate_name' instead.""")
    def certificate_id(self) -> Optional[_builtins.str]:
        """
        **Deprecated** The ID of the TLS certificate to be used for SSL termination. Use `certificate_name` instead.
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[_builtins.str]:
        """
        The unique name of the TLS certificate to be used for SSL termination.
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="tlsPassthrough")
    def tls_passthrough(self) -> Optional[_builtins.bool]:
        """
        A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
        return pulumi.get(self, "tls_passthrough")


@pulumi.output_type
class LoadBalancerGlbSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetPort":
            suggest = "target_port"
        elif key == "targetProtocol":
            suggest = "target_protocol"
        elif key == "failoverThreshold":
            suggest = "failover_threshold"
        elif key == "regionPriorities":
            suggest = "region_priorities"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerGlbSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerGlbSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerGlbSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_port: _builtins.int,
                 target_protocol: _builtins.str,
                 cdn: Optional['outputs.LoadBalancerGlbSettingsCdn'] = None,
                 failover_threshold: Optional[_builtins.int] = None,
                 region_priorities: Optional[Mapping[str, _builtins.int]] = None):
        """
        :param _builtins.int target_port: An integer representing the port on the backend Droplets to which the Load Balancer will send traffic. The possible values are: `80` for `http` and `443` for `https`.
        :param _builtins.str target_protocol: The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http` and `https`.
        :param 'LoadBalancerGlbSettingsCdnArgs' cdn: CDN configuration supporting the following:
        :param _builtins.int failover_threshold: fail-over threshold
        :param Mapping[str, _builtins.int] region_priorities: region priority map
        """
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if cdn is not None:
            pulumi.set(__self__, "cdn", cdn)
        if failover_threshold is not None:
            pulumi.set(__self__, "failover_threshold", failover_threshold)
        if region_priorities is not None:
            pulumi.set(__self__, "region_priorities", region_priorities)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> _builtins.int:
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic. The possible values are: `80` for `http` and `443` for `https`.
        """
        return pulumi.get(self, "target_port")

    @_builtins.property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> _builtins.str:
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http` and `https`.
        """
        return pulumi.get(self, "target_protocol")

    @_builtins.property
    @pulumi.getter
    def cdn(self) -> Optional['outputs.LoadBalancerGlbSettingsCdn']:
        """
        CDN configuration supporting the following:
        """
        return pulumi.get(self, "cdn")

    @_builtins.property
    @pulumi.getter(name="failoverThreshold")
    def failover_threshold(self) -> Optional[_builtins.int]:
        """
        fail-over threshold
        """
        return pulumi.get(self, "failover_threshold")

    @_builtins.property
    @pulumi.getter(name="regionPriorities")
    def region_priorities(self) -> Optional[Mapping[str, _builtins.int]]:
        """
        region priority map
        """
        return pulumi.get(self, "region_priorities")


@pulumi.output_type
class LoadBalancerGlbSettingsCdn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "isEnabled":
            suggest = "is_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerGlbSettingsCdn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerGlbSettingsCdn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerGlbSettingsCdn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 is_enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool is_enabled: Control flag to specify if caching is enabled.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[_builtins.bool]:
        """
        Control flag to specify if caching is enabled.
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class LoadBalancerHealthcheck(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "checkIntervalSeconds":
            suggest = "check_interval_seconds"
        elif key == "healthyThreshold":
            suggest = "healthy_threshold"
        elif key == "responseTimeoutSeconds":
            suggest = "response_timeout_seconds"
        elif key == "unhealthyThreshold":
            suggest = "unhealthy_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerHealthcheck. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerHealthcheck.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerHealthcheck.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 check_interval_seconds: Optional[_builtins.int] = None,
                 healthy_threshold: Optional[_builtins.int] = None,
                 path: Optional[_builtins.str] = None,
                 response_timeout_seconds: Optional[_builtins.int] = None,
                 unhealthy_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.int port: An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        :param _builtins.str protocol: The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https` or `tcp`.
        :param _builtins.int check_interval_seconds: The number of seconds between two consecutive health checks. If not specified, the default value is `10`.
        :param _builtins.int healthy_threshold: The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        :param _builtins.str path: The path on the backend Droplets to which the Load Balancer instance will send a request.
        :param _builtins.int response_timeout_seconds: The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        :param _builtins.int unhealthy_threshold: The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if check_interval_seconds is not None:
            pulumi.set(__self__, "check_interval_seconds", check_interval_seconds)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if response_timeout_seconds is not None:
            pulumi.set(__self__, "response_timeout_seconds", response_timeout_seconds)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https` or `tcp`.
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="checkIntervalSeconds")
    def check_interval_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds between two consecutive health checks. If not specified, the default value is `10`.
        """
        return pulumi.get(self, "check_interval_seconds")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[_builtins.int]:
        """
        The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        The path on the backend Droplets to which the Load Balancer instance will send a request.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="responseTimeoutSeconds")
    def response_timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        """
        return pulumi.get(self, "response_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[_builtins.int]:
        """
        The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class LoadBalancerStickySessions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "cookieName":
            suggest = "cookie_name"
        elif key == "cookieTtlSeconds":
            suggest = "cookie_ttl_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in LoadBalancerStickySessions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        LoadBalancerStickySessions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        LoadBalancerStickySessions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cookie_name: Optional[_builtins.str] = None,
                 cookie_ttl_seconds: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str cookie_name: The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        :param _builtins.int cookie_ttl_seconds: The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        :param _builtins.str type: An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if cookie_ttl_seconds is not None:
            pulumi.set(__self__, "cookie_ttl_seconds", cookie_ttl_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[_builtins.str]:
        """
        The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_name")

    @_builtins.property
    @pulumi.getter(name="cookieTtlSeconds")
    def cookie_ttl_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_ttl_seconds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class MonitorAlertAlerts(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slacks: Optional[Sequence['outputs.MonitorAlertAlertsSlack']] = None):
        """
        :param Sequence[_builtins.str] emails: List of email addresses to sent notifications to
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of email addresses to sent notifications to
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter
    def slacks(self) -> Optional[Sequence['outputs.MonitorAlertAlertsSlack']]:
        return pulumi.get(self, "slacks")


@pulumi.output_type
class MonitorAlertAlertsSlack(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send alerts to
        :param _builtins.str url: The webhook URL for Slack
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send alerts to
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The webhook URL for Slack
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class PartnerAttachmentBgp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "authKey":
            suggest = "auth_key"
        elif key == "localRouterIp":
            suggest = "local_router_ip"
        elif key == "peerRouterAsn":
            suggest = "peer_router_asn"
        elif key == "peerRouterIp":
            suggest = "peer_router_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PartnerAttachmentBgp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PartnerAttachmentBgp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PartnerAttachmentBgp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auth_key: Optional[_builtins.str] = None,
                 local_router_ip: Optional[_builtins.str] = None,
                 peer_router_asn: Optional[_builtins.int] = None,
                 peer_router_ip: Optional[_builtins.str] = None):
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if local_router_ip is not None:
            pulumi.set(__self__, "local_router_ip", local_router_ip)
        if peer_router_asn is not None:
            pulumi.set(__self__, "peer_router_asn", peer_router_asn)
        if peer_router_ip is not None:
            pulumi.set(__self__, "peer_router_ip", peer_router_ip)

    @_builtins.property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "auth_key")

    @_builtins.property
    @pulumi.getter(name="localRouterIp")
    def local_router_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "local_router_ip")

    @_builtins.property
    @pulumi.getter(name="peerRouterAsn")
    def peer_router_asn(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "peer_router_asn")

    @_builtins.property
    @pulumi.getter(name="peerRouterIp")
    def peer_router_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "peer_router_ip")


@pulumi.output_type
class SpacesBucketCorsConfigurationCorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "exposeHeaders":
            suggest = "expose_headers"
        elif key == "maxAgeSeconds":
            suggest = "max_age_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpacesBucketCorsConfigurationCorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpacesBucketCorsConfigurationCorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpacesBucketCorsConfigurationCorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[_builtins.str],
                 allowed_origins: Sequence[_builtins.str],
                 allowed_headers: Optional[Sequence[_builtins.str]] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 id: Optional[_builtins.str] = None,
                 max_age_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] allowed_methods: Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        :param Sequence[_builtins.str] allowed_origins: Set of origins you want customers to be able to access the bucket from.
        :param Sequence[_builtins.str] allowed_headers: Set of Headers that are specified in the Access-Control-Request-Headers header.
        :param Sequence[_builtins.str] expose_headers: Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        :param _builtins.str id: Unique identifier for the rule. The value cannot be longer than 255 characters.
        :param _builtins.int max_age_seconds: Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[_builtins.str]:
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        """
        return pulumi.get(self, "allowed_methods")

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[_builtins.str]:
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Set of Headers that are specified in the Access-Control-Request-Headers header.
        """
        return pulumi.get(self, "allowed_headers")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[_builtins.int]:
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class SpacesBucketCorsRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowedMethods":
            suggest = "allowed_methods"
        elif key == "allowedOrigins":
            suggest = "allowed_origins"
        elif key == "allowedHeaders":
            suggest = "allowed_headers"
        elif key == "maxAgeSeconds":
            suggest = "max_age_seconds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpacesBucketCorsRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpacesBucketCorsRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpacesBucketCorsRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allowed_methods: Sequence[_builtins.str],
                 allowed_origins: Sequence[_builtins.str],
                 allowed_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age_seconds: Optional[_builtins.int] = None):
        """
        :param Sequence[_builtins.str] allowed_methods: A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        :param Sequence[_builtins.str] allowed_origins: A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        :param Sequence[_builtins.str] allowed_headers: A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        :param _builtins.int max_age_seconds: The time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> Sequence[_builtins.str]:
        """
        A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        """
        return pulumi.get(self, "allowed_methods")

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> Sequence[_builtins.str]:
        """
        A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        """
        return pulumi.get(self, "allowed_origins")

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        """
        return pulumi.get(self, "allowed_headers")

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[_builtins.int]:
        """
        The time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")


@pulumi.output_type
class SpacesBucketLifecycleRule(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "abortIncompleteMultipartUploadDays":
            suggest = "abort_incomplete_multipart_upload_days"
        elif key == "noncurrentVersionExpiration":
            suggest = "noncurrent_version_expiration"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpacesBucketLifecycleRule. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpacesBucketLifecycleRule.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpacesBucketLifecycleRule.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 abort_incomplete_multipart_upload_days: Optional[_builtins.int] = None,
                 expiration: Optional['outputs.SpacesBucketLifecycleRuleExpiration'] = None,
                 id: Optional[_builtins.str] = None,
                 noncurrent_version_expiration: Optional['outputs.SpacesBucketLifecycleRuleNoncurrentVersionExpiration'] = None,
                 prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: Specifies lifecycle rule status.
        :param _builtins.int abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart
               upload when the multipart upload must be completed or else Spaces will abort the upload.
        :param 'SpacesBucketLifecycleRuleExpirationArgs' expiration: Specifies a time period after which applicable objects expire (documented below).
        :param _builtins.str id: Unique identifier for the rule.
        :param 'SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs' noncurrent_version_expiration: Specifies when non-current object versions expire (documented below).
               
               At least one of `expiration` or `noncurrent_version_expiration` must be specified.
        :param _builtins.str prefix: Object key prefix identifying one or more objects to which the rule applies.
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days after initiating a multipart
        upload when the multipart upload must be completed or else Spaces will abort the upload.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional['outputs.SpacesBucketLifecycleRuleExpiration']:
        """
        Specifies a time period after which applicable objects expire (documented below).
        """
        return pulumi.get(self, "expiration")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        Unique identifier for the rule.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional['outputs.SpacesBucketLifecycleRuleNoncurrentVersionExpiration']:
        """
        Specifies when non-current object versions expire (documented below).

        At least one of `expiration` or `noncurrent_version_expiration` must be specified.
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[_builtins.str]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class SpacesBucketLifecycleRuleExpiration(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expiredObjectDeleteMarker":
            suggest = "expired_object_delete_marker"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpacesBucketLifecycleRuleExpiration. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpacesBucketLifecycleRuleExpiration.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpacesBucketLifecycleRuleExpiration.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 date: Optional[_builtins.str] = None,
                 days: Optional[_builtins.int] = None,
                 expired_object_delete_marker: Optional[_builtins.bool] = None):
        """
        :param _builtins.str date: Specifies the date/time after which you want applicable objects to expire. The argument uses
               RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        :param _builtins.int days: Specifies the number of days after object creation when the applicable objects will expire.
        :param _builtins.bool expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended
               bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[_builtins.str]:
        """
        Specifies the date/time after which you want applicable objects to expire. The argument uses
        RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        """
        return pulumi.get(self, "date")

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days after object creation when the applicable objects will expire.
        """
        return pulumi.get(self, "days")

    @_builtins.property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[_builtins.bool]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended
        bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
        return pulumi.get(self, "expired_object_delete_marker")


@pulumi.output_type
class SpacesBucketLifecycleRuleNoncurrentVersionExpiration(dict):
    def __init__(__self__, *,
                 days: Optional[_builtins.int] = None):
        """
        :param _builtins.int days: Specifies the number of days after which an object's non-current versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[_builtins.int]:
        """
        Specifies the number of days after which an object's non-current versions expire.
        """
        return pulumi.get(self, "days")


@pulumi.output_type
class SpacesBucketVersioning(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
               state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
        state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class SpacesKeyGrant(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str bucket: Name of the bucket associated with this grant. In case of a `fullaccess` permission, this value should be an empty string.
        :param _builtins.str permission: Permission associated with this grant. Values can be `read`, `readwrite`, `fullaccess`.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        Name of the bucket associated with this grant. In case of a `fullaccess` permission, this value should be an empty string.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        Permission associated with this grant. Values can be `read`, `readwrite`, `fullaccess`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class UptimeAlertNotification(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slacks: Optional[Sequence['outputs.UptimeAlertNotificationSlack']] = None):
        """
        :param Sequence[_builtins.str] emails: List of email addresses to sent notifications to.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of email addresses to sent notifications to.
        """
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter
    def slacks(self) -> Optional[Sequence['outputs.UptimeAlertNotificationSlack']]:
        return pulumi.get(self, "slacks")


@pulumi.output_type
class UptimeAlertNotificationSlack(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send alerts to.
        :param _builtins.str url: The webhook URL for Slack.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send alerts to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The webhook URL for Slack.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class VpcNatGatewayEgress(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "publicGateways":
            suggest = "public_gateways"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcNatGatewayEgress. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcNatGatewayEgress.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcNatGatewayEgress.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 public_gateways: Optional[Sequence['outputs.VpcNatGatewayEgressPublicGateway']] = None):
        """
        :param Sequence['VpcNatGatewayEgressPublicGatewayArgs'] public_gateways: List of public gateway IPs
        """
        if public_gateways is not None:
            pulumi.set(__self__, "public_gateways", public_gateways)

    @_builtins.property
    @pulumi.getter(name="publicGateways")
    def public_gateways(self) -> Optional[Sequence['outputs.VpcNatGatewayEgressPublicGateway']]:
        """
        List of public gateway IPs
        """
        return pulumi.get(self, "public_gateways")


@pulumi.output_type
class VpcNatGatewayEgressPublicGateway(dict):
    def __init__(__self__, *,
                 ipv4: Optional[_builtins.str] = None):
        """
        :param _builtins.str ipv4: IPv4 address
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[_builtins.str]:
        """
        IPv4 address
        """
        return pulumi.get(self, "ipv4")


@pulumi.output_type
class VpcNatGatewayVpc(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vpcUuid":
            suggest = "vpc_uuid"
        elif key == "defaultGateway":
            suggest = "default_gateway"
        elif key == "gatewayIp":
            suggest = "gateway_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VpcNatGatewayVpc. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VpcNatGatewayVpc.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VpcNatGatewayVpc.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vpc_uuid: _builtins.str,
                 default_gateway: Optional[_builtins.bool] = None,
                 gateway_ip: Optional[_builtins.str] = None):
        """
        :param _builtins.str vpc_uuid: The ID of the ingress VPC
        :param _builtins.bool default_gateway: Boolean flag indicating if this should be the default gateway in this VPC
        :param _builtins.str gateway_ip: The private IP of the VPC NAT Gateway
        """
        pulumi.set(__self__, "vpc_uuid", vpc_uuid)
        if default_gateway is not None:
            pulumi.set(__self__, "default_gateway", default_gateway)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)

    @_builtins.property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> _builtins.str:
        """
        The ID of the ingress VPC
        """
        return pulumi.get(self, "vpc_uuid")

    @_builtins.property
    @pulumi.getter(name="defaultGateway")
    def default_gateway(self) -> Optional[_builtins.bool]:
        """
        Boolean flag indicating if this should be the default gateway in this VPC
        """
        return pulumi.get(self, "default_gateway")

    @_builtins.property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[_builtins.str]:
        """
        The private IP of the VPC NAT Gateway
        """
        return pulumi.get(self, "gateway_ip")


@pulumi.output_type
class GetAppDedicatedIpResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 ip: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str id: The ID of the dedicated egress IP.
        :param _builtins.str ip: The IP address of the dedicated egress IP.
        :param _builtins.str status: The status of the dedicated egress IP.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the dedicated egress IP.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The IP address of the dedicated egress IP.
        """
        return pulumi.get(self, "ip")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the dedicated egress IP.
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetAppSpecResult(dict):
    def __init__(__self__, *,
                 domain: Sequence['outputs.GetAppSpecDomainResult'],
                 domains: Sequence[_builtins.str],
                 features: Sequence[_builtins.str],
                 ingress: 'outputs.GetAppSpecIngressResult',
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.GetAppSpecAlertResult']] = None,
                 databases: Optional[Sequence['outputs.GetAppSpecDatabaseResult']] = None,
                 disable_edge_cache: Optional[_builtins.bool] = None,
                 disable_email_obfuscation: Optional[_builtins.bool] = None,
                 egresses: Optional[Sequence['outputs.GetAppSpecEgressResult']] = None,
                 enhanced_threat_control_enabled: Optional[_builtins.bool] = None,
                 envs: Optional[Sequence['outputs.GetAppSpecEnvResult']] = None,
                 functions: Optional[Sequence['outputs.GetAppSpecFunctionResult']] = None,
                 jobs: Optional[Sequence['outputs.GetAppSpecJobResult']] = None,
                 maintenance: Optional['outputs.GetAppSpecMaintenanceResult'] = None,
                 region: Optional[_builtins.str] = None,
                 services: Optional[Sequence['outputs.GetAppSpecServiceResult']] = None,
                 static_sites: Optional[Sequence['outputs.GetAppSpecStaticSiteResult']] = None,
                 vpcs: Optional[Sequence['outputs.GetAppSpecVpcResult']] = None,
                 workers: Optional[Sequence['outputs.GetAppSpecWorkerResult']] = None):
        """
        :param Sequence[_builtins.str] features: List of features which is applied to the app
        :param _builtins.str name: The name of the component.
        :param Sequence['GetAppSpecAlertArgs'] alerts: Describes an alert policy for the component.
        :param _builtins.bool disable_edge_cache: Whether to disable the edge cache for the app. Default is false, which enables the edge cache.
        :param _builtins.bool disable_email_obfuscation: Email obfuscation configuration for the app. Default is false, which keeps the email obfuscated.
        :param _builtins.bool enhanced_threat_control_enabled: Whether to enable enhanced threat control for the app. Default is false. Set to true to enable enhanced threat control, putting additional security measures for Layer 7 DDoS attacks.
        :param Sequence['GetAppSpecEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'GetAppSpecMaintenanceArgs' maintenance: Specification to configure maintenance settings for the app, such as maintenance mode and archiving the app.
        :param _builtins.str region: The slug for the DigitalOcean data center region hosting the app
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "domains", domains)
        pulumi.set(__self__, "features", features)
        pulumi.set(__self__, "ingress", ingress)
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if disable_edge_cache is not None:
            pulumi.set(__self__, "disable_edge_cache", disable_edge_cache)
        if disable_email_obfuscation is not None:
            pulumi.set(__self__, "disable_email_obfuscation", disable_email_obfuscation)
        if egresses is not None:
            pulumi.set(__self__, "egresses", egresses)
        if enhanced_threat_control_enabled is not None:
            pulumi.set(__self__, "enhanced_threat_control_enabled", enhanced_threat_control_enabled)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if maintenance is not None:
            pulumi.set(__self__, "maintenance", maintenance)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if static_sites is not None:
            pulumi.set(__self__, "static_sites", static_sites)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Sequence['outputs.GetAppSpecDomainResult']:
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute has been replaced by `domain` which supports additional functionality.""")
    def domains(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "domains")

    @_builtins.property
    @pulumi.getter
    def features(self) -> Sequence[_builtins.str]:
        """
        List of features which is applied to the app
        """
        return pulumi.get(self, "features")

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> 'outputs.GetAppSpecIngressResult':
        return pulumi.get(self, "ingress")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.GetAppSpecAlertResult']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Optional[Sequence['outputs.GetAppSpecDatabaseResult']]:
        return pulumi.get(self, "databases")

    @_builtins.property
    @pulumi.getter(name="disableEdgeCache")
    def disable_edge_cache(self) -> Optional[_builtins.bool]:
        """
        Whether to disable the edge cache for the app. Default is false, which enables the edge cache.
        """
        return pulumi.get(self, "disable_edge_cache")

    @_builtins.property
    @pulumi.getter(name="disableEmailObfuscation")
    def disable_email_obfuscation(self) -> Optional[_builtins.bool]:
        """
        Email obfuscation configuration for the app. Default is false, which keeps the email obfuscated.
        """
        return pulumi.get(self, "disable_email_obfuscation")

    @_builtins.property
    @pulumi.getter
    def egresses(self) -> Optional[Sequence['outputs.GetAppSpecEgressResult']]:
        return pulumi.get(self, "egresses")

    @_builtins.property
    @pulumi.getter(name="enhancedThreatControlEnabled")
    def enhanced_threat_control_enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to enable enhanced threat control for the app. Default is false. Set to true to enable enhanced threat control, putting additional security measures for Layer 7 DDoS attacks.
        """
        return pulumi.get(self, "enhanced_threat_control_enabled")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetAppSpecEnvResult']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.GetAppSpecFunctionResult']]:
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[Sequence['outputs.GetAppSpecJobResult']]:
        return pulumi.get(self, "jobs")

    @_builtins.property
    @pulumi.getter
    def maintenance(self) -> Optional['outputs.GetAppSpecMaintenanceResult']:
        """
        Specification to configure maintenance settings for the app, such as maintenance mode and archiving the app.
        """
        return pulumi.get(self, "maintenance")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The slug for the DigitalOcean data center region hosting the app
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[Sequence['outputs.GetAppSpecServiceResult']]:
        return pulumi.get(self, "services")

    @_builtins.property
    @pulumi.getter(name="staticSites")
    def static_sites(self) -> Optional[Sequence['outputs.GetAppSpecStaticSiteResult']]:
        return pulumi.get(self, "static_sites")

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[Sequence['outputs.GetAppSpecVpcResult']]:
        return pulumi.get(self, "vpcs")

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[Sequence['outputs.GetAppSpecWorkerResult']]:
        return pulumi.get(self, "workers")


@pulumi.output_type
class GetAppSpecAlertResult(dict):
    def __init__(__self__, *,
                 rule: _builtins.str,
                 destinations: Optional['outputs.GetAppSpecAlertDestinationsResult'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "rule", rule)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.GetAppSpecAlertDestinationsResult']:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GetAppSpecAlertDestinationsResult(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.GetAppSpecAlertDestinationsSlackWebhookResult']] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.GetAppSpecAlertDestinationsSlackWebhookResult']]:
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class GetAppSpecAlertDestinationsSlackWebhookResult(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetAppSpecDatabaseResult(dict):
    def __init__(__self__, *,
                 cluster_name: Optional[_builtins.str] = None,
                 db_name: Optional[_builtins.str] = None,
                 db_user: Optional[_builtins.str] = None,
                 engine: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 production: Optional[_builtins.bool] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str db_name: The name of the MySQL or PostgreSQL database to configure.
        :param _builtins.str db_user: The name of the MySQL or PostgreSQL user to configure.
        :param _builtins.str engine: The database engine to use (`MYSQL`, `PG`, `REDIS`, or `MONGODB`).
        :param _builtins.str name: The name of the component.
        :param _builtins.bool production: Whether this is a production or dev database.
        :param _builtins.str version: The version of the database engine.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if production is not None:
            pulumi.set(__self__, "production", production)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[_builtins.str]:
        """
        The name of the MySQL or PostgreSQL database to configure.
        """
        return pulumi.get(self, "db_name")

    @_builtins.property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[_builtins.str]:
        """
        The name of the MySQL or PostgreSQL user to configure.
        """
        return pulumi.get(self, "db_user")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        The database engine to use (`MYSQL`, `PG`, `REDIS`, or `MONGODB`).
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def production(self) -> Optional[_builtins.bool]:
        """
        Whether this is a production or dev database.
        """
        return pulumi.get(self, "production")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        The version of the database engine.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetAppSpecDomainResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 type: _builtins.str,
                 wildcard: _builtins.bool,
                 zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the component.
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.bool wildcard: Indicates whether the domain includes all sub-domains, in addition to the given domain.
        :param _builtins.str zone: If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "wildcard", wildcard)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def wildcard(self) -> _builtins.bool:
        """
        Indicates whether the domain includes all sub-domains, in addition to the given domain.
        """
        return pulumi.get(self, "wildcard")

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[_builtins.str]:
        """
        If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
        return pulumi.get(self, "zone")


@pulumi.output_type
class GetAppSpecEgressResult(dict):
    def __init__(__self__, *,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetAppSpecEnvResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str value: The threshold for the type of the warning.
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppSpecFunctionResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 routes: Sequence['outputs.GetAppSpecFunctionRouteResult'],
                 alerts: Optional[Sequence['outputs.GetAppSpecFunctionAlertResult']] = None,
                 bitbucket: Optional['outputs.GetAppSpecFunctionBitbucketResult'] = None,
                 cors: Optional['outputs.GetAppSpecFunctionCorsResult'] = None,
                 envs: Optional[Sequence['outputs.GetAppSpecFunctionEnvResult']] = None,
                 git: Optional['outputs.GetAppSpecFunctionGitResult'] = None,
                 github: Optional['outputs.GetAppSpecFunctionGithubResult'] = None,
                 gitlab: Optional['outputs.GetAppSpecFunctionGitlabResult'] = None,
                 log_destinations: Optional[Sequence['outputs.GetAppSpecFunctionLogDestinationResult']] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the component.
        :param Sequence['GetAppSpecFunctionAlertArgs'] alerts: Describes an alert policy for the component.
        :param 'GetAppSpecFunctionBitbucketArgs' bitbucket: A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        :param 'GetAppSpecFunctionCorsArgs' cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param Sequence['GetAppSpecFunctionEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'GetAppSpecFunctionGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        :param 'GetAppSpecFunctionGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'GetAppSpecFunctionGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param Sequence['GetAppSpecFunctionLogDestinationArgs'] log_destinations: Describes a log forwarding destination.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routes", routes)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Sequence['outputs.GetAppSpecFunctionRouteResult']:
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.GetAppSpecFunctionAlertResult']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.GetAppSpecFunctionBitbucketResult']:
        """
        A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional['outputs.GetAppSpecFunctionCorsResult']:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetAppSpecFunctionEnvResult']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.GetAppSpecFunctionGitResult']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.GetAppSpecFunctionGithubResult']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.GetAppSpecFunctionGitlabResult']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[Sequence['outputs.GetAppSpecFunctionLogDestinationResult']]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class GetAppSpecFunctionAlertResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 rule: _builtins.str,
                 value: _builtins.float,
                 window: _builtins.str,
                 destinations: Optional['outputs.GetAppSpecFunctionAlertDestinationsResult'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.float value: The threshold for the type of the warning.
        :param _builtins.str window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> _builtins.str:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.GetAppSpecFunctionAlertDestinationsResult']:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GetAppSpecFunctionAlertDestinationsResult(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.GetAppSpecFunctionAlertDestinationsSlackWebhookResult']] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.GetAppSpecFunctionAlertDestinationsSlackWebhookResult']]:
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class GetAppSpecFunctionAlertDestinationsSlackWebhookResult(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetAppSpecFunctionBitbucketResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecFunctionCorsResult(dict):
    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional['outputs.GetAppSpecFunctionCorsAllowOriginsResult'] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        :param 'GetAppSpecFunctionCorsAllowOriginsArgs' allow_origins: The `Access-Control-Allow-Origin` can be
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional['outputs.GetAppSpecFunctionCorsAllowOriginsResult']:
        """
        The `Access-Control-Allow-Origin` can be
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetAppSpecFunctionCorsAllowOriginsResult(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        :param _builtins.str prefix: The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        :param _builtins.str regex: The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAppSpecFunctionEnvResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str value: The threshold for the type of the warning.
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppSpecFunctionGitResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class GetAppSpecFunctionGithubResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecFunctionGitlabResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecFunctionLogDestinationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.GetAppSpecFunctionLogDestinationDatadogResult'] = None,
                 logtail: Optional['outputs.GetAppSpecFunctionLogDestinationLogtailResult'] = None,
                 open_search: Optional['outputs.GetAppSpecFunctionLogDestinationOpenSearchResult'] = None,
                 papertrail: Optional['outputs.GetAppSpecFunctionLogDestinationPapertrailResult'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param 'GetAppSpecFunctionLogDestinationDatadogArgs' datadog: Datadog configuration.
        :param 'GetAppSpecFunctionLogDestinationLogtailArgs' logtail: Logtail configuration.
        :param 'GetAppSpecFunctionLogDestinationOpenSearchArgs' open_search: OpenSearch configuration.
        :param 'GetAppSpecFunctionLogDestinationPapertrailArgs' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.GetAppSpecFunctionLogDestinationDatadogResult']:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.GetAppSpecFunctionLogDestinationLogtailResult']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.GetAppSpecFunctionLogDestinationOpenSearchResult']:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.GetAppSpecFunctionLogDestinationPapertrailResult']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class GetAppSpecFunctionLogDestinationDatadogResult(dict):
    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetAppSpecFunctionLogDestinationLogtailResult(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetAppSpecFunctionLogDestinationOpenSearchResult(dict):
    def __init__(__self__, *,
                 basic_auth: 'outputs.GetAppSpecFunctionLogDestinationOpenSearchBasicAuthResult',
                 cluster_name: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 index_name: Optional[_builtins.str] = None):
        """
        :param 'GetAppSpecFunctionLogDestinationOpenSearchBasicAuthArgs' basic_auth: OpenSearch basic auth
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        :param _builtins.str index_name: The index name to use for the logs. If not set, the default index name is `logs`.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.GetAppSpecFunctionLogDestinationOpenSearchBasicAuthResult':
        """
        OpenSearch basic auth
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        """
        The index name to use for the logs. If not set, the default index name is `logs`.
        """
        return pulumi.get(self, "index_name")


@pulumi.output_type
class GetAppSpecFunctionLogDestinationOpenSearchBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
        :param _builtins.str user: Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetAppSpecFunctionLogDestinationPapertrailResult(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetAppSpecFunctionRouteResult(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 preserve_path_prefix: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: Paths must start with `/` and must be unique within the app.
        :param _builtins.bool preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.bool]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")


@pulumi.output_type
class GetAppSpecIngressResult(dict):
    def __init__(__self__, *,
                 rules: Optional[Sequence['outputs.GetAppSpecIngressRuleResult']] = None):
        """
        :param Sequence['GetAppSpecIngressRuleArgs'] rules: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[Sequence['outputs.GetAppSpecIngressRuleResult']]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rules")


@pulumi.output_type
class GetAppSpecIngressRuleResult(dict):
    def __init__(__self__, *,
                 component: 'outputs.GetAppSpecIngressRuleComponentResult',
                 cors: 'outputs.GetAppSpecIngressRuleCorsResult',
                 match: 'outputs.GetAppSpecIngressRuleMatchResult',
                 redirect: Optional['outputs.GetAppSpecIngressRuleRedirectResult'] = None):
        """
        :param 'GetAppSpecIngressRuleCorsArgs' cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        pulumi.set(__self__, "component", component)
        pulumi.set(__self__, "cors", cors)
        pulumi.set(__self__, "match", match)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @_builtins.property
    @pulumi.getter
    def component(self) -> 'outputs.GetAppSpecIngressRuleComponentResult':
        return pulumi.get(self, "component")

    @_builtins.property
    @pulumi.getter
    def cors(self) -> 'outputs.GetAppSpecIngressRuleCorsResult':
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter
    def match(self) -> 'outputs.GetAppSpecIngressRuleMatchResult':
        return pulumi.get(self, "match")

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional['outputs.GetAppSpecIngressRuleRedirectResult']:
        return pulumi.get(self, "redirect")


@pulumi.output_type
class GetAppSpecIngressRuleComponentResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 preserve_path_prefix: _builtins.bool,
                 rewrite: _builtins.str):
        """
        :param _builtins.str name: The name of the component.
        :param _builtins.bool preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)
        pulumi.set(__self__, "rewrite", rewrite)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> _builtins.bool:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @_builtins.property
    @pulumi.getter
    def rewrite(self) -> _builtins.str:
        return pulumi.get(self, "rewrite")


@pulumi.output_type
class GetAppSpecIngressRuleCorsResult(dict):
    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional['outputs.GetAppSpecIngressRuleCorsAllowOriginsResult'] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        :param 'GetAppSpecIngressRuleCorsAllowOriginsArgs' allow_origins: The `Access-Control-Allow-Origin` can be
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional['outputs.GetAppSpecIngressRuleCorsAllowOriginsResult']:
        """
        The `Access-Control-Allow-Origin` can be
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetAppSpecIngressRuleCorsAllowOriginsResult(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        :param _builtins.str prefix: The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        :param _builtins.str regex: The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAppSpecIngressRuleMatchResult(dict):
    def __init__(__self__, *,
                 authority: 'outputs.GetAppSpecIngressRuleMatchAuthorityResult',
                 path: 'outputs.GetAppSpecIngressRuleMatchPathResult'):
        """
        :param 'GetAppSpecIngressRuleMatchPathArgs' path: Paths must start with `/` and must be unique within the app.
        """
        pulumi.set(__self__, "authority", authority)
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> 'outputs.GetAppSpecIngressRuleMatchAuthorityResult':
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def path(self) -> 'outputs.GetAppSpecIngressRuleMatchPathResult':
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class GetAppSpecIngressRuleMatchAuthorityResult(dict):
    def __init__(__self__, *,
                 exact: _builtins.str):
        """
        :param _builtins.str exact: The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        pulumi.set(__self__, "exact", exact)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> _builtins.str:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        return pulumi.get(self, "exact")


@pulumi.output_type
class GetAppSpecIngressRuleMatchPathResult(dict):
    def __init__(__self__, *,
                 prefix: _builtins.str):
        """
        :param _builtins.str prefix: The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> _builtins.str:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        return pulumi.get(self, "prefix")


@pulumi.output_type
class GetAppSpecIngressRuleRedirectResult(dict):
    def __init__(__self__, *,
                 authority: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 redirect_code: Optional[_builtins.int] = None,
                 scheme: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "authority")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "redirect_code")

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scheme")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class GetAppSpecJobResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.GetAppSpecJobAlertResult']] = None,
                 bitbucket: Optional['outputs.GetAppSpecJobBitbucketResult'] = None,
                 build_command: Optional[_builtins.str] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.GetAppSpecJobEnvResult']] = None,
                 git: Optional['outputs.GetAppSpecJobGitResult'] = None,
                 github: Optional['outputs.GetAppSpecJobGithubResult'] = None,
                 gitlab: Optional['outputs.GetAppSpecJobGitlabResult'] = None,
                 image: Optional['outputs.GetAppSpecJobImageResult'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional[_builtins.str] = None,
                 kind: Optional[_builtins.str] = None,
                 log_destinations: Optional[Sequence['outputs.GetAppSpecJobLogDestinationResult']] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None,
                 termination: Optional['outputs.GetAppSpecJobTerminationResult'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param Sequence['GetAppSpecJobAlertArgs'] alerts: Describes an alert policy for the component.
        :param 'GetAppSpecJobBitbucketArgs' bitbucket: A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app.
        :param Sequence['GetAppSpecJobEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'GetAppSpecJobGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        :param 'GetAppSpecJobGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'GetAppSpecJobGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'GetAppSpecJobImageArgs' image: An image to use as the component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to.
        :param _builtins.str instance_size_slug: The instance size to use for this component.
        :param _builtins.str kind: The type of job and when it will be run during the deployment process. It may be one of:
               - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
               - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
               - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
               - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        :param Sequence['GetAppSpecJobLogDestinationArgs'] log_destinations: Describes a log forwarding destination.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        :param 'GetAppSpecJobTerminationArgs' termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.GetAppSpecJobAlertResult']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.GetAppSpecJobBitbucketResult']:
        """
        A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetAppSpecJobEnvResult']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.GetAppSpecJobGitResult']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.GetAppSpecJobGithubResult']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.GetAppSpecJobGitlabResult']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.GetAppSpecJobImageResult']:
        """
        An image to use as the component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[_builtins.str]:
        """
        The instance size to use for this component.
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[_builtins.str]:
        """
        The type of job and when it will be run during the deployment process. It may be one of:
        - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
        - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
        - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
        - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        """
        return pulumi.get(self, "kind")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[Sequence['outputs.GetAppSpecJobLogDestinationResult']]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional['outputs.GetAppSpecJobTerminationResult']:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")


@pulumi.output_type
class GetAppSpecJobAlertResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 rule: _builtins.str,
                 value: _builtins.float,
                 window: _builtins.str,
                 destinations: Optional['outputs.GetAppSpecJobAlertDestinationsResult'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.float value: The threshold for the type of the warning.
        :param _builtins.str window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> _builtins.str:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.GetAppSpecJobAlertDestinationsResult']:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GetAppSpecJobAlertDestinationsResult(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.GetAppSpecJobAlertDestinationsSlackWebhookResult']] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.GetAppSpecJobAlertDestinationsSlackWebhookResult']]:
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class GetAppSpecJobAlertDestinationsSlackWebhookResult(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetAppSpecJobBitbucketResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecJobEnvResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str value: The threshold for the type of the warning.
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppSpecJobGitResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class GetAppSpecJobGithubResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecJobGitlabResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecJobImageResult(dict):
    def __init__(__self__, *,
                 deploy_on_pushes: Sequence['outputs.GetAppSpecJobImageDeployOnPushResult'],
                 registry_type: _builtins.str,
                 repository: _builtins.str,
                 digest: Optional[_builtins.str] = None,
                 registry: Optional[_builtins.str] = None,
                 registry_credentials: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param Sequence['GetAppSpecJobImageDeployOnPushArgs'] deploy_on_pushes: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param _builtins.str repository: The repository name.
        :param _builtins.str digest: The image digest. Cannot be specified if `tag` is provided.
        :param _builtins.str registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param _builtins.str registry_credentials: Access credentials for third-party registries
        :param _builtins.str tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Sequence['outputs.GetAppSpecJobImageDeployOnPushResult']:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> _builtins.str:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> _builtins.str:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[_builtins.str]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[_builtins.str]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[_builtins.str]:
        """
        Access credentials for third-party registries
        """
        return pulumi.get(self, "registry_credentials")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetAppSpecJobImageDeployOnPushResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetAppSpecJobLogDestinationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.GetAppSpecJobLogDestinationDatadogResult'] = None,
                 logtail: Optional['outputs.GetAppSpecJobLogDestinationLogtailResult'] = None,
                 open_search: Optional['outputs.GetAppSpecJobLogDestinationOpenSearchResult'] = None,
                 papertrail: Optional['outputs.GetAppSpecJobLogDestinationPapertrailResult'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param 'GetAppSpecJobLogDestinationDatadogArgs' datadog: Datadog configuration.
        :param 'GetAppSpecJobLogDestinationLogtailArgs' logtail: Logtail configuration.
        :param 'GetAppSpecJobLogDestinationOpenSearchArgs' open_search: OpenSearch configuration.
        :param 'GetAppSpecJobLogDestinationPapertrailArgs' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.GetAppSpecJobLogDestinationDatadogResult']:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.GetAppSpecJobLogDestinationLogtailResult']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.GetAppSpecJobLogDestinationOpenSearchResult']:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.GetAppSpecJobLogDestinationPapertrailResult']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class GetAppSpecJobLogDestinationDatadogResult(dict):
    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetAppSpecJobLogDestinationLogtailResult(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetAppSpecJobLogDestinationOpenSearchResult(dict):
    def __init__(__self__, *,
                 basic_auth: 'outputs.GetAppSpecJobLogDestinationOpenSearchBasicAuthResult',
                 cluster_name: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 index_name: Optional[_builtins.str] = None):
        """
        :param 'GetAppSpecJobLogDestinationOpenSearchBasicAuthArgs' basic_auth: OpenSearch basic auth
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        :param _builtins.str index_name: The index name to use for the logs. If not set, the default index name is `logs`.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.GetAppSpecJobLogDestinationOpenSearchBasicAuthResult':
        """
        OpenSearch basic auth
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        """
        The index name to use for the logs. If not set, the default index name is `logs`.
        """
        return pulumi.get(self, "index_name")


@pulumi.output_type
class GetAppSpecJobLogDestinationOpenSearchBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
        :param _builtins.str user: Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetAppSpecJobLogDestinationPapertrailResult(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetAppSpecJobTerminationResult(dict):
    def __init__(__self__, *,
                 grace_period_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
        """
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
        """
        return pulumi.get(self, "grace_period_seconds")


@pulumi.output_type
class GetAppSpecMaintenanceResult(dict):
    def __init__(__self__, *,
                 archive: Optional[_builtins.bool] = None,
                 enabled: Optional[_builtins.bool] = None,
                 offline_page_url: Optional[_builtins.str] = None):
        """
        :param _builtins.bool archive: Indicates whether the app should be archived. Setting this to true implies that enabled is set to true.
        :param _builtins.bool enabled: Whether to automatically deploy images pushed to DOCR.
        :param _builtins.str offline_page_url: A custom offline page to display when maintenance mode is enabled or the app is archived.
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if offline_page_url is not None:
            pulumi.set(__self__, "offline_page_url", offline_page_url)

    @_builtins.property
    @pulumi.getter
    def archive(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the app should be archived. Setting this to true implies that enabled is set to true.
        """
        return pulumi.get(self, "archive")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="offlinePageUrl")
    def offline_page_url(self) -> Optional[_builtins.str]:
        """
        A custom offline page to display when maintenance mode is enabled or the app is archived.
        """
        return pulumi.get(self, "offline_page_url")


@pulumi.output_type
class GetAppSpecServiceResult(dict):
    def __init__(__self__, *,
                 http_port: _builtins.int,
                 internal_ports: Sequence[_builtins.int],
                 name: _builtins.str,
                 routes: Sequence['outputs.GetAppSpecServiceRouteResult'],
                 run_command: _builtins.str,
                 alerts: Optional[Sequence['outputs.GetAppSpecServiceAlertResult']] = None,
                 autoscaling: Optional['outputs.GetAppSpecServiceAutoscalingResult'] = None,
                 bitbucket: Optional['outputs.GetAppSpecServiceBitbucketResult'] = None,
                 build_command: Optional[_builtins.str] = None,
                 cors: Optional['outputs.GetAppSpecServiceCorsResult'] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.GetAppSpecServiceEnvResult']] = None,
                 git: Optional['outputs.GetAppSpecServiceGitResult'] = None,
                 github: Optional['outputs.GetAppSpecServiceGithubResult'] = None,
                 gitlab: Optional['outputs.GetAppSpecServiceGitlabResult'] = None,
                 health_check: Optional['outputs.GetAppSpecServiceHealthCheckResult'] = None,
                 image: Optional['outputs.GetAppSpecServiceImageResult'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional[_builtins.str] = None,
                 log_destinations: Optional[Sequence['outputs.GetAppSpecServiceLogDestinationResult']] = None,
                 source_dir: Optional[_builtins.str] = None,
                 termination: Optional['outputs.GetAppSpecServiceTerminationResult'] = None):
        """
        :param _builtins.int http_port: The internal port on which this service's run command will listen.
        :param Sequence[_builtins.int] internal_ports: A list of ports on which this service will listen for internal traffic.
        :param _builtins.str name: The name of the component.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param Sequence['GetAppSpecServiceAlertArgs'] alerts: Describes an alert policy for the component.
        :param 'GetAppSpecServiceAutoscalingArgs' autoscaling: Configuration for automatically scaling this component based on metrics.
        :param 'GetAppSpecServiceBitbucketArgs' bitbucket: A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param 'GetAppSpecServiceCorsArgs' cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param _builtins.str dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app.
        :param Sequence['GetAppSpecServiceEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'GetAppSpecServiceGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        :param 'GetAppSpecServiceGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'GetAppSpecServiceGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'GetAppSpecServiceHealthCheckArgs' health_check: A health check to determine the availability of this component.
        :param 'GetAppSpecServiceImageArgs' image: An image to use as the component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to.
        :param _builtins.str instance_size_slug: The instance size to use for this component.
        :param Sequence['GetAppSpecServiceLogDestinationArgs'] log_destinations: Describes a log forwarding destination.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        :param 'GetAppSpecServiceTerminationArgs' termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "http_port", http_port)
        pulumi.set(__self__, "internal_ports", internal_ports)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routes", routes)
        pulumi.set(__self__, "run_command", run_command)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> _builtins.int:
        """
        The internal port on which this service's run command will listen.
        """
        return pulumi.get(self, "http_port")

    @_builtins.property
    @pulumi.getter(name="internalPorts")
    def internal_ports(self) -> Sequence[_builtins.int]:
        """
        A list of ports on which this service will listen for internal traffic.
        """
        return pulumi.get(self, "internal_ports")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Sequence['outputs.GetAppSpecServiceRouteResult']:
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> _builtins.str:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.GetAppSpecServiceAlertResult']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.GetAppSpecServiceAutoscalingResult']:
        """
        Configuration for automatically scaling this component based on metrics.
        """
        return pulumi.get(self, "autoscaling")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.GetAppSpecServiceBitbucketResult']:
        """
        A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional['outputs.GetAppSpecServiceCorsResult']:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetAppSpecServiceEnvResult']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.GetAppSpecServiceGitResult']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.GetAppSpecServiceGithubResult']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.GetAppSpecServiceGitlabResult']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional['outputs.GetAppSpecServiceHealthCheckResult']:
        """
        A health check to determine the availability of this component.
        """
        return pulumi.get(self, "health_check")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.GetAppSpecServiceImageResult']:
        """
        An image to use as the component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[_builtins.str]:
        """
        The instance size to use for this component.
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[Sequence['outputs.GetAppSpecServiceLogDestinationResult']]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional['outputs.GetAppSpecServiceTerminationResult']:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")


@pulumi.output_type
class GetAppSpecServiceAlertResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 rule: _builtins.str,
                 value: _builtins.float,
                 window: _builtins.str,
                 destinations: Optional['outputs.GetAppSpecServiceAlertDestinationsResult'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.float value: The threshold for the type of the warning.
        :param _builtins.str window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> _builtins.str:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.GetAppSpecServiceAlertDestinationsResult']:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GetAppSpecServiceAlertDestinationsResult(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.GetAppSpecServiceAlertDestinationsSlackWebhookResult']] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.GetAppSpecServiceAlertDestinationsSlackWebhookResult']]:
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class GetAppSpecServiceAlertDestinationsSlackWebhookResult(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetAppSpecServiceAutoscalingResult(dict):
    def __init__(__self__, *,
                 max_instance_count: _builtins.int,
                 metrics: 'outputs.GetAppSpecServiceAutoscalingMetricsResult',
                 min_instance_count: _builtins.int):
        """
        :param _builtins.int max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count.
        :param 'GetAppSpecServiceAutoscalingMetricsArgs' metrics: The metrics that the component is scaled on.
        :param _builtins.int min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_instance_count", min_instance_count)

    @_builtins.property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> _builtins.int:
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        return pulumi.get(self, "max_instance_count")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> 'outputs.GetAppSpecServiceAutoscalingMetricsResult':
        """
        The metrics that the component is scaled on.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> _builtins.int:
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class GetAppSpecServiceAutoscalingMetricsResult(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.GetAppSpecServiceAutoscalingMetricsCpuResult'] = None):
        """
        :param 'GetAppSpecServiceAutoscalingMetricsCpuArgs' cpu: Settings for scaling the component based on CPU utilization.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.GetAppSpecServiceAutoscalingMetricsCpuResult']:
        """
        Settings for scaling the component based on CPU utilization.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class GetAppSpecServiceAutoscalingMetricsCpuResult(dict):
    def __init__(__self__, *,
                 percent: _builtins.int):
        """
        :param _builtins.int percent: The average target CPU utilization for the component.
        """
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.int:
        """
        The average target CPU utilization for the component.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetAppSpecServiceBitbucketResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecServiceCorsResult(dict):
    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional['outputs.GetAppSpecServiceCorsAllowOriginsResult'] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        :param 'GetAppSpecServiceCorsAllowOriginsArgs' allow_origins: The `Access-Control-Allow-Origin` can be
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional['outputs.GetAppSpecServiceCorsAllowOriginsResult']:
        """
        The `Access-Control-Allow-Origin` can be
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetAppSpecServiceCorsAllowOriginsResult(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        :param _builtins.str prefix: The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        :param _builtins.str regex: The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAppSpecServiceEnvResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str value: The threshold for the type of the warning.
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppSpecServiceGitResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class GetAppSpecServiceGithubResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecServiceGitlabResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecServiceHealthCheckResult(dict):
    def __init__(__self__, *,
                 failure_threshold: Optional[_builtins.int] = None,
                 http_path: Optional[_builtins.str] = None,
                 initial_delay_seconds: Optional[_builtins.int] = None,
                 period_seconds: Optional[_builtins.int] = None,
                 port: Optional[_builtins.int] = None,
                 success_threshold: Optional[_builtins.int] = None,
                 timeout_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int failure_threshold: The number of failed health checks before considered unhealthy.
        :param _builtins.str http_path: The route path used for the HTTP health check ping.
        :param _builtins.int initial_delay_seconds: The number of seconds to wait before beginning health checks.
        :param _builtins.int period_seconds: The number of seconds to wait between health checks.
        :param _builtins.int port: The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port.
        :param _builtins.int success_threshold: The number of successful health checks before considered healthy.
        :param _builtins.int timeout_seconds: The number of seconds after which the check times out.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[_builtins.int]:
        """
        The number of failed health checks before considered unhealthy.
        """
        return pulumi.get(self, "failure_threshold")

    @_builtins.property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[_builtins.str]:
        """
        The route path used for the HTTP health check ping.
        """
        return pulumi.get(self, "http_path")

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait before beginning health checks.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between health checks.
        """
        return pulumi.get(self, "period_seconds")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        The port on which the health check will be performed. If not set, the health check will be performed on the component's http_port.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[_builtins.int]:
        """
        The number of successful health checks before considered healthy.
        """
        return pulumi.get(self, "success_threshold")

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds after which the check times out.
        """
        return pulumi.get(self, "timeout_seconds")


@pulumi.output_type
class GetAppSpecServiceImageResult(dict):
    def __init__(__self__, *,
                 deploy_on_pushes: Sequence['outputs.GetAppSpecServiceImageDeployOnPushResult'],
                 registry_type: _builtins.str,
                 repository: _builtins.str,
                 digest: Optional[_builtins.str] = None,
                 registry: Optional[_builtins.str] = None,
                 registry_credentials: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param Sequence['GetAppSpecServiceImageDeployOnPushArgs'] deploy_on_pushes: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param _builtins.str repository: The repository name.
        :param _builtins.str digest: The image digest. Cannot be specified if `tag` is provided.
        :param _builtins.str registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param _builtins.str registry_credentials: Access credentials for third-party registries
        :param _builtins.str tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Sequence['outputs.GetAppSpecServiceImageDeployOnPushResult']:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> _builtins.str:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> _builtins.str:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[_builtins.str]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[_builtins.str]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[_builtins.str]:
        """
        Access credentials for third-party registries
        """
        return pulumi.get(self, "registry_credentials")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetAppSpecServiceImageDeployOnPushResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetAppSpecServiceLogDestinationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.GetAppSpecServiceLogDestinationDatadogResult'] = None,
                 logtail: Optional['outputs.GetAppSpecServiceLogDestinationLogtailResult'] = None,
                 open_search: Optional['outputs.GetAppSpecServiceLogDestinationOpenSearchResult'] = None,
                 papertrail: Optional['outputs.GetAppSpecServiceLogDestinationPapertrailResult'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param 'GetAppSpecServiceLogDestinationDatadogArgs' datadog: Datadog configuration.
        :param 'GetAppSpecServiceLogDestinationLogtailArgs' logtail: Logtail configuration.
        :param 'GetAppSpecServiceLogDestinationOpenSearchArgs' open_search: OpenSearch configuration.
        :param 'GetAppSpecServiceLogDestinationPapertrailArgs' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.GetAppSpecServiceLogDestinationDatadogResult']:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.GetAppSpecServiceLogDestinationLogtailResult']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.GetAppSpecServiceLogDestinationOpenSearchResult']:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.GetAppSpecServiceLogDestinationPapertrailResult']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class GetAppSpecServiceLogDestinationDatadogResult(dict):
    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetAppSpecServiceLogDestinationLogtailResult(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetAppSpecServiceLogDestinationOpenSearchResult(dict):
    def __init__(__self__, *,
                 basic_auth: 'outputs.GetAppSpecServiceLogDestinationOpenSearchBasicAuthResult',
                 cluster_name: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 index_name: Optional[_builtins.str] = None):
        """
        :param 'GetAppSpecServiceLogDestinationOpenSearchBasicAuthArgs' basic_auth: OpenSearch basic auth
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        :param _builtins.str index_name: The index name to use for the logs. If not set, the default index name is `logs`.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.GetAppSpecServiceLogDestinationOpenSearchBasicAuthResult':
        """
        OpenSearch basic auth
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        """
        The index name to use for the logs. If not set, the default index name is `logs`.
        """
        return pulumi.get(self, "index_name")


@pulumi.output_type
class GetAppSpecServiceLogDestinationOpenSearchBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
        :param _builtins.str user: Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetAppSpecServiceLogDestinationPapertrailResult(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetAppSpecServiceRouteResult(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 preserve_path_prefix: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: Paths must start with `/` and must be unique within the app.
        :param _builtins.bool preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.bool]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")


@pulumi.output_type
class GetAppSpecServiceTerminationResult(dict):
    def __init__(__self__, *,
                 drain_seconds: Optional[_builtins.int] = None,
                 grace_period_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int drain_seconds: The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110.
        :param _builtins.int grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
        """
        if drain_seconds is not None:
            pulumi.set(__self__, "drain_seconds", drain_seconds)
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="drainSeconds")
    def drain_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110.
        """
        return pulumi.get(self, "drain_seconds")

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
        """
        return pulumi.get(self, "grace_period_seconds")


@pulumi.output_type
class GetAppSpecStaticSiteResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 routes: Sequence['outputs.GetAppSpecStaticSiteRouteResult'],
                 bitbucket: Optional['outputs.GetAppSpecStaticSiteBitbucketResult'] = None,
                 build_command: Optional[_builtins.str] = None,
                 catchall_document: Optional[_builtins.str] = None,
                 cors: Optional['outputs.GetAppSpecStaticSiteCorsResult'] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.GetAppSpecStaticSiteEnvResult']] = None,
                 error_document: Optional[_builtins.str] = None,
                 git: Optional['outputs.GetAppSpecStaticSiteGitResult'] = None,
                 github: Optional['outputs.GetAppSpecStaticSiteGithubResult'] = None,
                 gitlab: Optional['outputs.GetAppSpecStaticSiteGitlabResult'] = None,
                 index_document: Optional[_builtins.str] = None,
                 output_dir: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: The name of the component.
        :param 'GetAppSpecStaticSiteBitbucketArgs' bitbucket: A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str catchall_document: The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        :param 'GetAppSpecStaticSiteCorsArgs' cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param _builtins.str dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app.
        :param Sequence['GetAppSpecStaticSiteEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param _builtins.str error_document: The name of the error document to use when serving this static site.
        :param 'GetAppSpecStaticSiteGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        :param 'GetAppSpecStaticSiteGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'GetAppSpecStaticSiteGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param _builtins.str index_document: The name of the index document to use when serving this static site.
        :param _builtins.str output_dir: An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "routes", routes)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if catchall_document is not None:
            pulumi.set(__self__, "catchall_document", catchall_document)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if output_dir is not None:
            pulumi.set(__self__, "output_dir", output_dir)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Sequence['outputs.GetAppSpecStaticSiteRouteResult']:
        return pulumi.get(self, "routes")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.GetAppSpecStaticSiteBitbucketResult']:
        """
        A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="catchallDocument")
    def catchall_document(self) -> Optional[_builtins.str]:
        """
        The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        """
        return pulumi.get(self, "catchall_document")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional['outputs.GetAppSpecStaticSiteCorsResult']:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetAppSpecStaticSiteEnvResult']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[_builtins.str]:
        """
        The name of the error document to use when serving this static site.
        """
        return pulumi.get(self, "error_document")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.GetAppSpecStaticSiteGitResult']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.GetAppSpecStaticSiteGithubResult']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.GetAppSpecStaticSiteGitlabResult']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[_builtins.str]:
        """
        The name of the index document to use when serving this static site.
        """
        return pulumi.get(self, "index_document")

    @_builtins.property
    @pulumi.getter(name="outputDir")
    def output_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        """
        return pulumi.get(self, "output_dir")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")


@pulumi.output_type
class GetAppSpecStaticSiteBitbucketResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecStaticSiteCorsResult(dict):
    def __init__(__self__, *,
                 allow_credentials: Optional[_builtins.bool] = None,
                 allow_headers: Optional[Sequence[_builtins.str]] = None,
                 allow_methods: Optional[Sequence[_builtins.str]] = None,
                 allow_origins: Optional['outputs.GetAppSpecStaticSiteCorsAllowOriginsResult'] = None,
                 expose_headers: Optional[Sequence[_builtins.str]] = None,
                 max_age: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        :param Sequence[_builtins.str] allow_headers: The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        :param Sequence[_builtins.str] allow_methods: The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        :param 'GetAppSpecStaticSiteCorsAllowOriginsArgs' allow_origins: The `Access-Control-Allow-Origin` can be
        :param Sequence[_builtins.str] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        :param _builtins.str max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[_builtins.bool]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        return pulumi.get(self, "allow_credentials")

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "allow_headers")

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        return pulumi.get(self, "allow_methods")

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional['outputs.GetAppSpecStaticSiteCorsAllowOriginsResult']:
        """
        The `Access-Control-Allow-Origin` can be
        """
        return pulumi.get(self, "allow_origins")

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[Sequence[_builtins.str]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        return pulumi.get(self, "expose_headers")

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[_builtins.str]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")


@pulumi.output_type
class GetAppSpecStaticSiteCorsAllowOriginsResult(dict):
    def __init__(__self__, *,
                 exact: Optional[_builtins.str] = None,
                 prefix: Optional[_builtins.str] = None,
                 regex: Optional[_builtins.str] = None):
        """
        :param _builtins.str exact: The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        :param _builtins.str prefix: The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        :param _builtins.str regex: The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        return pulumi.get(self, "exact")

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        return pulumi.get(self, "prefix")

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[_builtins.str]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")


@pulumi.output_type
class GetAppSpecStaticSiteEnvResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str value: The threshold for the type of the warning.
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppSpecStaticSiteGitResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class GetAppSpecStaticSiteGithubResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecStaticSiteGitlabResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecStaticSiteRouteResult(dict):
    def __init__(__self__, *,
                 path: Optional[_builtins.str] = None,
                 preserve_path_prefix: Optional[_builtins.bool] = None):
        """
        :param _builtins.str path: Paths must start with `/` and must be unique within the app.
        :param _builtins.bool preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[_builtins.bool]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")


@pulumi.output_type
class GetAppSpecVpcResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str):
        """
        :param _builtins.str id: The ID of the dedicated egress IP.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the dedicated egress IP.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetAppSpecWorkerResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 alerts: Optional[Sequence['outputs.GetAppSpecWorkerAlertResult']] = None,
                 autoscaling: Optional['outputs.GetAppSpecWorkerAutoscalingResult'] = None,
                 bitbucket: Optional['outputs.GetAppSpecWorkerBitbucketResult'] = None,
                 build_command: Optional[_builtins.str] = None,
                 dockerfile_path: Optional[_builtins.str] = None,
                 environment_slug: Optional[_builtins.str] = None,
                 envs: Optional[Sequence['outputs.GetAppSpecWorkerEnvResult']] = None,
                 git: Optional['outputs.GetAppSpecWorkerGitResult'] = None,
                 github: Optional['outputs.GetAppSpecWorkerGithubResult'] = None,
                 gitlab: Optional['outputs.GetAppSpecWorkerGitlabResult'] = None,
                 image: Optional['outputs.GetAppSpecWorkerImageResult'] = None,
                 instance_count: Optional[_builtins.int] = None,
                 instance_size_slug: Optional[_builtins.str] = None,
                 log_destinations: Optional[Sequence['outputs.GetAppSpecWorkerLogDestinationResult']] = None,
                 run_command: Optional[_builtins.str] = None,
                 source_dir: Optional[_builtins.str] = None,
                 termination: Optional['outputs.GetAppSpecWorkerTerminationResult'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param Sequence['GetAppSpecWorkerAlertArgs'] alerts: Describes an alert policy for the component.
        :param 'GetAppSpecWorkerAutoscalingArgs' autoscaling: Configuration for automatically scaling this component based on metrics.
        :param 'GetAppSpecWorkerBitbucketArgs' bitbucket: A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        :param _builtins.str build_command: An optional build command to run while building this component from source.
        :param _builtins.str dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param _builtins.str environment_slug: An environment slug describing the type of this app.
        :param Sequence['GetAppSpecWorkerEnvArgs'] envs: Describes an environment variable made available to an app competent.
        :param 'GetAppSpecWorkerGitArgs' git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        :param 'GetAppSpecWorkerGithubArgs' github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'GetAppSpecWorkerGitlabArgs' gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param 'GetAppSpecWorkerImageArgs' image: An image to use as the component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param _builtins.int instance_count: The amount of instances that this component should be scaled to.
        :param _builtins.str instance_size_slug: The instance size to use for this component.
        :param Sequence['GetAppSpecWorkerLogDestinationArgs'] log_destinations: Describes a log forwarding destination.
        :param _builtins.str run_command: An optional run command to override the component's default.
        :param _builtins.str source_dir: An optional path to the working directory to use for the build.
        :param 'GetAppSpecWorkerTerminationArgs' termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[Sequence['outputs.GetAppSpecWorkerAlertResult']]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional['outputs.GetAppSpecWorkerAutoscalingResult']:
        """
        Configuration for automatically scaling this component based on metrics.
        """
        return pulumi.get(self, "autoscaling")

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional['outputs.GetAppSpecWorkerBitbucketResult']:
        """
        A Bitbucket repo to use as component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set. To read your repo, App Platform must be authorized to access your Bitbucket account. Go to this URL to link App Platform to your Bitbucket account: `https://cloud.digitalocean.com/apps/bitbucket/install`.
        """
        return pulumi.get(self, "bitbucket")

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[_builtins.str]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[_builtins.str]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[_builtins.str]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[Sequence['outputs.GetAppSpecWorkerEnvResult']]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional['outputs.GetAppSpecWorkerGitResult']:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication.  Only one of `git`, `github` or `gitlab`  may be set.
        """
        return pulumi.get(self, "git")

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional['outputs.GetAppSpecWorkerGithubResult']:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional['outputs.GetAppSpecWorkerGitlabResult']:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.GetAppSpecWorkerImageResult']:
        """
        An image to use as the component's source. Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[_builtins.int]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[_builtins.str]:
        """
        The instance size to use for this component.
        """
        return pulumi.get(self, "instance_size_slug")

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[Sequence['outputs.GetAppSpecWorkerLogDestinationResult']]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[_builtins.str]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[_builtins.str]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional['outputs.GetAppSpecWorkerTerminationResult']:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")


@pulumi.output_type
class GetAppSpecWorkerAlertResult(dict):
    def __init__(__self__, *,
                 operator: _builtins.str,
                 rule: _builtins.str,
                 value: _builtins.float,
                 window: _builtins.str,
                 destinations: Optional['outputs.GetAppSpecWorkerAlertDestinationsResult'] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param _builtins.str rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param _builtins.float value: The threshold for the type of the warning.
        :param _builtins.str window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param _builtins.bool disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> _builtins.str:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @_builtins.property
    @pulumi.getter
    def rule(self) -> _builtins.str:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.float:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def window(self) -> _builtins.str:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional['outputs.GetAppSpecWorkerAlertDestinationsResult']:
        return pulumi.get(self, "destinations")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GetAppSpecWorkerAlertDestinationsResult(dict):
    def __init__(__self__, *,
                 emails: Optional[Sequence[_builtins.str]] = None,
                 slack_webhooks: Optional[Sequence['outputs.GetAppSpecWorkerAlertDestinationsSlackWebhookResult']] = None):
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "emails")

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[Sequence['outputs.GetAppSpecWorkerAlertDestinationsSlackWebhookResult']]:
        return pulumi.get(self, "slack_webhooks")


@pulumi.output_type
class GetAppSpecWorkerAlertDestinationsSlackWebhookResult(dict):
    def __init__(__self__, *,
                 channel: _builtins.str,
                 url: _builtins.str):
        """
        :param _builtins.str channel: The Slack channel to send notifications to.
        :param _builtins.str url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> _builtins.str:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class GetAppSpecWorkerAutoscalingResult(dict):
    def __init__(__self__, *,
                 max_instance_count: _builtins.int,
                 metrics: 'outputs.GetAppSpecWorkerAutoscalingMetricsResult',
                 min_instance_count: _builtins.int):
        """
        :param _builtins.int max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count.
        :param 'GetAppSpecWorkerAutoscalingMetricsArgs' metrics: The metrics that the component is scaled on.
        :param _builtins.int min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_instance_count", min_instance_count)

    @_builtins.property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> _builtins.int:
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        return pulumi.get(self, "max_instance_count")

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> 'outputs.GetAppSpecWorkerAutoscalingMetricsResult':
        """
        The metrics that the component is scaled on.
        """
        return pulumi.get(self, "metrics")

    @_builtins.property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> _builtins.int:
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        return pulumi.get(self, "min_instance_count")


@pulumi.output_type
class GetAppSpecWorkerAutoscalingMetricsResult(dict):
    def __init__(__self__, *,
                 cpu: Optional['outputs.GetAppSpecWorkerAutoscalingMetricsCpuResult'] = None):
        """
        :param 'GetAppSpecWorkerAutoscalingMetricsCpuArgs' cpu: Settings for scaling the component based on CPU utilization.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional['outputs.GetAppSpecWorkerAutoscalingMetricsCpuResult']:
        """
        Settings for scaling the component based on CPU utilization.
        """
        return pulumi.get(self, "cpu")


@pulumi.output_type
class GetAppSpecWorkerAutoscalingMetricsCpuResult(dict):
    def __init__(__self__, *,
                 percent: _builtins.int):
        """
        :param _builtins.int percent: The average target CPU utilization for the component.
        """
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> _builtins.int:
        """
        The average target CPU utilization for the component.
        """
        return pulumi.get(self, "percent")


@pulumi.output_type
class GetAppSpecWorkerBitbucketResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecWorkerEnvResult(dict):
    def __init__(__self__, *,
                 type: _builtins.str,
                 key: Optional[_builtins.str] = None,
                 scope: Optional[_builtins.str] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.str type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param _builtins.str key: The name of the environment variable.
        :param _builtins.str scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param _builtins.str value: The threshold for the type of the warning.
        """
        pulumi.set(__self__, "type", type)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[_builtins.str]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[_builtins.str]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetAppSpecWorkerGitResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 repo_clone_url: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.str repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[_builtins.str]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")


@pulumi.output_type
class GetAppSpecWorkerGithubResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecWorkerGitlabResult(dict):
    def __init__(__self__, *,
                 branch: Optional[_builtins.str] = None,
                 deploy_on_push: Optional[_builtins.bool] = None,
                 repo: Optional[_builtins.str] = None):
        """
        :param _builtins.str branch: The name of the branch to use.
        :param _builtins.bool deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[_builtins.str]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[_builtins.str]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")


@pulumi.output_type
class GetAppSpecWorkerImageResult(dict):
    def __init__(__self__, *,
                 deploy_on_pushes: Sequence['outputs.GetAppSpecWorkerImageDeployOnPushResult'],
                 registry_type: _builtins.str,
                 repository: _builtins.str,
                 digest: Optional[_builtins.str] = None,
                 registry: Optional[_builtins.str] = None,
                 registry_credentials: Optional[_builtins.str] = None,
                 tag: Optional[_builtins.str] = None):
        """
        :param Sequence['GetAppSpecWorkerImageDeployOnPushArgs'] deploy_on_pushes: Whether to automatically deploy new commits made to the repo.
        :param _builtins.str registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param _builtins.str repository: The repository name.
        :param _builtins.str digest: The image digest. Cannot be specified if `tag` is provided.
        :param _builtins.str registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param _builtins.str registry_credentials: Access credentials for third-party registries
        :param _builtins.str tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Sequence['outputs.GetAppSpecWorkerImageDeployOnPushResult']:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> _builtins.str:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @_builtins.property
    @pulumi.getter
    def repository(self) -> _builtins.str:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[_builtins.str]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[_builtins.str]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[_builtins.str]:
        """
        Access credentials for third-party registries
        """
        return pulumi.get(self, "registry_credentials")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[_builtins.str]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class GetAppSpecWorkerImageDeployOnPushResult(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetAppSpecWorkerLogDestinationResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 datadog: Optional['outputs.GetAppSpecWorkerLogDestinationDatadogResult'] = None,
                 logtail: Optional['outputs.GetAppSpecWorkerLogDestinationLogtailResult'] = None,
                 open_search: Optional['outputs.GetAppSpecWorkerLogDestinationOpenSearchResult'] = None,
                 papertrail: Optional['outputs.GetAppSpecWorkerLogDestinationPapertrailResult'] = None):
        """
        :param _builtins.str name: The name of the component.
        :param 'GetAppSpecWorkerLogDestinationDatadogArgs' datadog: Datadog configuration.
        :param 'GetAppSpecWorkerLogDestinationLogtailArgs' logtail: Logtail configuration.
        :param 'GetAppSpecWorkerLogDestinationOpenSearchArgs' open_search: OpenSearch configuration.
        :param 'GetAppSpecWorkerLogDestinationPapertrailArgs' papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional['outputs.GetAppSpecWorkerLogDestinationDatadogResult']:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional['outputs.GetAppSpecWorkerLogDestinationLogtailResult']:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional['outputs.GetAppSpecWorkerLogDestinationOpenSearchResult']:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional['outputs.GetAppSpecWorkerLogDestinationPapertrailResult']:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")


@pulumi.output_type
class GetAppSpecWorkerLogDestinationDatadogResult(dict):
    def __init__(__self__, *,
                 api_key: _builtins.str,
                 endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: Datadog API key.
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> _builtins.str:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetAppSpecWorkerLogDestinationLogtailResult(dict):
    def __init__(__self__, *,
                 token: _builtins.str):
        """
        :param _builtins.str token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetAppSpecWorkerLogDestinationOpenSearchResult(dict):
    def __init__(__self__, *,
                 basic_auth: 'outputs.GetAppSpecWorkerLogDestinationOpenSearchBasicAuthResult',
                 cluster_name: Optional[_builtins.str] = None,
                 endpoint: Optional[_builtins.str] = None,
                 index_name: Optional[_builtins.str] = None):
        """
        :param 'GetAppSpecWorkerLogDestinationOpenSearchBasicAuthArgs' basic_auth: OpenSearch basic auth
        :param _builtins.str cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        :param _builtins.str index_name: The index name to use for the logs. If not set, the default index name is `logs`.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> 'outputs.GetAppSpecWorkerLogDestinationOpenSearchBasicAuthResult':
        """
        OpenSearch basic auth
        """
        return pulumi.get(self, "basic_auth")

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[_builtins.str]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[_builtins.str]:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[_builtins.str]:
        """
        The index name to use for the logs. If not set, the default index name is `logs`.
        """
        return pulumi.get(self, "index_name")


@pulumi.output_type
class GetAppSpecWorkerLogDestinationOpenSearchBasicAuthResult(dict):
    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 user: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
        :param _builtins.str user: Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for user defined in User. Is required when endpoint is set. Cannot be set if using a DigitalOcean DBaaS OpenSearch cluster.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[_builtins.str]:
        """
        Username to authenticate with. Only required when endpoint is set. Defaults to doadmin when cluster_name is set.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class GetAppSpecWorkerLogDestinationPapertrailResult(dict):
    def __init__(__self__, *,
                 endpoint: _builtins.str):
        """
        :param _builtins.str endpoint: OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        OpenSearch API Endpoint. Only HTTPS is supported. Format: https://<host>:<port>.
        """
        return pulumi.get(self, "endpoint")


@pulumi.output_type
class GetAppSpecWorkerTerminationResult(dict):
    def __init__(__self__, *,
                 grace_period_seconds: Optional[_builtins.int] = None):
        """
        :param _builtins.int grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
        """
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[_builtins.int]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
        """
        return pulumi.get(self, "grace_period_seconds")


@pulumi.output_type
class GetDatabaseClusterMaintenanceWindowResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 hour: _builtins.str):
        """
        :param _builtins.str day: The day of the week on which to apply maintenance updates.
        :param _builtins.str hour: The hour in UTC at which maintenance updates will be applied in 24 hour format.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        The day of the week on which to apply maintenance updates.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def hour(self) -> _builtins.str:
        """
        The hour in UTC at which maintenance updates will be applied in 24 hour format.
        """
        return pulumi.get(self, "hour")


@pulumi.output_type
class GetDatabaseUserSettingResult(dict):
    def __init__(__self__, *,
                 acls: Optional[Sequence['outputs.GetDatabaseUserSettingAclResult']] = None,
                 opensearch_acls: Optional[Sequence['outputs.GetDatabaseUserSettingOpensearchAclResult']] = None):
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if opensearch_acls is not None:
            pulumi.set(__self__, "opensearch_acls", opensearch_acls)

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Optional[Sequence['outputs.GetDatabaseUserSettingAclResult']]:
        return pulumi.get(self, "acls")

    @_builtins.property
    @pulumi.getter(name="opensearchAcls")
    def opensearch_acls(self) -> Optional[Sequence['outputs.GetDatabaseUserSettingOpensearchAclResult']]:
        return pulumi.get(self, "opensearch_acls")


@pulumi.output_type
class GetDatabaseUserSettingAclResult(dict):
    def __init__(__self__, *,
                 id: _builtins.str,
                 permission: _builtins.str,
                 topic: _builtins.str):
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        return pulumi.get(self, "permission")

    @_builtins.property
    @pulumi.getter
    def topic(self) -> _builtins.str:
        return pulumi.get(self, "topic")


@pulumi.output_type
class GetDatabaseUserSettingOpensearchAclResult(dict):
    def __init__(__self__, *,
                 index: _builtins.str,
                 permission: _builtins.str):
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def index(self) -> _builtins.str:
        return pulumi.get(self, "index")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetDomainsDomainResult(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 ttl: _builtins.int,
                 urn: _builtins.str):
        """
        :param _builtins.str name: (Required) The name of the domain.
        :param _builtins.int ttl: The TTL of the domain.
        :param _builtins.str urn: The uniform resource name of the domain
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        (Required) The name of the domain.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        The TTL of the domain.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> _builtins.str:
        """
        The uniform resource name of the domain
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class GetDomainsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves domains
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves domains
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetDomainsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetDropletAutoscaleConfigResult(dict):
    def __init__(__self__, *,
                 cooldown_minutes: _builtins.int,
                 max_instances: _builtins.int,
                 min_instances: _builtins.int,
                 target_cpu_utilization: _builtins.float,
                 target_memory_utilization: _builtins.float,
                 target_number_instances: _builtins.int):
        """
        :param _builtins.int cooldown_minutes: Cooldown duration
        :param _builtins.int max_instances: Max number of members
        :param _builtins.int min_instances: Min number of members
        :param _builtins.float target_cpu_utilization: CPU target threshold
        :param _builtins.float target_memory_utilization: Memory target threshold
        :param _builtins.int target_number_instances: Target number of members
        """
        pulumi.set(__self__, "cooldown_minutes", cooldown_minutes)
        pulumi.set(__self__, "max_instances", max_instances)
        pulumi.set(__self__, "min_instances", min_instances)
        pulumi.set(__self__, "target_cpu_utilization", target_cpu_utilization)
        pulumi.set(__self__, "target_memory_utilization", target_memory_utilization)
        pulumi.set(__self__, "target_number_instances", target_number_instances)

    @_builtins.property
    @pulumi.getter(name="cooldownMinutes")
    def cooldown_minutes(self) -> _builtins.int:
        """
        Cooldown duration
        """
        return pulumi.get(self, "cooldown_minutes")

    @_builtins.property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> _builtins.int:
        """
        Max number of members
        """
        return pulumi.get(self, "max_instances")

    @_builtins.property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> _builtins.int:
        """
        Min number of members
        """
        return pulumi.get(self, "min_instances")

    @_builtins.property
    @pulumi.getter(name="targetCpuUtilization")
    def target_cpu_utilization(self) -> _builtins.float:
        """
        CPU target threshold
        """
        return pulumi.get(self, "target_cpu_utilization")

    @_builtins.property
    @pulumi.getter(name="targetMemoryUtilization")
    def target_memory_utilization(self) -> _builtins.float:
        """
        Memory target threshold
        """
        return pulumi.get(self, "target_memory_utilization")

    @_builtins.property
    @pulumi.getter(name="targetNumberInstances")
    def target_number_instances(self) -> _builtins.int:
        """
        Target number of members
        """
        return pulumi.get(self, "target_number_instances")


@pulumi.output_type
class GetDropletAutoscaleCurrentUtilizationResult(dict):
    def __init__(__self__, *,
                 cpu: _builtins.float,
                 memory: _builtins.float):
        """
        :param _builtins.float cpu: Average CPU utilization
        :param _builtins.float memory: Average Memory utilization
        """
        pulumi.set(__self__, "cpu", cpu)
        pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> _builtins.float:
        """
        Average CPU utilization
        """
        return pulumi.get(self, "cpu")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.float:
        """
        Average Memory utilization
        """
        return pulumi.get(self, "memory")


@pulumi.output_type
class GetDropletAutoscaleDropletTemplateResult(dict):
    def __init__(__self__, *,
                 image: _builtins.str,
                 ipv6: _builtins.bool,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 size: _builtins.str,
                 ssh_keys: Sequence[_builtins.str],
                 tags: Sequence[_builtins.str],
                 user_data: _builtins.str,
                 vpc_uuid: _builtins.str,
                 with_droplet_agent: _builtins.bool):
        """
        :param _builtins.str image: Droplet image
        :param _builtins.bool ipv6: Enable droplet IPv6
        :param _builtins.str project_id: Droplet project ID
        :param _builtins.str region: Droplet region
        :param _builtins.str size: Droplet size
        :param Sequence[_builtins.str] ssh_keys: Droplet SSH keys
        :param Sequence[_builtins.str] tags: Droplet tags
        :param _builtins.str user_data: Droplet user data
        :param _builtins.str vpc_uuid: Droplet VPC UUID
        :param _builtins.bool with_droplet_agent: Enable droplet agent
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "user_data", user_data)
        pulumi.set(__self__, "vpc_uuid", vpc_uuid)
        pulumi.set(__self__, "with_droplet_agent", with_droplet_agent)

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        Droplet image
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        """
        Enable droplet IPv6
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Droplet project ID
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Droplet region
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        Droplet size
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> Sequence[_builtins.str]:
        """
        Droplet SSH keys
        """
        return pulumi.get(self, "ssh_keys")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        Droplet tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> _builtins.str:
        """
        Droplet user data
        """
        return pulumi.get(self, "user_data")

    @_builtins.property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> _builtins.str:
        """
        Droplet VPC UUID
        """
        return pulumi.get(self, "vpc_uuid")

    @_builtins.property
    @pulumi.getter(name="withDropletAgent")
    def with_droplet_agent(self) -> _builtins.bool:
        """
        Enable droplet agent
        """
        return pulumi.get(self, "with_droplet_agent")


@pulumi.output_type
class GetDropletsDropletResult(dict):
    def __init__(__self__, *,
                 backups: _builtins.bool,
                 created_at: _builtins.str,
                 disk: _builtins.int,
                 id: _builtins.int,
                 image: _builtins.str,
                 ipv4_address: _builtins.str,
                 ipv4_address_private: _builtins.str,
                 ipv6: _builtins.bool,
                 ipv6_address: _builtins.str,
                 ipv6_address_private: _builtins.str,
                 locked: _builtins.bool,
                 memory: _builtins.int,
                 monitoring: _builtins.bool,
                 name: _builtins.str,
                 price_hourly: _builtins.float,
                 price_monthly: _builtins.float,
                 private_networking: _builtins.bool,
                 region: _builtins.str,
                 size: _builtins.str,
                 status: _builtins.str,
                 tags: Sequence[_builtins.str],
                 urn: _builtins.str,
                 vcpus: _builtins.int,
                 volume_ids: Sequence[_builtins.str],
                 vpc_uuid: _builtins.str):
        """
        :param _builtins.bool backups: Whether backups are enabled.
        :param _builtins.str created_at: the creation date for the Droplet
        :param _builtins.int disk: The size of the Droplet's disk in GB.
        :param _builtins.int id: The ID of the Droplet.
        :param _builtins.str image: The Droplet image ID or slug.
        :param _builtins.str ipv4_address: The Droplet's public IPv4 address
        :param _builtins.str ipv4_address_private: The Droplet's private IPv4 address
        :param _builtins.bool ipv6: Whether IPv6 is enabled.
        :param _builtins.str ipv6_address: The Droplet's public IPv6 address
        :param _builtins.str ipv6_address_private: The Droplet's private IPv6 address
        :param _builtins.bool locked: Whether the Droplet is locked.
        :param _builtins.int memory: The amount of the Droplet's memory in MB.
        :param _builtins.bool monitoring: Whether monitoring agent is installed.
        :param _builtins.str name: name of the Droplet
        :param _builtins.float price_hourly: Droplet hourly price.
        :param _builtins.float price_monthly: Droplet monthly price.
        :param _builtins.bool private_networking: Whether private networks are enabled.
        :param _builtins.str region: The region the Droplet is running in.
        :param _builtins.str size: The unique slug that identifies the type of Droplet.
        :param _builtins.str status: The status of the Droplet.
        :param Sequence[_builtins.str] tags: A list of the tags associated to the Droplet.
        :param _builtins.str urn: The uniform resource name of the Droplet
        :param _builtins.int vcpus: The number of the Droplet's virtual CPUs.
        :param Sequence[_builtins.str] volume_ids: List of the IDs of each volumes attached to the Droplet.
        :param _builtins.str vpc_uuid: The ID of the VPC where the Droplet is located.
        """
        pulumi.set(__self__, "backups", backups)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "ipv4_address", ipv4_address)
        pulumi.set(__self__, "ipv4_address_private", ipv4_address_private)
        pulumi.set(__self__, "ipv6", ipv6)
        pulumi.set(__self__, "ipv6_address", ipv6_address)
        pulumi.set(__self__, "ipv6_address_private", ipv6_address_private)
        pulumi.set(__self__, "locked", locked)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "monitoring", monitoring)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "price_hourly", price_hourly)
        pulumi.set(__self__, "price_monthly", price_monthly)
        pulumi.set(__self__, "private_networking", private_networking)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "urn", urn)
        pulumi.set(__self__, "vcpus", vcpus)
        pulumi.set(__self__, "volume_ids", volume_ids)
        pulumi.set(__self__, "vpc_uuid", vpc_uuid)

    @_builtins.property
    @pulumi.getter
    def backups(self) -> _builtins.bool:
        """
        Whether backups are enabled.
        """
        return pulumi.get(self, "backups")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        the creation date for the Droplet
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.int:
        """
        The size of the Droplet's disk in GB.
        """
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the Droplet.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        The Droplet image ID or slug.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="ipv4Address")
    def ipv4_address(self) -> _builtins.str:
        """
        The Droplet's public IPv4 address
        """
        return pulumi.get(self, "ipv4_address")

    @_builtins.property
    @pulumi.getter(name="ipv4AddressPrivate")
    def ipv4_address_private(self) -> _builtins.str:
        """
        The Droplet's private IPv4 address
        """
        return pulumi.get(self, "ipv4_address_private")

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> _builtins.bool:
        """
        Whether IPv6 is enabled.
        """
        return pulumi.get(self, "ipv6")

    @_builtins.property
    @pulumi.getter(name="ipv6Address")
    def ipv6_address(self) -> _builtins.str:
        """
        The Droplet's public IPv6 address
        """
        return pulumi.get(self, "ipv6_address")

    @_builtins.property
    @pulumi.getter(name="ipv6AddressPrivate")
    def ipv6_address_private(self) -> _builtins.str:
        """
        The Droplet's private IPv6 address
        """
        return pulumi.get(self, "ipv6_address_private")

    @_builtins.property
    @pulumi.getter
    def locked(self) -> _builtins.bool:
        """
        Whether the Droplet is locked.
        """
        return pulumi.get(self, "locked")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        """
        The amount of the Droplet's memory in MB.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter
    def monitoring(self) -> _builtins.bool:
        """
        Whether monitoring agent is installed.
        """
        return pulumi.get(self, "monitoring")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        name of the Droplet
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="priceHourly")
    def price_hourly(self) -> _builtins.float:
        """
        Droplet hourly price.
        """
        return pulumi.get(self, "price_hourly")

    @_builtins.property
    @pulumi.getter(name="priceMonthly")
    def price_monthly(self) -> _builtins.float:
        """
        Droplet monthly price.
        """
        return pulumi.get(self, "price_monthly")

    @_builtins.property
    @pulumi.getter(name="privateNetworking")
    def private_networking(self) -> _builtins.bool:
        """
        Whether private networks are enabled.
        """
        return pulumi.get(self, "private_networking")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The region the Droplet is running in.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        The unique slug that identifies the type of Droplet.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the Droplet.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        A list of the tags associated to the Droplet.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> _builtins.str:
        """
        The uniform resource name of the Droplet
        """
        return pulumi.get(self, "urn")

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> _builtins.int:
        """
        The number of the Droplet's virtual CPUs.
        """
        return pulumi.get(self, "vcpus")

    @_builtins.property
    @pulumi.getter(name="volumeIds")
    def volume_ids(self) -> Sequence[_builtins.str]:
        """
        List of the IDs of each volumes attached to the Droplet.
        """
        return pulumi.get(self, "volume_ids")

    @_builtins.property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> _builtins.str:
        """
        The ID of the VPC where the Droplet is located.
        """
        return pulumi.get(self, "vpc_uuid")


@pulumi.output_type
class GetDropletsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
               `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
               `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
               `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves Droplets
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves Droplets
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetDropletsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
               `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
               `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
               `status`, `urn`, `vcpus`, or `vpc_uuid`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `urn`, `vcpus`, or `vpc_uuid`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetFirewallInboundRuleResult(dict):
    def __init__(__self__, *,
                 protocol: _builtins.str,
                 port_range: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_droplet_ids: Optional[Sequence[_builtins.int]] = None,
                 source_kubernetes_ids: Optional[Sequence[_builtins.str]] = None,
                 source_load_balancer_uids: Optional[Sequence[_builtins.str]] = None,
                 source_tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param _builtins.str port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        :param Sequence[_builtins.str] source_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
               inbound traffic will be accepted.
        :param Sequence[_builtins.int] source_droplet_ids: An array containing the IDs of
               the Droplets from which the inbound traffic will be accepted.
        :param Sequence[_builtins.str] source_load_balancer_uids: An array containing the IDs
               of the Load Balancers from which the inbound traffic will be accepted.
        :param Sequence[_builtins.str] source_tags: A set of names of Tags corresponding to group of
               Droplets from which the inbound traffic will be accepted.
        """
        pulumi.set(__self__, "protocol", protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_droplet_ids is not None:
            pulumi.set(__self__, "source_droplet_ids", source_droplet_ids)
        if source_kubernetes_ids is not None:
            pulumi.set(__self__, "source_kubernetes_ids", source_kubernetes_ids)
        if source_load_balancer_uids is not None:
            pulumi.set(__self__, "source_load_balancer_uids", source_load_balancer_uids)
        if source_tags is not None:
            pulumi.set(__self__, "source_tags", source_tags)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_addresses")

    @_builtins.property
    @pulumi.getter(name="sourceDropletIds")
    def source_droplet_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_droplet_ids")

    @_builtins.property
    @pulumi.getter(name="sourceKubernetesIds")
    def source_kubernetes_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_kubernetes_ids")

    @_builtins.property
    @pulumi.getter(name="sourceLoadBalancerUids")
    def source_load_balancer_uids(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_load_balancer_uids")

    @_builtins.property
    @pulumi.getter(name="sourceTags")
    def source_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        A set of names of Tags corresponding to group of
        Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_tags")


@pulumi.output_type
class GetFirewallOutboundRuleResult(dict):
    def __init__(__self__, *,
                 protocol: _builtins.str,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_droplet_ids: Optional[Sequence[_builtins.int]] = None,
                 destination_kubernetes_ids: Optional[Sequence[_builtins.str]] = None,
                 destination_load_balancer_uids: Optional[Sequence[_builtins.str]] = None,
                 destination_tags: Optional[Sequence[_builtins.str]] = None,
                 port_range: Optional[_builtins.str] = None):
        """
        :param _builtins.str protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param Sequence[_builtins.str] destination_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
               outbound traffic will be allowed.
        :param Sequence[_builtins.int] destination_droplet_ids: An array containing the IDs of
               the Droplets to which the outbound traffic will be allowed.
        :param Sequence[_builtins.str] destination_load_balancer_uids: An array containing the IDs
               of the Load Balancers to which the outbound traffic will be allowed.
        :param Sequence[_builtins.str] destination_tags: An array containing the names of Tags
               corresponding to groups of Droplets to which the outbound traffic will
               be allowed.
               traffic.
        :param _builtins.str port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        """
        pulumi.set(__self__, "protocol", protocol)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_droplet_ids is not None:
            pulumi.set(__self__, "destination_droplet_ids", destination_droplet_ids)
        if destination_kubernetes_ids is not None:
            pulumi.set(__self__, "destination_kubernetes_ids", destination_kubernetes_ids)
        if destination_load_balancer_uids is not None:
            pulumi.set(__self__, "destination_load_balancer_uids", destination_load_balancer_uids)
        if destination_tags is not None:
            pulumi.set(__self__, "destination_tags", destination_tags)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_addresses")

    @_builtins.property
    @pulumi.getter(name="destinationDropletIds")
    def destination_droplet_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_droplet_ids")

    @_builtins.property
    @pulumi.getter(name="destinationKubernetesIds")
    def destination_kubernetes_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_kubernetes_ids")

    @_builtins.property
    @pulumi.getter(name="destinationLoadBalancerUids")
    def destination_load_balancer_uids(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_load_balancer_uids")

    @_builtins.property
    @pulumi.getter(name="destinationTags")
    def destination_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        traffic.
        """
        return pulumi.get(self, "destination_tags")

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")


@pulumi.output_type
class GetFirewallPendingChangeResult(dict):
    def __init__(__self__, *,
                 droplet_id: Optional[_builtins.int] = None,
                 removing: Optional[_builtins.bool] = None,
                 status: Optional[_builtins.str] = None):
        """
        :param _builtins.str status: A status string indicating the current state of the Firewall.
               This can be "waiting", "succeeded", or "failed".
        """
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if removing is not None:
            pulumi.set(__self__, "removing", removing)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "droplet_id")

    @_builtins.property
    @pulumi.getter
    def removing(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "removing")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        A status string indicating the current state of the Firewall.
        This can be "waiting", "succeeded", or "failed".
        """
        return pulumi.get(self, "status")


@pulumi.output_type
class GetGenaiAgentAgentGuardrailResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 is_attached: _builtins.bool,
                 updated_at: _builtins.str,
                 agent_uuid: Optional[_builtins.str] = None,
                 default_response: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 is_default: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Guardrail
        :param _builtins.bool is_attached: Indicates if the Guardrail is attached
        :param _builtins.str updated_at: Updated At timestamp for the Guardrail
        :param _builtins.str agent_uuid: Agent UUID for the Guardrail
        :param _builtins.str default_response: Default response for the Guardrail
        :param _builtins.str description: Description of the Guardrail
        :param _builtins.str guardrail_uuid: Guardrail UUID
        :param _builtins.bool is_default: Indicates if the Guardrail is default
        :param _builtins.str name: Name of Guardrail
        :param _builtins.int priority: Priority of the Guardrail
        :param _builtins.str type: Type of the Guardrail
        :param _builtins.str uuid: Guardrail UUID
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "is_attached", is_attached)
        pulumi.set(__self__, "updated_at", updated_at)
        if agent_uuid is not None:
            pulumi.set(__self__, "agent_uuid", agent_uuid)
        if default_response is not None:
            pulumi.set(__self__, "default_response", default_response)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Guardrail
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="isAttached")
    def is_attached(self) -> _builtins.bool:
        """
        Indicates if the Guardrail is attached
        """
        return pulumi.get(self, "is_attached")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Guardrail
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="agentUuid")
    def agent_uuid(self) -> Optional[_builtins.str]:
        """
        Agent UUID for the Guardrail
        """
        return pulumi.get(self, "agent_uuid")

    @_builtins.property
    @pulumi.getter(name="defaultResponse")
    def default_response(self) -> Optional[_builtins.str]:
        """
        Default response for the Guardrail
        """
        return pulumi.get(self, "default_response")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Guardrail
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "guardrail_uuid")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Guardrail is default
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of Guardrail
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Priority of the Guardrail
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the Guardrail
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str chatbot_id: Chatbot ID
        """
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[_builtins.str]:
        """
        Chatbot ID
        """
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentChildAgentResult(dict):
    def __init__(__self__, *,
                 agent_id: _builtins.str,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 anthropic_api_keys: Optional[Sequence['outputs.GetGenaiAgentChildAgentAnthropicApiKeyResult']] = None,
                 api_key_infos: Optional[Sequence['outputs.GetGenaiAgentChildAgentApiKeyInfoResult']] = None,
                 api_keys: Optional[Sequence['outputs.GetGenaiAgentChildAgentApiKeyResult']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GetGenaiAgentChildAgentChatbotIdentifierResult']] = None,
                 chatbots: Optional[Sequence['outputs.GetGenaiAgentChildAgentChatbotResult']] = None,
                 deployments: Optional[Sequence['outputs.GetGenaiAgentChildAgentDeploymentResult']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_id: ID of the child agent
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param _builtins.str name: Name of the Agent
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param Sequence['GetGenaiAgentChildAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GetGenaiAgentChildAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GetGenaiAgentChildAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GetGenaiAgentChildAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GetGenaiAgentChildAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GetGenaiAgentChildAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.str:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentChildAgentAnthropicApiKeyResult']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GetGenaiAgentChildAgentApiKeyInfoResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentChildAgentApiKeyResult']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GetGenaiAgentChildAgentChatbotIdentifierResult']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GetGenaiAgentChildAgentChatbotResult']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GetGenaiAgentChildAgentDeploymentResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetGenaiAgentChildAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentChildAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentChildAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentChildAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentChildAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: _builtins.str):
        pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> _builtins.str:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentChildAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentFunctionResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 faasname: Optional[_builtins.str] = None,
                 faasnamespace: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Function
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str api_key: API Key value
        :param _builtins.str description: Description of the Function
        :param _builtins.str faasname: Name of function
        :param _builtins.str faasnamespace: Namespace of function
        :param _builtins.str guardrail_uuid: Guardrail UUID for the Function
        :param _builtins.str name: Name of function
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if faasname is not None:
            pulumi.set(__self__, "faasname", faasname)
        if faasnamespace is not None:
            pulumi.set(__self__, "faasnamespace", faasnamespace)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Function
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Function
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def faasname(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "faasname")

    @_builtins.property
    @pulumi.getter
    def faasnamespace(self) -> Optional[_builtins.str]:
        """
        Namespace of function
        """
        return pulumi.get(self, "faasnamespace")

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID for the Function
        """
        return pulumi.get(self, "guardrail_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentKnowledgeBaseResult(dict):
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_jobs: Optional[Sequence['outputs.GetGenaiAgentKnowledgeBaseLastIndexingJobResult']] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GetGenaiAgentKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str user_id: User ID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['outputs.GetGenaiAgentKnowledgeBaseLastIndexingJobResult']]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGenaiAgentKnowledgeBaseLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentModelResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['outputs.GetGenaiAgentModelAgreementResult']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GetGenaiAgentModelVersionResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiAgentModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiAgentModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GetGenaiAgentModelAgreementResult']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GetGenaiAgentModelVersionResult']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetGenaiAgentModelAgreementResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentModelVersionResult(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GetGenaiAgentOpenAiApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: OpenAI API Key
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        OpenAI API Key
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentParentAgentResult(dict):
    def __init__(__self__, *,
                 agent_id: _builtins.str,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 anthropic_api_keys: Optional[Sequence['outputs.GetGenaiAgentParentAgentAnthropicApiKeyResult']] = None,
                 api_key_infos: Optional[Sequence['outputs.GetGenaiAgentParentAgentApiKeyInfoResult']] = None,
                 api_keys: Optional[Sequence['outputs.GetGenaiAgentParentAgentApiKeyResult']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GetGenaiAgentParentAgentChatbotIdentifierResult']] = None,
                 chatbots: Optional[Sequence['outputs.GetGenaiAgentParentAgentChatbotResult']] = None,
                 deployments: Optional[Sequence['outputs.GetGenaiAgentParentAgentDeploymentResult']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_id: ID of the child agent
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param _builtins.str name: Name of the Agent
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param Sequence['GetGenaiAgentParentAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GetGenaiAgentParentAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GetGenaiAgentParentAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GetGenaiAgentParentAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GetGenaiAgentParentAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GetGenaiAgentParentAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.str:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentParentAgentAnthropicApiKeyResult']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GetGenaiAgentParentAgentApiKeyInfoResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentParentAgentApiKeyResult']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GetGenaiAgentParentAgentChatbotIdentifierResult']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GetGenaiAgentParentAgentChatbotResult']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GetGenaiAgentParentAgentDeploymentResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetGenaiAgentParentAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentParentAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentParentAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentParentAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentParentAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: _builtins.str):
        pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> _builtins.str:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentParentAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentTemplateResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 instruction: Optional[_builtins.str] = None,
                 k: Optional[_builtins.int] = None,
                 knowledge_bases: Optional[Sequence['outputs.GetGenaiAgentTemplateKnowledgeBaseResult']] = None,
                 max_tokens: Optional[_builtins.int] = None,
                 models: Optional[Sequence['outputs.GetGenaiAgentTemplateModelResult']] = None,
                 name: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Updated At timestamp for the Agent Template
        :param _builtins.str description: Description of the Agent Template
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.int k: K value for the Agent Template
        :param Sequence['GetGenaiAgentTemplateKnowledgeBaseArgs'] knowledge_bases: List of Knowledge Bases
        :param _builtins.int max_tokens: Maximum tokens allowed
        :param Sequence['GetGenaiAgentTemplateModelArgs'] models: Model of the Agent Template
        :param _builtins.str name: Name of the Agent Template
        :param _builtins.float temperature: Agent temperature setting
        :param _builtins.float top_p: Top P sampling parameter
        :param _builtins.str uuid: uuid of the Agent Template
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)
        if k is not None:
            pulumi.set(__self__, "k", k)
        if knowledge_bases is not None:
            pulumi.set(__self__, "knowledge_bases", knowledge_bases)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent Template
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Agent Template
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[_builtins.str]:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.int]:
        """
        K value for the Agent Template
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> Optional[Sequence['outputs.GetGenaiAgentTemplateKnowledgeBaseResult']]:
        """
        List of Knowledge Bases
        """
        return pulumi.get(self, "knowledge_bases")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.int]:
        """
        Maximum tokens allowed
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[Sequence['outputs.GetGenaiAgentTemplateModelResult']]:
        """
        Model of the Agent Template
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Agent Template
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Agent temperature setting
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Top P sampling parameter
        """
        return pulumi.get(self, "top_p")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        uuid of the Agent Template
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentTemplateKnowledgeBaseResult(dict):
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_jobs: Optional[Sequence['outputs.GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobResult']] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str user_id: User ID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['outputs.GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobResult']]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentTemplateModelResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['outputs.GetGenaiAgentTemplateModelAgreementResult']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GetGenaiAgentTemplateModelVersionResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiAgentTemplateModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiAgentTemplateModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GetGenaiAgentTemplateModelAgreementResult']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GetGenaiAgentTemplateModelVersionResult']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetGenaiAgentTemplateModelAgreementResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentTemplateModelVersionResult(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GetGenaiAgentVersionsAgentVersionResult(dict):
    def __init__(__self__, *,
                 agent_uuid: _builtins.str,
                 attached_child_agents: Sequence['outputs.GetGenaiAgentVersionsAgentVersionAttachedChildAgentResult'],
                 attached_functions: Sequence['outputs.GetGenaiAgentVersionsAgentVersionAttachedFunctionResult'],
                 attached_guardrails: Sequence['outputs.GetGenaiAgentVersionsAgentVersionAttachedGuardrailResult'],
                 attached_knowledge_bases: Sequence['outputs.GetGenaiAgentVersionsAgentVersionAttachedKnowledgeBaseResult'],
                 can_rollback: _builtins.bool,
                 created_at: _builtins.str,
                 created_by_email: _builtins.str,
                 currently_applied: _builtins.bool,
                 description: _builtins.str,
                 id: _builtins.str,
                 instruction: _builtins.str,
                 k: _builtins.int,
                 max_tokens: _builtins.int,
                 model_name: _builtins.str,
                 name: _builtins.str,
                 provide_citations: _builtins.bool,
                 retrieval_method: _builtins.str,
                 tags: Sequence[_builtins.str],
                 temperature: _builtins.float,
                 top_p: _builtins.float,
                 trigger_action: _builtins.str,
                 version_hash: _builtins.str):
        """
        :param _builtins.str agent_uuid: ID of the Agent to retrieve versions for
        :param Sequence['GetGenaiAgentVersionsAgentVersionAttachedChildAgentArgs'] attached_child_agents: List of child agents attached to this version
        :param Sequence['GetGenaiAgentVersionsAgentVersionAttachedFunctionArgs'] attached_functions: List of functions attached to this version
        :param Sequence['GetGenaiAgentVersionsAgentVersionAttachedGuardrailArgs'] attached_guardrails: List of guardrails attached to this version
        :param Sequence['GetGenaiAgentVersionsAgentVersionAttachedKnowledgeBaseArgs'] attached_knowledge_bases: List of Knowledge Bases agent versions
        :param _builtins.bool can_rollback: Indicates if the version can be rolled back
        :param _builtins.str created_at: Timestamp when the Agent Version was created
        :param _builtins.str created_by_email: Email of the user who created this version
        :param _builtins.bool currently_applied: Indicates if this version is currently applied configuration
        :param _builtins.str description: Description of the Agent Version
        :param _builtins.str id: Id of the Agent Version
        :param _builtins.str instruction: Instruction for the Agent Version
        :param _builtins.int k: K value for the Agent Version
        :param _builtins.int max_tokens: Maximum tokens allowed for the Agent
        :param _builtins.str model_name: Name of model associated to the agent version
        :param _builtins.str name: Name of the Agent
        :param _builtins.bool provide_citations: Indicates if the should provide in-response citations
        :param _builtins.str retrieval_method: Retrieval method used. 
               - RETRIEVAL_METHOD_UNKNOWN: The retrieval method is unknown
               - RETRIEVAL_METHOD_REWRITE: The retrieval method is rewrite
               - RETRIEVAL_METHOD_STEP_BACK: The retrieval method is step back
               - RETRIEVAL_METHOD_SUB_QUERIES: The retrieval method is sub queries
               - RETRIEVAL_METHOD_NONE: The retrieval method is none.
        :param Sequence[_builtins.str] tags: List of Tags
        :param _builtins.float temperature: Temperature setting for the Agent Version
        :param _builtins.float top_p: Top P sampling parameter for the Agent Version
        :param _builtins.str trigger_action: Trigger action for the Agent Version
        :param _builtins.str version_hash: Hash of the Agent Version
        """
        pulumi.set(__self__, "agent_uuid", agent_uuid)
        pulumi.set(__self__, "attached_child_agents", attached_child_agents)
        pulumi.set(__self__, "attached_functions", attached_functions)
        pulumi.set(__self__, "attached_guardrails", attached_guardrails)
        pulumi.set(__self__, "attached_knowledge_bases", attached_knowledge_bases)
        pulumi.set(__self__, "can_rollback", can_rollback)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "created_by_email", created_by_email)
        pulumi.set(__self__, "currently_applied", currently_applied)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "k", k)
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "model_name", model_name)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "provide_citations", provide_citations)
        pulumi.set(__self__, "retrieval_method", retrieval_method)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "top_p", top_p)
        pulumi.set(__self__, "trigger_action", trigger_action)
        pulumi.set(__self__, "version_hash", version_hash)

    @_builtins.property
    @pulumi.getter(name="agentUuid")
    def agent_uuid(self) -> _builtins.str:
        """
        ID of the Agent to retrieve versions for
        """
        return pulumi.get(self, "agent_uuid")

    @_builtins.property
    @pulumi.getter(name="attachedChildAgents")
    def attached_child_agents(self) -> Sequence['outputs.GetGenaiAgentVersionsAgentVersionAttachedChildAgentResult']:
        """
        List of child agents attached to this version
        """
        return pulumi.get(self, "attached_child_agents")

    @_builtins.property
    @pulumi.getter(name="attachedFunctions")
    def attached_functions(self) -> Sequence['outputs.GetGenaiAgentVersionsAgentVersionAttachedFunctionResult']:
        """
        List of functions attached to this version
        """
        return pulumi.get(self, "attached_functions")

    @_builtins.property
    @pulumi.getter(name="attachedGuardrails")
    def attached_guardrails(self) -> Sequence['outputs.GetGenaiAgentVersionsAgentVersionAttachedGuardrailResult']:
        """
        List of guardrails attached to this version
        """
        return pulumi.get(self, "attached_guardrails")

    @_builtins.property
    @pulumi.getter(name="attachedKnowledgeBases")
    def attached_knowledge_bases(self) -> Sequence['outputs.GetGenaiAgentVersionsAgentVersionAttachedKnowledgeBaseResult']:
        """
        List of Knowledge Bases agent versions
        """
        return pulumi.get(self, "attached_knowledge_bases")

    @_builtins.property
    @pulumi.getter(name="canRollback")
    def can_rollback(self) -> _builtins.bool:
        """
        Indicates if the version can be rolled back
        """
        return pulumi.get(self, "can_rollback")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the Agent Version was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdByEmail")
    def created_by_email(self) -> _builtins.str:
        """
        Email of the user who created this version
        """
        return pulumi.get(self, "created_by_email")

    @_builtins.property
    @pulumi.getter(name="currentlyApplied")
    def currently_applied(self) -> _builtins.bool:
        """
        Indicates if this version is currently applied configuration
        """
        return pulumi.get(self, "currently_applied")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the Agent Version
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Id of the Agent Version
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent Version
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter
    def k(self) -> _builtins.int:
        """
        K value for the Agent Version
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> _builtins.int:
        """
        Maximum tokens allowed for the Agent
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="modelName")
    def model_name(self) -> _builtins.str:
        """
        Name of model associated to the agent version
        """
        return pulumi.get(self, "model_name")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="provideCitations")
    def provide_citations(self) -> _builtins.bool:
        """
        Indicates if the should provide in-response citations
        """
        return pulumi.get(self, "provide_citations")

    @_builtins.property
    @pulumi.getter(name="retrievalMethod")
    def retrieval_method(self) -> _builtins.str:
        """
        Retrieval method used. 
        - RETRIEVAL_METHOD_UNKNOWN: The retrieval method is unknown
        - RETRIEVAL_METHOD_REWRITE: The retrieval method is rewrite
        - RETRIEVAL_METHOD_STEP_BACK: The retrieval method is step back
        - RETRIEVAL_METHOD_SUB_QUERIES: The retrieval method is sub queries
        - RETRIEVAL_METHOD_NONE: The retrieval method is none.
        """
        return pulumi.get(self, "retrieval_method")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        List of Tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> _builtins.float:
        """
        Temperature setting for the Agent Version
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> _builtins.float:
        """
        Top P sampling parameter for the Agent Version
        """
        return pulumi.get(self, "top_p")

    @_builtins.property
    @pulumi.getter(name="triggerAction")
    def trigger_action(self) -> _builtins.str:
        """
        Trigger action for the Agent Version
        """
        return pulumi.get(self, "trigger_action")

    @_builtins.property
    @pulumi.getter(name="versionHash")
    def version_hash(self) -> _builtins.str:
        """
        Hash of the Agent Version
        """
        return pulumi.get(self, "version_hash")


@pulumi.output_type
class GetGenaiAgentVersionsAgentVersionAttachedChildAgentResult(dict):
    def __init__(__self__, *,
                 agent_name: _builtins.str,
                 child_agent_uuid: _builtins.str,
                 if_case: _builtins.str,
                 is_deleted: _builtins.bool,
                 route_name: _builtins.str):
        """
        :param _builtins.str agent_name: Name of the child agent
        :param _builtins.str child_agent_uuid: Child agent unique identifier
        :param _builtins.str if_case: If case
        :param _builtins.bool is_deleted: Child agent is deleted
        :param _builtins.str route_name: Route name
        """
        pulumi.set(__self__, "agent_name", agent_name)
        pulumi.set(__self__, "child_agent_uuid", child_agent_uuid)
        pulumi.set(__self__, "if_case", if_case)
        pulumi.set(__self__, "is_deleted", is_deleted)
        pulumi.set(__self__, "route_name", route_name)

    @_builtins.property
    @pulumi.getter(name="agentName")
    def agent_name(self) -> _builtins.str:
        """
        Name of the child agent
        """
        return pulumi.get(self, "agent_name")

    @_builtins.property
    @pulumi.getter(name="childAgentUuid")
    def child_agent_uuid(self) -> _builtins.str:
        """
        Child agent unique identifier
        """
        return pulumi.get(self, "child_agent_uuid")

    @_builtins.property
    @pulumi.getter(name="ifCase")
    def if_case(self) -> _builtins.str:
        """
        If case
        """
        return pulumi.get(self, "if_case")

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> _builtins.bool:
        """
        Child agent is deleted
        """
        return pulumi.get(self, "is_deleted")

    @_builtins.property
    @pulumi.getter(name="routeName")
    def route_name(self) -> _builtins.str:
        """
        Route name
        """
        return pulumi.get(self, "route_name")


@pulumi.output_type
class GetGenaiAgentVersionsAgentVersionAttachedFunctionResult(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 faas_name: _builtins.str,
                 faas_namespace: _builtins.str,
                 is_deleted: _builtins.bool,
                 name: _builtins.str):
        """
        :param _builtins.str description: Description of the function
        :param _builtins.str faas_name: FaaS name of the function
        :param _builtins.str faas_namespace: FaaS namespace of the function
        :param _builtins.bool is_deleted: Function is deleted
        :param _builtins.str name: Name of the function
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "faas_name", faas_name)
        pulumi.set(__self__, "faas_namespace", faas_namespace)
        pulumi.set(__self__, "is_deleted", is_deleted)
        pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description of the function
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="faasName")
    def faas_name(self) -> _builtins.str:
        """
        FaaS name of the function
        """
        return pulumi.get(self, "faas_name")

    @_builtins.property
    @pulumi.getter(name="faasNamespace")
    def faas_namespace(self) -> _builtins.str:
        """
        FaaS namespace of the function
        """
        return pulumi.get(self, "faas_namespace")

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> _builtins.bool:
        """
        Function is deleted
        """
        return pulumi.get(self, "is_deleted")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the function
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class GetGenaiAgentVersionsAgentVersionAttachedGuardrailResult(dict):
    def __init__(__self__, *,
                 is_deleted: _builtins.bool,
                 name: _builtins.str,
                 priority: _builtins.int,
                 uuid: _builtins.str):
        """
        :param _builtins.bool is_deleted: Whether the guardrail is deleted
        :param _builtins.str name: Name of the guardrail
        :param _builtins.int priority: Guardrail priority
        :param _builtins.str uuid: Guardrail UUID
        """
        pulumi.set(__self__, "is_deleted", is_deleted)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> _builtins.bool:
        """
        Whether the guardrail is deleted
        """
        return pulumi.get(self, "is_deleted")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the guardrail
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        Guardrail priority
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentVersionsAgentVersionAttachedKnowledgeBaseResult(dict):
    def __init__(__self__, *,
                 is_deleted: _builtins.bool,
                 name: _builtins.str,
                 uuid: _builtins.str):
        """
        :param _builtins.bool is_deleted: Whether the knowledge base is deleted
        :param _builtins.str name: Name of the knowledge base
        :param _builtins.str uuid: Knowledge base UUID
        """
        pulumi.set(__self__, "is_deleted", is_deleted)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="isDeleted")
    def is_deleted(self) -> _builtins.bool:
        """
        Whether the knowledge base is deleted
        """
        return pulumi.get(self, "is_deleted")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the knowledge base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        Knowledge base UUID
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentVersionsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetGenaiAgentVersionsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetGenaiAgentsAgentResult(dict):
    def __init__(__self__, *,
                 agent_guardrails: Sequence['outputs.GetGenaiAgentsAgentAgentGuardrailResult'],
                 agent_id: _builtins.str,
                 anthropic_api_keys: Sequence['outputs.GetGenaiAgentsAgentAnthropicApiKeyResult'],
                 api_key_infos: Sequence['outputs.GetGenaiAgentsAgentApiKeyInfoResult'],
                 api_keys: Sequence['outputs.GetGenaiAgentsAgentApiKeyResult'],
                 chatbot_identifiers: Sequence['outputs.GetGenaiAgentsAgentChatbotIdentifierResult'],
                 chatbots: Sequence['outputs.GetGenaiAgentsAgentChatbotResult'],
                 child_agents: Sequence['outputs.GetGenaiAgentsAgentChildAgentResult'],
                 created_at: _builtins.str,
                 deployments: Sequence['outputs.GetGenaiAgentsAgentDeploymentResult'],
                 description: _builtins.str,
                 functions: Sequence['outputs.GetGenaiAgentsAgentFunctionResult'],
                 if_case: _builtins.str,
                 instruction: _builtins.str,
                 k: _builtins.int,
                 knowledge_bases: Sequence['outputs.GetGenaiAgentsAgentKnowledgeBaseResult'],
                 max_tokens: _builtins.int,
                 model_uuid: _builtins.str,
                 models: Sequence['outputs.GetGenaiAgentsAgentModelResult'],
                 name: _builtins.str,
                 open_ai_api_keys: Sequence['outputs.GetGenaiAgentsAgentOpenAiApiKeyResult'],
                 parent_agents: Sequence['outputs.GetGenaiAgentsAgentParentAgentResult'],
                 project_id: _builtins.str,
                 region: _builtins.str,
                 retrieval_method: _builtins.str,
                 route_created_at: _builtins.str,
                 route_created_by: _builtins.str,
                 route_name: _builtins.str,
                 route_uuid: _builtins.str,
                 tags: Sequence[_builtins.str],
                 temperature: _builtins.float,
                 templates: Sequence['outputs.GetGenaiAgentsAgentTemplateResult'],
                 top_p: _builtins.float,
                 updated_at: _builtins.str,
                 url: _builtins.str,
                 user_id: _builtins.str):
        """
        :param Sequence['GetGenaiAgentsAgentAgentGuardrailArgs'] agent_guardrails: AgentGuardrail represents a Guardrail attached to Gen AI Agent
        :param _builtins.str agent_id: ID of the Agent to retrieve
        :param Sequence['GetGenaiAgentsAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GetGenaiAgentsAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GetGenaiAgentsAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GetGenaiAgentsAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GetGenaiAgentsAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GetGenaiAgentsAgentChildAgentArgs'] child_agents: List of child agents
        :param _builtins.str created_at: Timestamp when the Agent was created
        :param Sequence['GetGenaiAgentsAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        :param Sequence['GetGenaiAgentsAgentFunctionArgs'] functions: List of API Key Infos
        :param _builtins.str if_case: If case condition
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.int k: K value
        :param Sequence['GetGenaiAgentsAgentKnowledgeBaseArgs'] knowledge_bases: List of Knowledge Bases
        :param _builtins.int max_tokens: Maximum tokens allowed
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param Sequence['GetGenaiAgentsAgentModelArgs'] models: Model of the Agent
        :param _builtins.str name: Name of the Agent
        :param Sequence['GetGenaiAgentsAgentOpenAiApiKeyArgs'] open_ai_api_keys: OpenAI API Key information
        :param Sequence['GetGenaiAgentsAgentParentAgentArgs'] parent_agents: List of parent agents
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param _builtins.str retrieval_method: Retrieval method used
        :param _builtins.str route_created_at: Timestamp when the route was created
        :param _builtins.str route_created_by: User who created the route
        :param _builtins.str route_name: Route name
        :param _builtins.str route_uuid: Route UUID
        :param Sequence[_builtins.str] tags: List of Tags
        :param _builtins.float temperature: Agent temperature setting
        :param Sequence['GetGenaiAgentsAgentTemplateArgs'] templates: Agent Template
        :param _builtins.float top_p: Top P sampling parameter
        :param _builtins.str updated_at: Timestamp when the Agent was updated
        :param _builtins.str url: URL for the Agent
        :param _builtins.str user_id: User ID linked with the Agent
        """
        pulumi.set(__self__, "agent_guardrails", agent_guardrails)
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        pulumi.set(__self__, "api_key_infos", api_key_infos)
        pulumi.set(__self__, "api_keys", api_keys)
        pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        pulumi.set(__self__, "chatbots", chatbots)
        pulumi.set(__self__, "child_agents", child_agents)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deployments", deployments)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "functions", functions)
        pulumi.set(__self__, "if_case", if_case)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "k", k)
        pulumi.set(__self__, "knowledge_bases", knowledge_bases)
        pulumi.set(__self__, "max_tokens", max_tokens)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "models", models)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "open_ai_api_keys", open_ai_api_keys)
        pulumi.set(__self__, "parent_agents", parent_agents)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "retrieval_method", retrieval_method)
        pulumi.set(__self__, "route_created_at", route_created_at)
        pulumi.set(__self__, "route_created_by", route_created_by)
        pulumi.set(__self__, "route_name", route_name)
        pulumi.set(__self__, "route_uuid", route_uuid)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "temperature", temperature)
        pulumi.set(__self__, "templates", templates)
        pulumi.set(__self__, "top_p", top_p)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "url", url)
        pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="agentGuardrails")
    def agent_guardrails(self) -> Sequence['outputs.GetGenaiAgentsAgentAgentGuardrailResult']:
        """
        AgentGuardrail represents a Guardrail attached to Gen AI Agent
        """
        return pulumi.get(self, "agent_guardrails")

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.str:
        """
        ID of the Agent to retrieve
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Sequence['outputs.GetGenaiAgentsAgentAnthropicApiKeyResult']:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Sequence['outputs.GetGenaiAgentsAgentApiKeyInfoResult']:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Sequence['outputs.GetGenaiAgentsAgentApiKeyResult']:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Sequence['outputs.GetGenaiAgentsAgentChatbotIdentifierResult']:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Sequence['outputs.GetGenaiAgentsAgentChatbotResult']:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter(name="childAgents")
    def child_agents(self) -> Sequence['outputs.GetGenaiAgentsAgentChildAgentResult']:
        """
        List of child agents
        """
        return pulumi.get(self, "child_agents")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the Agent was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Sequence['outputs.GetGenaiAgentsAgentDeploymentResult']:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Sequence['outputs.GetGenaiAgentsAgentFunctionResult']:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter(name="ifCase")
    def if_case(self) -> _builtins.str:
        """
        If case condition
        """
        return pulumi.get(self, "if_case")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter
    def k(self) -> _builtins.int:
        """
        K value
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> Sequence['outputs.GetGenaiAgentsAgentKnowledgeBaseResult']:
        """
        List of Knowledge Bases
        """
        return pulumi.get(self, "knowledge_bases")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> _builtins.int:
        """
        Maximum tokens allowed
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Sequence['outputs.GetGenaiAgentsAgentModelResult']:
        """
        Model of the Agent
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openAiApiKeys")
    def open_ai_api_keys(self) -> Sequence['outputs.GetGenaiAgentsAgentOpenAiApiKeyResult']:
        """
        OpenAI API Key information
        """
        return pulumi.get(self, "open_ai_api_keys")

    @_builtins.property
    @pulumi.getter(name="parentAgents")
    def parent_agents(self) -> Sequence['outputs.GetGenaiAgentsAgentParentAgentResult']:
        """
        List of parent agents
        """
        return pulumi.get(self, "parent_agents")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="retrievalMethod")
    def retrieval_method(self) -> _builtins.str:
        """
        Retrieval method used
        """
        return pulumi.get(self, "retrieval_method")

    @_builtins.property
    @pulumi.getter(name="routeCreatedAt")
    def route_created_at(self) -> _builtins.str:
        """
        Timestamp when the route was created
        """
        return pulumi.get(self, "route_created_at")

    @_builtins.property
    @pulumi.getter(name="routeCreatedBy")
    def route_created_by(self) -> _builtins.str:
        """
        User who created the route
        """
        return pulumi.get(self, "route_created_by")

    @_builtins.property
    @pulumi.getter(name="routeName")
    def route_name(self) -> _builtins.str:
        """
        Route name
        """
        return pulumi.get(self, "route_name")

    @_builtins.property
    @pulumi.getter(name="routeUuid")
    def route_uuid(self) -> _builtins.str:
        """
        Route UUID
        """
        return pulumi.get(self, "route_uuid")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        List of Tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> _builtins.float:
        """
        Agent temperature setting
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Sequence['outputs.GetGenaiAgentsAgentTemplateResult']:
        """
        Agent Template
        """
        return pulumi.get(self, "templates")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> _builtins.float:
        """
        Top P sampling parameter
        """
        return pulumi.get(self, "top_p")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Agent was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def url(self) -> _builtins.str:
        """
        URL for the Agent
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        User ID linked with the Agent
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGenaiAgentsAgentAgentGuardrailResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 is_attached: _builtins.bool,
                 updated_at: _builtins.str,
                 agent_uuid: Optional[_builtins.str] = None,
                 default_response: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 is_default: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Guardrail
        :param _builtins.bool is_attached: Indicates if the Guardrail is attached
        :param _builtins.str updated_at: Updated At timestamp for the Guardrail
        :param _builtins.str agent_uuid: Agent UUID for the Guardrail
        :param _builtins.str default_response: Default response for the Guardrail
        :param _builtins.str description: Description of the Guardrail
        :param _builtins.str guardrail_uuid: Guardrail UUID
        :param _builtins.bool is_default: Indicates if the Guardrail is default
        :param _builtins.str name: Name of Guardrail
        :param _builtins.int priority: Priority of the Guardrail
        :param _builtins.str type: Type of the Guardrail
        :param _builtins.str uuid: Guardrail UUID
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "is_attached", is_attached)
        pulumi.set(__self__, "updated_at", updated_at)
        if agent_uuid is not None:
            pulumi.set(__self__, "agent_uuid", agent_uuid)
        if default_response is not None:
            pulumi.set(__self__, "default_response", default_response)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Guardrail
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="isAttached")
    def is_attached(self) -> _builtins.bool:
        """
        Indicates if the Guardrail is attached
        """
        return pulumi.get(self, "is_attached")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Guardrail
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="agentUuid")
    def agent_uuid(self) -> Optional[_builtins.str]:
        """
        Agent UUID for the Guardrail
        """
        return pulumi.get(self, "agent_uuid")

    @_builtins.property
    @pulumi.getter(name="defaultResponse")
    def default_response(self) -> Optional[_builtins.str]:
        """
        Default response for the Guardrail
        """
        return pulumi.get(self, "default_response")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Guardrail
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "guardrail_uuid")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Guardrail is default
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of Guardrail
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Priority of the Guardrail
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the Guardrail
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentsAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentsAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str chatbot_id: Chatbot ID
        """
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[_builtins.str]:
        """
        Chatbot ID
        """
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentsAgentChildAgentResult(dict):
    def __init__(__self__, *,
                 agent_id: _builtins.str,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 anthropic_api_keys: Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentAnthropicApiKeyResult']] = None,
                 api_key_infos: Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentApiKeyInfoResult']] = None,
                 api_keys: Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentApiKeyResult']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentChatbotIdentifierResult']] = None,
                 chatbots: Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentChatbotResult']] = None,
                 deployments: Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentDeploymentResult']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_id: ID of the child agent
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param _builtins.str name: Name of the Agent
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param Sequence['GetGenaiAgentsAgentChildAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GetGenaiAgentsAgentChildAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GetGenaiAgentsAgentChildAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GetGenaiAgentsAgentChildAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GetGenaiAgentsAgentChildAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GetGenaiAgentsAgentChildAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.str:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentAnthropicApiKeyResult']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentApiKeyInfoResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentApiKeyResult']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentChatbotIdentifierResult']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentChatbotResult']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentChildAgentDeploymentResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetGenaiAgentsAgentChildAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentChildAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentsAgentChildAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentChildAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentsAgentChildAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: _builtins.str):
        pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> _builtins.str:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentsAgentChildAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentsAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentsAgentFunctionResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 faasname: Optional[_builtins.str] = None,
                 faasnamespace: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Function
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str api_key: API Key value
        :param _builtins.str description: Description of the Function
        :param _builtins.str faasname: Name of function
        :param _builtins.str faasnamespace: Namespace of function
        :param _builtins.str guardrail_uuid: Guardrail UUID for the Function
        :param _builtins.str name: Name of function
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if faasname is not None:
            pulumi.set(__self__, "faasname", faasname)
        if faasnamespace is not None:
            pulumi.set(__self__, "faasnamespace", faasnamespace)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Function
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Function
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def faasname(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "faasname")

    @_builtins.property
    @pulumi.getter
    def faasnamespace(self) -> Optional[_builtins.str]:
        """
        Namespace of function
        """
        return pulumi.get(self, "faasnamespace")

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID for the Function
        """
        return pulumi.get(self, "guardrail_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentKnowledgeBaseResult(dict):
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_jobs: Optional[Sequence['outputs.GetGenaiAgentsAgentKnowledgeBaseLastIndexingJobResult']] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GetGenaiAgentsAgentKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str user_id: User ID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentKnowledgeBaseLastIndexingJobResult']]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGenaiAgentsAgentKnowledgeBaseLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentModelResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['outputs.GetGenaiAgentsAgentModelAgreementResult']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GetGenaiAgentsAgentModelVersionResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiAgentsAgentModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiAgentsAgentModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentModelAgreementResult']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentModelVersionResult']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetGenaiAgentsAgentModelAgreementResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentModelVersionResult(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GetGenaiAgentsAgentOpenAiApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: OpenAI API Key
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        OpenAI API Key
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentsAgentParentAgentResult(dict):
    def __init__(__self__, *,
                 agent_id: _builtins.str,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 anthropic_api_keys: Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentAnthropicApiKeyResult']] = None,
                 api_key_infos: Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentApiKeyInfoResult']] = None,
                 api_keys: Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentApiKeyResult']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentChatbotIdentifierResult']] = None,
                 chatbots: Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentChatbotResult']] = None,
                 deployments: Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentDeploymentResult']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_id: ID of the child agent
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param _builtins.str name: Name of the Agent
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param Sequence['GetGenaiAgentsAgentParentAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GetGenaiAgentsAgentParentAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GetGenaiAgentsAgentParentAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GetGenaiAgentsAgentParentAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GetGenaiAgentsAgentParentAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GetGenaiAgentsAgentParentAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.str:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentAnthropicApiKeyResult']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentApiKeyInfoResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentApiKeyResult']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentChatbotIdentifierResult']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentChatbotResult']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentParentAgentDeploymentResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetGenaiAgentsAgentParentAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentParentAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentsAgentParentAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentParentAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentsAgentParentAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: _builtins.str):
        pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> _builtins.str:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentsAgentParentAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentsAgentTemplateResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 instruction: Optional[_builtins.str] = None,
                 k: Optional[_builtins.int] = None,
                 knowledge_bases: Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateKnowledgeBaseResult']] = None,
                 max_tokens: Optional[_builtins.int] = None,
                 models: Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateModelResult']] = None,
                 name: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Updated At timestamp for the Agent Template
        :param _builtins.str description: Description of the Agent Template
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.int k: K value for the Agent Template
        :param Sequence['GetGenaiAgentsAgentTemplateKnowledgeBaseArgs'] knowledge_bases: List of Knowledge Bases
        :param _builtins.int max_tokens: Maximum tokens allowed
        :param Sequence['GetGenaiAgentsAgentTemplateModelArgs'] models: Model of the Agent Template
        :param _builtins.str name: Name of the Agent Template
        :param _builtins.float temperature: Agent temperature setting
        :param _builtins.float top_p: Top P sampling parameter
        :param _builtins.str uuid: uuid of the Agent Template
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)
        if k is not None:
            pulumi.set(__self__, "k", k)
        if knowledge_bases is not None:
            pulumi.set(__self__, "knowledge_bases", knowledge_bases)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent Template
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Agent Template
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[_builtins.str]:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.int]:
        """
        K value for the Agent Template
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateKnowledgeBaseResult']]:
        """
        List of Knowledge Bases
        """
        return pulumi.get(self, "knowledge_bases")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.int]:
        """
        Maximum tokens allowed
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateModelResult']]:
        """
        Model of the Agent Template
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Agent Template
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Agent temperature setting
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Top P sampling parameter
        """
        return pulumi.get(self, "top_p")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        uuid of the Agent Template
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentTemplateKnowledgeBaseResult(dict):
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_jobs: Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateKnowledgeBaseLastIndexingJobResult']] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GetGenaiAgentsAgentTemplateKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str user_id: User ID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateKnowledgeBaseLastIndexingJobResult']]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGenaiAgentsAgentTemplateKnowledgeBaseLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentTemplateModelResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateModelAgreementResult']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateModelVersionResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiAgentsAgentTemplateModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiAgentsAgentTemplateModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateModelAgreementResult']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GetGenaiAgentsAgentTemplateModelVersionResult']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetGenaiAgentsAgentTemplateModelAgreementResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsAgentTemplateModelVersionResult(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentResult(dict):
    def __init__(__self__, *,
                 agent_id: _builtins.str,
                 child_agents: Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentResult'],
                 created_at: _builtins.str,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 models: Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentModelResult'],
                 name: _builtins.str,
                 parent_agents: Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentResult'],
                 project_id: _builtins.str,
                 region: _builtins.str,
                 route_created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agent_guardrails: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentAgentGuardrailResult']] = None,
                 anthropic_api_keys: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentAnthropicApiKeyResult']] = None,
                 api_key_infos: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentApiKeyInfoResult']] = None,
                 api_keys: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentApiKeyResult']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChatbotIdentifierResult']] = None,
                 chatbots: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChatbotResult']] = None,
                 deployments: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentDeploymentResult']] = None,
                 description: Optional[_builtins.str] = None,
                 functions: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentFunctionResult']] = None,
                 if_case: Optional[_builtins.str] = None,
                 k: Optional[_builtins.int] = None,
                 knowledge_bases: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseResult']] = None,
                 max_tokens: Optional[_builtins.int] = None,
                 open_ai_api_keys: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentOpenAiApiKeyResult']] = None,
                 retrieval_method: Optional[_builtins.str] = None,
                 route_created_by: Optional[_builtins.str] = None,
                 route_name: Optional[_builtins.str] = None,
                 route_uuid: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 temperature: Optional[_builtins.float] = None,
                 templates: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateResult']] = None,
                 top_p: Optional[_builtins.float] = None,
                 url: Optional[_builtins.str] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_id: ID of the Agent to retrieve
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChildAgentArgs'] child_agents: List of child agents
        :param _builtins.str created_at: Timestamp when the Agent was created
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentModelArgs'] models: Model of the Agent
        :param _builtins.str name: Name of the Agent
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentParentAgentArgs'] parent_agents: List of parent agents
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param _builtins.str route_created_at: Timestamp when the route was created
        :param _builtins.str updated_at: Timestamp when the Agent was updated
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentAgentGuardrailArgs'] agent_guardrails: AgentGuardrail represents a Guardrail attached to Gen AI Agent
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentFunctionArgs'] functions: List of API Key Infos
        :param _builtins.str if_case: If case condition
        :param _builtins.int k: K value
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseArgs'] knowledge_bases: List of Knowledge Bases
        :param _builtins.int max_tokens: Maximum tokens allowed
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentOpenAiApiKeyArgs'] open_ai_api_keys: OpenAI API Key information
        :param _builtins.str retrieval_method: Retrieval method used
        :param _builtins.str route_created_by: User who created the route
        :param _builtins.str route_name: Route name
        :param _builtins.str route_uuid: Route UUID
        :param Sequence[_builtins.str] tags: List of Tags
        :param _builtins.float temperature: Agent temperature setting
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentTemplateArgs'] templates: Agent Template
        :param _builtins.float top_p: Top P sampling parameter
        :param _builtins.str url: URL for the Agent
        :param _builtins.str user_id: User ID linked with the Agent
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "child_agents", child_agents)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "models", models)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "parent_agents", parent_agents)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "route_created_at", route_created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agent_guardrails is not None:
            pulumi.set(__self__, "agent_guardrails", agent_guardrails)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if if_case is not None:
            pulumi.set(__self__, "if_case", if_case)
        if k is not None:
            pulumi.set(__self__, "k", k)
        if knowledge_bases is not None:
            pulumi.set(__self__, "knowledge_bases", knowledge_bases)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if open_ai_api_keys is not None:
            pulumi.set(__self__, "open_ai_api_keys", open_ai_api_keys)
        if retrieval_method is not None:
            pulumi.set(__self__, "retrieval_method", retrieval_method)
        if route_created_by is not None:
            pulumi.set(__self__, "route_created_by", route_created_by)
        if route_name is not None:
            pulumi.set(__self__, "route_name", route_name)
        if route_uuid is not None:
            pulumi.set(__self__, "route_uuid", route_uuid)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if templates is not None:
            pulumi.set(__self__, "templates", templates)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.str:
        """
        ID of the Agent to retrieve
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter(name="childAgents")
    def child_agents(self) -> Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentResult']:
        """
        List of child agents
        """
        return pulumi.get(self, "child_agents")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the Agent was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentModelResult']:
        """
        Model of the Agent
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentAgents")
    def parent_agents(self) -> Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentResult']:
        """
        List of parent agents
        """
        return pulumi.get(self, "parent_agents")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="routeCreatedAt")
    def route_created_at(self) -> _builtins.str:
        """
        Timestamp when the route was created
        """
        return pulumi.get(self, "route_created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Agent was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="agentGuardrails")
    def agent_guardrails(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentAgentGuardrailResult']]:
        """
        AgentGuardrail represents a Guardrail attached to Gen AI Agent
        """
        return pulumi.get(self, "agent_guardrails")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentAnthropicApiKeyResult']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentApiKeyInfoResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentApiKeyResult']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChatbotIdentifierResult']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChatbotResult']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentDeploymentResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentFunctionResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "functions")

    @_builtins.property
    @pulumi.getter(name="ifCase")
    def if_case(self) -> Optional[_builtins.str]:
        """
        If case condition
        """
        return pulumi.get(self, "if_case")

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.int]:
        """
        K value
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseResult']]:
        """
        List of Knowledge Bases
        """
        return pulumi.get(self, "knowledge_bases")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.int]:
        """
        Maximum tokens allowed
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter(name="openAiApiKeys")
    def open_ai_api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentOpenAiApiKeyResult']]:
        """
        OpenAI API Key information
        """
        return pulumi.get(self, "open_ai_api_keys")

    @_builtins.property
    @pulumi.getter(name="retrievalMethod")
    def retrieval_method(self) -> Optional[_builtins.str]:
        """
        Retrieval method used
        """
        return pulumi.get(self, "retrieval_method")

    @_builtins.property
    @pulumi.getter(name="routeCreatedBy")
    def route_created_by(self) -> Optional[_builtins.str]:
        """
        User who created the route
        """
        return pulumi.get(self, "route_created_by")

    @_builtins.property
    @pulumi.getter(name="routeName")
    def route_name(self) -> Optional[_builtins.str]:
        """
        Route name
        """
        return pulumi.get(self, "route_name")

    @_builtins.property
    @pulumi.getter(name="routeUuid")
    def route_uuid(self) -> Optional[_builtins.str]:
        """
        Route UUID
        """
        return pulumi.get(self, "route_uuid")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Agent temperature setting
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter
    def templates(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateResult']]:
        """
        Agent Template
        """
        return pulumi.get(self, "templates")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Top P sampling parameter
        """
        return pulumi.get(self, "top_p")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL for the Agent
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID linked with the Agent
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentAgentGuardrailResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 is_attached: _builtins.bool,
                 updated_at: _builtins.str,
                 agent_uuid: Optional[_builtins.str] = None,
                 default_response: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 is_default: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Guardrail
        :param _builtins.bool is_attached: Indicates if the Guardrail is attached
        :param _builtins.str updated_at: Updated At timestamp for the Guardrail
        :param _builtins.str agent_uuid: Agent UUID for the Guardrail
        :param _builtins.str default_response: Default response for the Guardrail
        :param _builtins.str description: Description of the Guardrail
        :param _builtins.str guardrail_uuid: Guardrail UUID
        :param _builtins.bool is_default: Indicates if the Guardrail is default
        :param _builtins.str name: Name of Guardrail
        :param _builtins.int priority: Priority of the Guardrail
        :param _builtins.str type: Type of the Guardrail
        :param _builtins.str uuid: Guardrail UUID
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "is_attached", is_attached)
        pulumi.set(__self__, "updated_at", updated_at)
        if agent_uuid is not None:
            pulumi.set(__self__, "agent_uuid", agent_uuid)
        if default_response is not None:
            pulumi.set(__self__, "default_response", default_response)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Guardrail
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="isAttached")
    def is_attached(self) -> _builtins.bool:
        """
        Indicates if the Guardrail is attached
        """
        return pulumi.get(self, "is_attached")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Guardrail
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="agentUuid")
    def agent_uuid(self) -> Optional[_builtins.str]:
        """
        Agent UUID for the Guardrail
        """
        return pulumi.get(self, "agent_uuid")

    @_builtins.property
    @pulumi.getter(name="defaultResponse")
    def default_response(self) -> Optional[_builtins.str]:
        """
        Default response for the Guardrail
        """
        return pulumi.get(self, "default_response")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Guardrail
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "guardrail_uuid")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Guardrail is default
        """
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of Guardrail
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Priority of the Guardrail
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the Guardrail
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str chatbot_id: Chatbot ID
        """
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[_builtins.str]:
        """
        Chatbot ID
        """
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChildAgentResult(dict):
    def __init__(__self__, *,
                 agent_id: _builtins.str,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 anthropic_api_keys: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentAnthropicApiKeyResult']] = None,
                 api_key_infos: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyInfoResult']] = None,
                 api_keys: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyResult']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotIdentifierResult']] = None,
                 chatbots: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotResult']] = None,
                 deployments: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentDeploymentResult']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_id: ID of the child agent
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param _builtins.str name: Name of the Agent
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChildAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentChildAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.str:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentAnthropicApiKeyResult']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyInfoResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyResult']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotIdentifierResult']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotResult']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentChildAgentDeploymentResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChildAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChildAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChildAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: _builtins.str):
        pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> _builtins.str:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentChildAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentFunctionResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 faasname: Optional[_builtins.str] = None,
                 faasnamespace: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Function
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str api_key: API Key value
        :param _builtins.str description: Description of the Function
        :param _builtins.str faasname: Name of function
        :param _builtins.str faasnamespace: Namespace of function
        :param _builtins.str guardrail_uuid: Guardrail UUID for the Function
        :param _builtins.str name: Name of function
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if faasname is not None:
            pulumi.set(__self__, "faasname", faasname)
        if faasnamespace is not None:
            pulumi.set(__self__, "faasnamespace", faasnamespace)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Function
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Function
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def faasname(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "faasname")

    @_builtins.property
    @pulumi.getter
    def faasnamespace(self) -> Optional[_builtins.str]:
        """
        Namespace of function
        """
        return pulumi.get(self, "faasnamespace")

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID for the Function
        """
        return pulumi.get(self, "guardrail_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseResult(dict):
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_job: Optional['outputs.GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseLastIndexingJobResult'] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param 'GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseLastIndexingJobArgs' last_indexing_job: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str user_id: User ID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_job is not None:
            pulumi.set(__self__, "last_indexing_job", last_indexing_job)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJob")
    def last_indexing_job(self) -> Optional['outputs.GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseLastIndexingJobResult']:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_job")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentKnowledgeBaseLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentModelResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentModelAgreementResult']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentModelVersionResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentModelAgreementResult']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentModelVersionResult']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentModelAgreementResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentModelVersionResult(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentOpenAiApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: OpenAI API Key
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        OpenAI API Key
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentParentAgentResult(dict):
    def __init__(__self__, *,
                 agent_id: _builtins.str,
                 instruction: _builtins.str,
                 model_uuid: _builtins.str,
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 anthropic_api_keys: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentAnthropicApiKeyResult']] = None,
                 api_key_infos: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyInfoResult']] = None,
                 api_keys: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyResult']] = None,
                 chatbot_identifiers: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotIdentifierResult']] = None,
                 chatbots: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotResult']] = None,
                 deployments: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentDeploymentResult']] = None,
                 description: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent_id: ID of the child agent
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.str model_uuid: Model UUID of the Agent
        :param _builtins.str name: Name of the Agent
        :param _builtins.str project_id: Project ID of the Agent
        :param _builtins.str region: Region where the Agent is deployed
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentParentAgentAnthropicApiKeyArgs'] anthropic_api_keys: Anthropic API Key information
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyInfoArgs'] api_key_infos: List of API Key Infos
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyArgs'] api_keys: List of API Keys
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotIdentifierArgs'] chatbot_identifiers: List of Chatbot Identifiers
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotArgs'] chatbots: ChatBot configuration
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentParentAgentDeploymentArgs'] deployments: List of API Key Infos
        :param _builtins.str description: Description for the Agent
        """
        pulumi.set(__self__, "agent_id", agent_id)
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> _builtins.str:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> _builtins.str:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> _builtins.str:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentAnthropicApiKeyResult']]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyInfoResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyResult']]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotIdentifierResult']]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotResult']]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentParentAgentDeploymentResult']]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentParentAgentAnthropicApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyResult(dict):
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentParentAgentApiKeyInfoResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotResult(dict):
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentParentAgentChatbotIdentifierResult(dict):
    def __init__(__self__, *,
                 chatbot_id: _builtins.str):
        pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> _builtins.str:
        return pulumi.get(self, "chatbot_id")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentParentAgentDeploymentResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentTemplateResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 instruction: Optional[_builtins.str] = None,
                 k: Optional[_builtins.int] = None,
                 knowledge_bases: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseResult']] = None,
                 max_tokens: Optional[_builtins.int] = None,
                 models: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelResult']] = None,
                 name: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Updated At timestamp for the Agent Template
        :param _builtins.str description: Description of the Agent Template
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.int k: K value for the Agent Template
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseArgs'] knowledge_bases: List of Knowledge Bases
        :param _builtins.int max_tokens: Maximum tokens allowed
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelArgs'] models: Model of the Agent Template
        :param _builtins.str name: Name of the Agent Template
        :param _builtins.float temperature: Agent temperature setting
        :param _builtins.float top_p: Top P sampling parameter
        :param _builtins.str uuid: uuid of the Agent Template
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)
        if k is not None:
            pulumi.set(__self__, "k", k)
        if knowledge_bases is not None:
            pulumi.set(__self__, "knowledge_bases", knowledge_bases)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent Template
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Agent Template
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[_builtins.str]:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.int]:
        """
        K value for the Agent Template
        """
        return pulumi.get(self, "k")

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseResult']]:
        """
        List of Knowledge Bases
        """
        return pulumi.get(self, "knowledge_bases")

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.int]:
        """
        Maximum tokens allowed
        """
        return pulumi.get(self, "max_tokens")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelResult']]:
        """
        Model of the Agent Template
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Agent Template
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Agent temperature setting
        """
        return pulumi.get(self, "temperature")

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Top P sampling parameter
        """
        return pulumi.get(self, "top_p")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        uuid of the Agent Template
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseResult(dict):
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_job: Optional['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseLastIndexingJobResult'] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param 'GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseLastIndexingJobArgs' last_indexing_job: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str user_id: User ID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_job is not None:
            pulumi.set(__self__, "last_indexing_job", last_indexing_job)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJob")
    def last_indexing_job(self) -> Optional['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseLastIndexingJobResult']:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_job")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentTemplateKnowledgeBaseLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelAgreementResult']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelVersionResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelAgreementResult']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelVersionResult']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelAgreementResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiAgentsByOpenaiApiKeyAgentTemplateModelVersionResult(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GetGenaiAgentsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetGenaiAgentsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetGenaiKnowledgeBaseDataSourcesDatasourceResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 file_upload_data_sources: Optional[Sequence['outputs.GetGenaiKnowledgeBaseDataSourcesDatasourceFileUploadDataSourceResult']] = None,
                 last_indexing_jobs: Optional[Sequence['outputs.GetGenaiKnowledgeBaseDataSourcesDatasourceLastIndexingJobResult']] = None,
                 spaces_data_sources: Optional[Sequence['outputs.GetGenaiKnowledgeBaseDataSourcesDatasourceSpacesDataSourceResult']] = None,
                 uuid: Optional[_builtins.str] = None,
                 web_crawler_data_sources: Optional[Sequence['outputs.GetGenaiKnowledgeBaseDataSourcesDatasourceWebCrawlerDataSourceResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiKnowledgeBaseDataSourcesDatasourceFileUploadDataSourceArgs'] file_upload_data_sources: File upload data source configuration
        :param Sequence['GetGenaiKnowledgeBaseDataSourcesDatasourceLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the data source
        :param Sequence['GetGenaiKnowledgeBaseDataSourcesDatasourceSpacesDataSourceArgs'] spaces_data_sources: Spaces data source configuration
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param Sequence['GetGenaiKnowledgeBaseDataSourcesDatasourceWebCrawlerDataSourceArgs'] web_crawler_data_sources: Web crawler data source configuration
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if file_upload_data_sources is not None:
            pulumi.set(__self__, "file_upload_data_sources", file_upload_data_sources)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if spaces_data_sources is not None:
            pulumi.set(__self__, "spaces_data_sources", spaces_data_sources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if web_crawler_data_sources is not None:
            pulumi.set(__self__, "web_crawler_data_sources", web_crawler_data_sources)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="fileUploadDataSources")
    def file_upload_data_sources(self) -> Optional[Sequence['outputs.GetGenaiKnowledgeBaseDataSourcesDatasourceFileUploadDataSourceResult']]:
        """
        File upload data source configuration
        """
        return pulumi.get(self, "file_upload_data_sources")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['outputs.GetGenaiKnowledgeBaseDataSourcesDatasourceLastIndexingJobResult']]:
        """
        Last indexing job for the data source
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter(name="spacesDataSources")
    def spaces_data_sources(self) -> Optional[Sequence['outputs.GetGenaiKnowledgeBaseDataSourcesDatasourceSpacesDataSourceResult']]:
        """
        Spaces data source configuration
        """
        return pulumi.get(self, "spaces_data_sources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @_builtins.property
    @pulumi.getter(name="webCrawlerDataSources")
    def web_crawler_data_sources(self) -> Optional[Sequence['outputs.GetGenaiKnowledgeBaseDataSourcesDatasourceWebCrawlerDataSourceResult']]:
        """
        Web crawler data source configuration
        """
        return pulumi.get(self, "web_crawler_data_sources")


@pulumi.output_type
class GetGenaiKnowledgeBaseDataSourcesDatasourceFileUploadDataSourceResult(dict):
    def __init__(__self__, *,
                 original_file_name: Optional[_builtins.str] = None,
                 size_in_bytes: Optional[_builtins.str] = None,
                 stored_object_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str original_file_name: The original name of the uploaded file
        :param _builtins.str size_in_bytes: The size of the file in bytes
        :param _builtins.str stored_object_key: The stored object key for the file
        """
        if original_file_name is not None:
            pulumi.set(__self__, "original_file_name", original_file_name)
        if size_in_bytes is not None:
            pulumi.set(__self__, "size_in_bytes", size_in_bytes)
        if stored_object_key is not None:
            pulumi.set(__self__, "stored_object_key", stored_object_key)

    @_builtins.property
    @pulumi.getter(name="originalFileName")
    def original_file_name(self) -> Optional[_builtins.str]:
        """
        The original name of the uploaded file
        """
        return pulumi.get(self, "original_file_name")

    @_builtins.property
    @pulumi.getter(name="sizeInBytes")
    def size_in_bytes(self) -> Optional[_builtins.str]:
        """
        The size of the file in bytes
        """
        return pulumi.get(self, "size_in_bytes")

    @_builtins.property
    @pulumi.getter(name="storedObjectKey")
    def stored_object_key(self) -> Optional[_builtins.str]:
        """
        The stored object key for the file
        """
        return pulumi.get(self, "stored_object_key")


@pulumi.output_type
class GetGenaiKnowledgeBaseDataSourcesDatasourceLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiKnowledgeBaseDataSourcesDatasourceSpacesDataSourceResult(dict):
    def __init__(__self__, *,
                 bucket_name: Optional[_builtins.str] = None,
                 item_path: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket_name: The name of the Spaces bucket
        :param _builtins.str item_path: The path to the item in the bucket
        :param _builtins.str region: The region of the Spaces bucket
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if item_path is not None:
            pulumi.set(__self__, "item_path", item_path)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[_builtins.str]:
        """
        The name of the Spaces bucket
        """
        return pulumi.get(self, "bucket_name")

    @_builtins.property
    @pulumi.getter(name="itemPath")
    def item_path(self) -> Optional[_builtins.str]:
        """
        The path to the item in the bucket
        """
        return pulumi.get(self, "item_path")

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        The region of the Spaces bucket
        """
        return pulumi.get(self, "region")


@pulumi.output_type
class GetGenaiKnowledgeBaseDataSourcesDatasourceWebCrawlerDataSourceResult(dict):
    def __init__(__self__, *,
                 base_url: Optional[_builtins.str] = None,
                 crawling_option: Optional[_builtins.str] = None,
                 embed_media: Optional[_builtins.bool] = None):
        """
        :param _builtins.str base_url: The base URL to crawl
        :param _builtins.str crawling_option: Options for specifying how URLs found on pages should be handled. 
               - UNKNOWN: Default unknown value
               - SCOPED: Only include the base URL.
               - PATH: Crawl the base URL and linked pages within the URL path.
               - DOMAIN: Crawl the base URL and linked pages within the same domain.
               - SUBDOMAINS: Crawl the base URL and linked pages for any subdomain.
        :param _builtins.bool embed_media: Whether to embed media content
        """
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if crawling_option is not None:
            pulumi.set(__self__, "crawling_option", crawling_option)
        if embed_media is not None:
            pulumi.set(__self__, "embed_media", embed_media)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[_builtins.str]:
        """
        The base URL to crawl
        """
        return pulumi.get(self, "base_url")

    @_builtins.property
    @pulumi.getter(name="crawlingOption")
    def crawling_option(self) -> Optional[_builtins.str]:
        """
        Options for specifying how URLs found on pages should be handled. 
        - UNKNOWN: Default unknown value
        - SCOPED: Only include the base URL.
        - PATH: Crawl the base URL and linked pages within the URL path.
        - DOMAIN: Crawl the base URL and linked pages within the same domain.
        - SUBDOMAINS: Crawl the base URL and linked pages for any subdomain.
        """
        return pulumi.get(self, "crawling_option")

    @_builtins.property
    @pulumi.getter(name="embedMedia")
    def embed_media(self) -> Optional[_builtins.bool]:
        """
        Whether to embed media content
        """
        return pulumi.get(self, "embed_media")


@pulumi.output_type
class GetGenaiKnowledgeBaseLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiKnowledgeBasesFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetGenaiKnowledgeBasesKnowledgeBaseResult(dict):
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 database_id: _builtins.str,
                 embedding_model_uuid: _builtins.str,
                 is_public: _builtins.bool,
                 last_indexing_jobs: Sequence['outputs.GetGenaiKnowledgeBasesKnowledgeBaseLastIndexingJobResult'],
                 name: _builtins.str,
                 project_id: _builtins.str,
                 region: _builtins.str,
                 tags: Sequence[_builtins.str],
                 updated_at: _builtins.str,
                 user_id: _builtins.str,
                 uuid: _builtins.str):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GetGenaiKnowledgeBasesKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str user_id: User ID of the Knowledge Base
        :param _builtins.str uuid: UUID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "database_id", database_id)
        pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        pulumi.set(__self__, "is_public", is_public)
        pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "user_id", user_id)
        pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> _builtins.str:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> _builtins.str:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> _builtins.bool:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Sequence['outputs.GetGenaiKnowledgeBasesKnowledgeBaseLastIndexingJobResult']:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> _builtins.str:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> _builtins.str:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiKnowledgeBasesKnowledgeBaseLastIndexingJobResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiKnowledgeBasesSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetGenaiOpenaiApiKeyModelResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['outputs.GetGenaiOpenaiApiKeyModelAgreementResult']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GetGenaiOpenaiApiKeyModelVersionResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiOpenaiApiKeyModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiOpenaiApiKeyModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GetGenaiOpenaiApiKeyModelAgreementResult']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GetGenaiOpenaiApiKeyModelVersionResult']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetGenaiOpenaiApiKeyModelAgreementResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiOpenaiApiKeyModelVersionResult(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GetGenaiOpenaiApiKeysFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetGenaiOpenaiApiKeysOpenaiApiKeyResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 created_by: _builtins.str,
                 deleted_at: _builtins.str,
                 models: Sequence['outputs.GetGenaiOpenaiApiKeysOpenaiApiKeyModelResult'],
                 name: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param Sequence['GetGenaiOpenaiApiKeysOpenaiApiKeyModelArgs'] models: List of models associated with the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str uuid: OpenAI API Key Uuid
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "created_by", created_by)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "models", models)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> _builtins.str:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @_builtins.property
    @pulumi.getter
    def models(self) -> Sequence['outputs.GetGenaiOpenaiApiKeysOpenaiApiKeyModelResult']:
        """
        List of models associated with the API Key
        """
        return pulumi.get(self, "models")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        OpenAI API Key Uuid
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiOpenaiApiKeysOpenaiApiKeyModelResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['outputs.GetGenaiOpenaiApiKeysOpenaiApiKeyModelAgreementResult']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['outputs.GetGenaiOpenaiApiKeysOpenaiApiKeyModelVersionResult']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiOpenaiApiKeysOpenaiApiKeyModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiOpenaiApiKeysOpenaiApiKeyModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['outputs.GetGenaiOpenaiApiKeysOpenaiApiKeyModelAgreementResult']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['outputs.GetGenaiOpenaiApiKeysOpenaiApiKeyModelVersionResult']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")


@pulumi.output_type
class GetGenaiOpenaiApiKeysOpenaiApiKeyModelAgreementResult(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")


@pulumi.output_type
class GetGenaiOpenaiApiKeysOpenaiApiKeyModelVersionResult(dict):
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")


@pulumi.output_type
class GetGenaiOpenaiApiKeysSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetImagesFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the images by this key. This may be one of `distribution`, `error_message`,
               `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
               `tags`, or `type`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves images
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the images by this key. This may be one of `distribution`, `error_message`,
        `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
        `tags`, or `type`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves images
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetImagesImageResult(dict):
    def __init__(__self__, *,
                 created: _builtins.str,
                 description: _builtins.str,
                 distribution: _builtins.str,
                 error_message: _builtins.str,
                 id: _builtins.int,
                 image: _builtins.str,
                 min_disk_size: _builtins.int,
                 name: _builtins.str,
                 private: _builtins.bool,
                 regions: Sequence[_builtins.str],
                 size_gigabytes: _builtins.float,
                 slug: _builtins.str,
                 status: _builtins.str,
                 tags: Sequence[_builtins.str],
                 type: _builtins.str):
        """
        :param _builtins.str created: When the image was created
        :param _builtins.str description: a description of the image
        :param _builtins.str distribution: The name of the distribution of the OS of the image.
        :param _builtins.str error_message: Any applicable error message pertaining to the image
        :param _builtins.int id: The ID of the image.
        :param _builtins.str image: The id of the image (legacy parameter).
        :param _builtins.int min_disk_size: The minimum 'disk' required for the image.
        :param _builtins.str name: The name of the image.
        :param _builtins.bool private: Is image a public image or not. Public images represent
               Linux distributions or One-Click Applications, while non-public images represent
               snapshots and backups and are only available within your account.
        :param Sequence[_builtins.str] regions: A set of the regions that the image is available in.
        :param _builtins.float size_gigabytes: The size of the image in GB.
        :param _builtins.str slug: Unique text identifier of the image.
        :param _builtins.str status: Current status of the image
        :param Sequence[_builtins.str] tags: A set of tags applied to the image
        :param _builtins.str type: Type of the image.
        """
        pulumi.set(__self__, "created", created)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "distribution", distribution)
        pulumi.set(__self__, "error_message", error_message)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "min_disk_size", min_disk_size)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "private", private)
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "size_gigabytes", size_gigabytes)
        pulumi.set(__self__, "slug", slug)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def created(self) -> _builtins.str:
        """
        When the image was created
        """
        return pulumi.get(self, "created")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        a description of the image
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def distribution(self) -> _builtins.str:
        """
        The name of the distribution of the OS of the image.
        """
        return pulumi.get(self, "distribution")

    @_builtins.property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> _builtins.str:
        """
        Any applicable error message pertaining to the image
        """
        return pulumi.get(self, "error_message")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the image.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def image(self) -> _builtins.str:
        """
        The id of the image (legacy parameter).
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter(name="minDiskSize")
    def min_disk_size(self) -> _builtins.int:
        """
        The minimum 'disk' required for the image.
        """
        return pulumi.get(self, "min_disk_size")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the image.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def private(self) -> _builtins.bool:
        """
        Is image a public image or not. Public images represent
        Linux distributions or One-Click Applications, while non-public images represent
        snapshots and backups and are only available within your account.
        """
        return pulumi.get(self, "private")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Sequence[_builtins.str]:
        """
        A set of the regions that the image is available in.
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter(name="sizeGigabytes")
    def size_gigabytes(self) -> _builtins.float:
        """
        The size of the image in GB.
        """
        return pulumi.get(self, "size_gigabytes")

    @_builtins.property
    @pulumi.getter
    def slug(self) -> _builtins.str:
        """
        Unique text identifier of the image.
        """
        return pulumi.get(self, "slug")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        Current status of the image
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        A set of tags applied to the image
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of the image.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetImagesSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
               `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
        `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetKubernetesClusterAmdGpuDeviceMetricsExporterPluginResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetKubernetesClusterAmdGpuDevicePluginResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetKubernetesClusterClusterAutoscalerConfigurationResult(dict):
    def __init__(__self__, *,
                 expanders: Optional[Sequence[_builtins.str]] = None,
                 scale_down_unneeded_time: Optional[_builtins.str] = None,
                 scale_down_utilization_threshold: Optional[_builtins.float] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if scale_down_unneeded_time is not None:
            pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "expanders")

    @_builtins.property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scale_down_unneeded_time")

    @_builtins.property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "scale_down_utilization_threshold")


@pulumi.output_type
class GetKubernetesClusterControlPlaneFirewallResult(dict):
    def __init__(__self__, *,
                 allowed_addresses: Sequence[_builtins.str],
                 enabled: _builtins.bool):
        pulumi.set(__self__, "allowed_addresses", allowed_addresses)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="allowedAddresses")
    def allowed_addresses(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "allowed_addresses")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetKubernetesClusterKubeConfigResult(dict):
    def __init__(__self__, *,
                 client_certificate: _builtins.str,
                 client_key: _builtins.str,
                 cluster_ca_certificate: _builtins.str,
                 expires_at: _builtins.str,
                 host: _builtins.str,
                 raw_config: _builtins.str,
                 token: _builtins.str):
        """
        :param _builtins.str client_certificate: The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param _builtins.str client_key: The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param _builtins.str cluster_ca_certificate: The base64 encoded public certificate for the cluster's certificate authority.
        :param _builtins.str expires_at: The date and time when the credentials will expire and need to be regenerated.
        :param _builtins.str host: The URL of the API server on the Kubernetes master node.
        :param _builtins.str raw_config: The full contents of the Kubernetes cluster's kubeconfig file.
        :param _builtins.str token: The DigitalOcean API access token used by clients to access the cluster.
        """
        pulumi.set(__self__, "client_certificate", client_certificate)
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        pulumi.set(__self__, "expires_at", expires_at)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "raw_config", raw_config)
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> _builtins.str:
        """
        The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> _builtins.str:
        """
        The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> _builtins.str:
        """
        The base64 encoded public certificate for the cluster's certificate authority.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> _builtins.str:
        """
        The date and time when the credentials will expire and need to be regenerated.
        """
        return pulumi.get(self, "expires_at")

    @_builtins.property
    @pulumi.getter
    def host(self) -> _builtins.str:
        """
        The URL of the API server on the Kubernetes master node.
        """
        return pulumi.get(self, "host")

    @_builtins.property
    @pulumi.getter(name="rawConfig")
    def raw_config(self) -> _builtins.str:
        """
        The full contents of the Kubernetes cluster's kubeconfig file.
        """
        return pulumi.get(self, "raw_config")

    @_builtins.property
    @pulumi.getter
    def token(self) -> _builtins.str:
        """
        The DigitalOcean API access token used by clients to access the cluster.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class GetKubernetesClusterMaintenancePolicyResult(dict):
    def __init__(__self__, *,
                 day: _builtins.str,
                 duration: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str day: The day for the service window of the Kubernetes cluster.
        :param _builtins.str duration: The duration of the operation.
        :param _builtins.str start_time: The start time of the upgrade operation.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> _builtins.str:
        """
        The day for the service window of the Kubernetes cluster.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        The duration of the operation.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        The start time of the upgrade operation.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetKubernetesClusterNodePoolResult(dict):
    def __init__(__self__, *,
                 actual_node_count: _builtins.int,
                 auto_scale: _builtins.bool,
                 id: _builtins.str,
                 labels: Mapping[str, _builtins.str],
                 max_nodes: _builtins.int,
                 min_nodes: _builtins.int,
                 name: _builtins.str,
                 node_count: _builtins.int,
                 nodes: Sequence['outputs.GetKubernetesClusterNodePoolNodeResult'],
                 size: _builtins.str,
                 tags: Sequence[_builtins.str],
                 taints: Sequence['outputs.GetKubernetesClusterNodePoolTaintResult']):
        """
        :param _builtins.int actual_node_count: The actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        :param _builtins.bool auto_scale: A boolean indicating whether auto-scaling is enabled on the node pool.
        :param _builtins.str id: A unique ID that can be used to identify and reference the node.
        :param Mapping[str, _builtins.str] labels: A map of key/value pairs applied to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        :param _builtins.int max_nodes: If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        :param _builtins.int min_nodes: If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        :param _builtins.str name: The name of Kubernetes cluster.
        :param _builtins.int node_count: The number of Droplet instances in the node pool.
        :param Sequence['GetKubernetesClusterNodePoolNodeArgs'] nodes: A list of nodes in the pool. Each node exports the following attributes:
        :param _builtins.str size: The slug identifier for the type of Droplet used as workers in the node pool.
        :param Sequence[_builtins.str] tags: A list of tag names applied to the node pool.
        :param Sequence['GetKubernetesClusterNodePoolTaintArgs'] taints: A list of taints applied to all nodes in the pool. Each taint exports the following attributes:
        """
        pulumi.set(__self__, "actual_node_count", actual_node_count)
        pulumi.set(__self__, "auto_scale", auto_scale)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "labels", labels)
        pulumi.set(__self__, "max_nodes", max_nodes)
        pulumi.set(__self__, "min_nodes", min_nodes)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "nodes", nodes)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "tags", tags)
        pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter(name="actualNodeCount")
    def actual_node_count(self) -> _builtins.int:
        """
        The actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        """
        return pulumi.get(self, "actual_node_count")

    @_builtins.property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> _builtins.bool:
        """
        A boolean indicating whether auto-scaling is enabled on the node pool.
        """
        return pulumi.get(self, "auto_scale")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Mapping[str, _builtins.str]:
        """
        A map of key/value pairs applied to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        """
        return pulumi.get(self, "labels")

    @_builtins.property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> _builtins.int:
        """
        If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        """
        return pulumi.get(self, "max_nodes")

    @_builtins.property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> _builtins.int:
        """
        If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        """
        return pulumi.get(self, "min_nodes")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of Kubernetes cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of Droplet instances in the node pool.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Sequence['outputs.GetKubernetesClusterNodePoolNodeResult']:
        """
        A list of nodes in the pool. Each node exports the following attributes:
        """
        return pulumi.get(self, "nodes")

    @_builtins.property
    @pulumi.getter
    def size(self) -> _builtins.str:
        """
        The slug identifier for the type of Droplet used as workers in the node pool.
        """
        return pulumi.get(self, "size")

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Sequence[_builtins.str]:
        """
        A list of tag names applied to the node pool.
        """
        return pulumi.get(self, "tags")

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Sequence['outputs.GetKubernetesClusterNodePoolTaintResult']:
        """
        A list of taints applied to all nodes in the pool. Each taint exports the following attributes:
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class GetKubernetesClusterNodePoolNodeResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 droplet_id: _builtins.str,
                 id: _builtins.str,
                 name: _builtins.str,
                 status: _builtins.str,
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The date and time when the node was created.
        :param _builtins.str id: A unique ID that can be used to identify and reference the node.
        :param _builtins.str name: The name of Kubernetes cluster.
        :param _builtins.str status: A string indicating the current status of the individual node.
        :param _builtins.str updated_at: The date and time when the node was last updated.
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "droplet_id", droplet_id)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "status", status)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> _builtins.str:
        return pulumi.get(self, "droplet_id")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of Kubernetes cluster.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetKubernetesClusterNodePoolTaintResult(dict):
    def __init__(__self__, *,
                 effect: _builtins.str,
                 key: _builtins.str,
                 value: _builtins.str):
        """
        :param _builtins.str effect: How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        :param _builtins.str key: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        :param _builtins.str value: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> _builtins.str:
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        return pulumi.get(self, "effect")

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class GetKubernetesClusterRoutingAgentResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")


@pulumi.output_type
class GetLoadBalancerDomainResult(dict):
    def __init__(__self__, *,
                 certificate_id: _builtins.str,
                 certificate_name: _builtins.str,
                 is_managed: _builtins.bool,
                 name: _builtins.str,
                 ssl_validation_error_reasons: Sequence[_builtins.str],
                 verification_error_reasons: Sequence[_builtins.str]):
        """
        :param _builtins.str certificate_id: certificate ID for TLS handshaking
        :param _builtins.str certificate_name: name of certificate required for TLS handshaking
        :param _builtins.bool is_managed: flag indicating if domain is managed by DigitalOcean
        :param _builtins.str name: The name of load balancer.
        :param Sequence[_builtins.str] ssl_validation_error_reasons: list of domain SSL validation errors
        :param Sequence[_builtins.str] verification_error_reasons: list of domain verification errors
        """
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "certificate_name", certificate_name)
        pulumi.set(__self__, "is_managed", is_managed)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "ssl_validation_error_reasons", ssl_validation_error_reasons)
        pulumi.set(__self__, "verification_error_reasons", verification_error_reasons)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        certificate ID for TLS handshaking
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> _builtins.str:
        """
        name of certificate required for TLS handshaking
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="isManaged")
    def is_managed(self) -> _builtins.bool:
        """
        flag indicating if domain is managed by DigitalOcean
        """
        return pulumi.get(self, "is_managed")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of load balancer.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="sslValidationErrorReasons")
    def ssl_validation_error_reasons(self) -> Sequence[_builtins.str]:
        """
        list of domain SSL validation errors
        """
        return pulumi.get(self, "ssl_validation_error_reasons")

    @_builtins.property
    @pulumi.getter(name="verificationErrorReasons")
    def verification_error_reasons(self) -> Sequence[_builtins.str]:
        """
        list of domain verification errors
        """
        return pulumi.get(self, "verification_error_reasons")


@pulumi.output_type
class GetLoadBalancerFirewallResult(dict):
    def __init__(__self__, *,
                 allows: Sequence[_builtins.str],
                 denies: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] allows: the rules for ALLOWING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
        :param Sequence[_builtins.str] denies: the rules for DENYING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
        """
        pulumi.set(__self__, "allows", allows)
        pulumi.set(__self__, "denies", denies)

    @_builtins.property
    @pulumi.getter
    def allows(self) -> Sequence[_builtins.str]:
        """
        the rules for ALLOWING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
        """
        return pulumi.get(self, "allows")

    @_builtins.property
    @pulumi.getter
    def denies(self) -> Sequence[_builtins.str]:
        """
        the rules for DENYING traffic to the LB (strings in the form: 'ip:1.2.3.4' or 'cidr:1.2.0.0/16')
        """
        return pulumi.get(self, "denies")


@pulumi.output_type
class GetLoadBalancerForwardingRuleResult(dict):
    def __init__(__self__, *,
                 certificate_id: _builtins.str,
                 certificate_name: _builtins.str,
                 entry_port: _builtins.int,
                 entry_protocol: _builtins.str,
                 target_port: _builtins.int,
                 target_protocol: _builtins.str,
                 tls_passthrough: _builtins.bool):
        """
        :param _builtins.str certificate_id: the id of the tls certificate used for ssl termination if enabled
        :param _builtins.str certificate_name: the name of the tls certificate used for ssl termination if enabled
        :param _builtins.int entry_port: the port on which the load balancer instance will listen
        :param _builtins.str entry_protocol: the protocol used for traffic to the load balancer
        :param _builtins.int target_port: the port on the backend Droplets to which the load balancer will send traffic
        :param _builtins.str target_protocol: the protocol used for traffic to the backend droplets
        :param _builtins.bool tls_passthrough: whether ssl encrypted traffic will be passed through to the backend droplets
        """
        pulumi.set(__self__, "certificate_id", certificate_id)
        pulumi.set(__self__, "certificate_name", certificate_name)
        pulumi.set(__self__, "entry_port", entry_port)
        pulumi.set(__self__, "entry_protocol", entry_protocol)
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        pulumi.set(__self__, "tls_passthrough", tls_passthrough)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> _builtins.str:
        """
        the id of the tls certificate used for ssl termination if enabled
        """
        return pulumi.get(self, "certificate_id")

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> _builtins.str:
        """
        the name of the tls certificate used for ssl termination if enabled
        """
        return pulumi.get(self, "certificate_name")

    @_builtins.property
    @pulumi.getter(name="entryPort")
    def entry_port(self) -> _builtins.int:
        """
        the port on which the load balancer instance will listen
        """
        return pulumi.get(self, "entry_port")

    @_builtins.property
    @pulumi.getter(name="entryProtocol")
    def entry_protocol(self) -> _builtins.str:
        """
        the protocol used for traffic to the load balancer
        """
        return pulumi.get(self, "entry_protocol")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> _builtins.int:
        """
        the port on the backend Droplets to which the load balancer will send traffic
        """
        return pulumi.get(self, "target_port")

    @_builtins.property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> _builtins.str:
        """
        the protocol used for traffic to the backend droplets
        """
        return pulumi.get(self, "target_protocol")

    @_builtins.property
    @pulumi.getter(name="tlsPassthrough")
    def tls_passthrough(self) -> _builtins.bool:
        """
        whether ssl encrypted traffic will be passed through to the backend droplets
        """
        return pulumi.get(self, "tls_passthrough")


@pulumi.output_type
class GetLoadBalancerGlbSettingResult(dict):
    def __init__(__self__, *,
                 cdns: Sequence['outputs.GetLoadBalancerGlbSettingCdnResult'],
                 failover_threshold: _builtins.int,
                 region_priorities: Mapping[str, _builtins.int],
                 target_port: _builtins.int,
                 target_protocol: _builtins.str):
        """
        :param Sequence['GetLoadBalancerGlbSettingCdnArgs'] cdns: CDN specific configurations
        :param _builtins.int failover_threshold: fail-over threshold
        :param Mapping[str, _builtins.int] region_priorities: region priority map
        :param _builtins.int target_port: target port rules
        :param _builtins.str target_protocol: target protocol rules
        """
        pulumi.set(__self__, "cdns", cdns)
        pulumi.set(__self__, "failover_threshold", failover_threshold)
        pulumi.set(__self__, "region_priorities", region_priorities)
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)

    @_builtins.property
    @pulumi.getter
    def cdns(self) -> Sequence['outputs.GetLoadBalancerGlbSettingCdnResult']:
        """
        CDN specific configurations
        """
        return pulumi.get(self, "cdns")

    @_builtins.property
    @pulumi.getter(name="failoverThreshold")
    def failover_threshold(self) -> _builtins.int:
        """
        fail-over threshold
        """
        return pulumi.get(self, "failover_threshold")

    @_builtins.property
    @pulumi.getter(name="regionPriorities")
    def region_priorities(self) -> Mapping[str, _builtins.int]:
        """
        region priority map
        """
        return pulumi.get(self, "region_priorities")

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> _builtins.int:
        """
        target port rules
        """
        return pulumi.get(self, "target_port")

    @_builtins.property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> _builtins.str:
        """
        target protocol rules
        """
        return pulumi.get(self, "target_protocol")


@pulumi.output_type
class GetLoadBalancerGlbSettingCdnResult(dict):
    def __init__(__self__, *,
                 is_enabled: _builtins.bool):
        """
        :param _builtins.bool is_enabled: cache enable flag
        """
        pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> _builtins.bool:
        """
        cache enable flag
        """
        return pulumi.get(self, "is_enabled")


@pulumi.output_type
class GetLoadBalancerHealthcheckResult(dict):
    def __init__(__self__, *,
                 check_interval_seconds: _builtins.int,
                 healthy_threshold: _builtins.int,
                 path: _builtins.str,
                 port: _builtins.int,
                 protocol: _builtins.str,
                 response_timeout_seconds: _builtins.int,
                 unhealthy_threshold: _builtins.int):
        """
        :param _builtins.int check_interval_seconds: the number of seconds between between two consecutive health checks
        :param _builtins.int healthy_threshold: the number of times a health check must pass for a backend droplet to be marked 'healthy' and be re-added to the pool
        :param _builtins.str path: the path on the backend Droplets to which the Load Balancer will send a request
        :param _builtins.int port: the port on the backend droplets on which the health check will attempt a connection
        :param _builtins.str protocol: the protocol used for health checks sent to the backend droplets
        :param _builtins.int response_timeout_seconds: the number of seconds to wait for a response until marking a health check as failed
        :param _builtins.int unhealthy_threshold: The number of times a health check must fail for a backend droplet to be marked 'unhealthy' and be removed from the pool
        """
        pulumi.set(__self__, "check_interval_seconds", check_interval_seconds)
        pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        pulumi.set(__self__, "response_timeout_seconds", response_timeout_seconds)
        pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter(name="checkIntervalSeconds")
    def check_interval_seconds(self) -> _builtins.int:
        """
        the number of seconds between between two consecutive health checks
        """
        return pulumi.get(self, "check_interval_seconds")

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> _builtins.int:
        """
        the number of times a health check must pass for a backend droplet to be marked 'healthy' and be re-added to the pool
        """
        return pulumi.get(self, "healthy_threshold")

    @_builtins.property
    @pulumi.getter
    def path(self) -> _builtins.str:
        """
        the path on the backend Droplets to which the Load Balancer will send a request
        """
        return pulumi.get(self, "path")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        the port on the backend droplets on which the health check will attempt a connection
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        the protocol used for health checks sent to the backend droplets
        """
        return pulumi.get(self, "protocol")

    @_builtins.property
    @pulumi.getter(name="responseTimeoutSeconds")
    def response_timeout_seconds(self) -> _builtins.int:
        """
        the number of seconds to wait for a response until marking a health check as failed
        """
        return pulumi.get(self, "response_timeout_seconds")

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> _builtins.int:
        """
        The number of times a health check must fail for a backend droplet to be marked 'unhealthy' and be removed from the pool
        """
        return pulumi.get(self, "unhealthy_threshold")


@pulumi.output_type
class GetLoadBalancerStickySessionResult(dict):
    def __init__(__self__, *,
                 cookie_name: _builtins.str,
                 cookie_ttl_seconds: _builtins.int,
                 type: _builtins.str):
        """
        :param _builtins.str cookie_name: the name of the cookie sent to the client
        :param _builtins.int cookie_ttl_seconds: the number of seconds until the cookie set by the Load Balancer expires
        :param _builtins.str type: how and if requests from a client will be persistently served by the same backend droplet
        """
        pulumi.set(__self__, "cookie_name", cookie_name)
        pulumi.set(__self__, "cookie_ttl_seconds", cookie_ttl_seconds)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> _builtins.str:
        """
        the name of the cookie sent to the client
        """
        return pulumi.get(self, "cookie_name")

    @_builtins.property
    @pulumi.getter(name="cookieTtlSeconds")
    def cookie_ttl_seconds(self) -> _builtins.int:
        """
        the number of seconds until the cookie set by the Load Balancer expires
        """
        return pulumi.get(self, "cookie_ttl_seconds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        how and if requests from a client will be persistently served by the same backend droplet
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPartnerAttachmentBgpResult(dict):
    def __init__(__self__, *,
                 local_router_ip: Optional[_builtins.str] = None,
                 peer_router_asn: Optional[_builtins.int] = None,
                 peer_router_ip: Optional[_builtins.str] = None):
        if local_router_ip is not None:
            pulumi.set(__self__, "local_router_ip", local_router_ip)
        if peer_router_asn is not None:
            pulumi.set(__self__, "peer_router_asn", peer_router_asn)
        if peer_router_ip is not None:
            pulumi.set(__self__, "peer_router_ip", peer_router_ip)

    @_builtins.property
    @pulumi.getter(name="localRouterIp")
    def local_router_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "local_router_ip")

    @_builtins.property
    @pulumi.getter(name="peerRouterAsn")
    def peer_router_asn(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "peer_router_asn")

    @_builtins.property
    @pulumi.getter(name="peerRouterIp")
    def peer_router_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "peer_router_ip")


@pulumi.output_type
class GetProjectsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the projects by this key. This may be one of `name`,
               `purpose`, `description`, `environment`, or `is_default`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves projects
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the projects by this key. This may be one of `name`,
        `purpose`, `description`, `environment`, or `is_default`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves projects
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetProjectsProjectResult(dict):
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 description: _builtins.str,
                 environment: _builtins.str,
                 id: _builtins.str,
                 is_default: _builtins.bool,
                 name: _builtins.str,
                 owner_id: _builtins.int,
                 owner_uuid: _builtins.str,
                 purpose: _builtins.str,
                 resources: Sequence[_builtins.str],
                 updated_at: _builtins.str):
        """
        :param _builtins.str created_at: The date and time when the project was created, (ISO8601)
        :param _builtins.str description: The description of the project
        :param _builtins.str environment: The environment of the project's resources. The possible values are: `Development`, `Staging`, `Production`.
        :param _builtins.str id: The ID of the project
        :param _builtins.str name: The name of the project
        :param _builtins.int owner_id: The ID of the project owner
        :param _builtins.str owner_uuid: The unique universal identifier of the project owner
        :param _builtins.str purpose: The purpose of the project (Default: "Web Application")
        :param Sequence[_builtins.str] resources: A set of uniform resource names (URNs) for the resources associated with the project
        :param _builtins.str updated_at: The date and time when the project was last updated, (ISO8601)
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "environment", environment)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "is_default", is_default)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "owner_id", owner_id)
        pulumi.set(__self__, "owner_uuid", owner_uuid)
        pulumi.set(__self__, "purpose", purpose)
        pulumi.set(__self__, "resources", resources)
        pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        The date and time when the project was created, (ISO8601)
        """
        return pulumi.get(self, "created_at")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the project
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def environment(self) -> _builtins.str:
        """
        The environment of the project's resources. The possible values are: `Development`, `Staging`, `Production`.
        """
        return pulumi.get(self, "environment")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the project
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> _builtins.bool:
        return pulumi.get(self, "is_default")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the project
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="ownerId")
    def owner_id(self) -> _builtins.int:
        """
        The ID of the project owner
        """
        return pulumi.get(self, "owner_id")

    @_builtins.property
    @pulumi.getter(name="ownerUuid")
    def owner_uuid(self) -> _builtins.str:
        """
        The unique universal identifier of the project owner
        """
        return pulumi.get(self, "owner_uuid")

    @_builtins.property
    @pulumi.getter
    def purpose(self) -> _builtins.str:
        """
        The purpose of the project (Default: "Web Application")
        """
        return pulumi.get(self, "purpose")

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Sequence[_builtins.str]:
        """
        A set of uniform resource names (URNs) for the resources associated with the project
        """
        return pulumi.get(self, "resources")

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        The date and time when the project was last updated, (ISO8601)
        """
        return pulumi.get(self, "updated_at")


@pulumi.output_type
class GetProjectsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the projects by this key. This may be one of `name`,
               `purpose`, `description`, or `environment`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the projects by this key. This may be one of `name`,
        `purpose`, `description`, or `environment`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetRecordsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
               `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves DNS records
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves DNS records
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetRecordsRecordResult(dict):
    def __init__(__self__, *,
                 domain: _builtins.str,
                 flags: _builtins.int,
                 id: _builtins.int,
                 name: _builtins.str,
                 port: _builtins.int,
                 priority: _builtins.int,
                 tag: _builtins.str,
                 ttl: _builtins.int,
                 type: _builtins.str,
                 value: _builtins.str,
                 weight: _builtins.int):
        """
        :param _builtins.str domain: The domain name to search for DNS records
        :param _builtins.int flags: An unsigned integer between 0-255 used for CAA records.
        :param _builtins.int id: The ID of the record.
        :param _builtins.str name: The name of the DNS record.
        :param _builtins.int port: The port for SRV records.
        :param _builtins.int priority: The priority for SRV and MX records.
        :param _builtins.str tag: The parameter tag for CAA records.
        :param _builtins.int ttl: This value is the time to live for the record, in seconds. This defines the time frame that clients can cache queried information before a refresh should be requested.
        :param _builtins.str type: The type of the DNS record.
        :param _builtins.str value: Variable data depending on record type. For example, the "data" value for an A record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would contain the domain name of the CA being granted permission to issue certificates.
        :param _builtins.int weight: The weight for SRV records.
        """
        pulumi.set(__self__, "domain", domain)
        pulumi.set(__self__, "flags", flags)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "priority", priority)
        pulumi.set(__self__, "tag", tag)
        pulumi.set(__self__, "ttl", ttl)
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        The domain name to search for DNS records
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter
    def flags(self) -> _builtins.int:
        """
        An unsigned integer between 0-255 used for CAA records.
        """
        return pulumi.get(self, "flags")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the record.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the DNS record.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def port(self) -> _builtins.int:
        """
        The port for SRV records.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter
    def priority(self) -> _builtins.int:
        """
        The priority for SRV and MX records.
        """
        return pulumi.get(self, "priority")

    @_builtins.property
    @pulumi.getter
    def tag(self) -> _builtins.str:
        """
        The parameter tag for CAA records.
        """
        return pulumi.get(self, "tag")

    @_builtins.property
    @pulumi.getter
    def ttl(self) -> _builtins.int:
        """
        This value is the time to live for the record, in seconds. This defines the time frame that clients can cache queried information before a refresh should be requested.
        """
        return pulumi.get(self, "ttl")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the DNS record.
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter
    def value(self) -> _builtins.str:
        """
        Variable data depending on record type. For example, the "data" value for an A record would be the IPv4 address to which the domain will be mapped. For a CAA record, it would contain the domain name of the CA being granted permission to issue certificates.
        """
        return pulumi.get(self, "value")

    @_builtins.property
    @pulumi.getter
    def weight(self) -> _builtins.int:
        """
        The weight for SRV records.
        """
        return pulumi.get(self, "weight")


@pulumi.output_type
class GetRecordsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
               `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetRegionsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the regions by this key. This may be one of `slug`,
               `name`, `available`, `features`, or `sizes`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves regions
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the regions by this key. This may be one of `slug`,
        `name`, `available`, `features`, or `sizes`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves regions
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetRegionsRegionResult(dict):
    def __init__(__self__, *,
                 available: _builtins.bool,
                 features: Sequence[_builtins.str],
                 name: _builtins.str,
                 sizes: Sequence[_builtins.str],
                 slug: _builtins.str):
        """
        :param _builtins.bool available: A boolean value that represents whether new Droplets can be created in this region.
        :param Sequence[_builtins.str] features: A set of features available in this region.
        :param _builtins.str name: The display name of the region.
        :param Sequence[_builtins.str] sizes: A set of identifying slugs for the Droplet sizes available in this region.
        :param _builtins.str slug: A human-readable string that is used as a unique identifier for each region.
        """
        pulumi.set(__self__, "available", available)
        pulumi.set(__self__, "features", features)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "sizes", sizes)
        pulumi.set(__self__, "slug", slug)

    @_builtins.property
    @pulumi.getter
    def available(self) -> _builtins.bool:
        """
        A boolean value that represents whether new Droplets can be created in this region.
        """
        return pulumi.get(self, "available")

    @_builtins.property
    @pulumi.getter
    def features(self) -> Sequence[_builtins.str]:
        """
        A set of features available in this region.
        """
        return pulumi.get(self, "features")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The display name of the region.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def sizes(self) -> Sequence[_builtins.str]:
        """
        A set of identifying slugs for the Droplet sizes available in this region.
        """
        return pulumi.get(self, "sizes")

    @_builtins.property
    @pulumi.getter
    def slug(self) -> _builtins.str:
        """
        A human-readable string that is used as a unique identifier for each region.
        """
        return pulumi.get(self, "slug")


@pulumi.output_type
class GetRegionsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the regions by this key. This may be one of `slug`,
               `name`, or `available`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the regions by this key. This may be one of `slug`,
        `name`, or `available`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetSizesFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the sizes by this key. This may be one of `slug`,
               `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
               `price_hourly`, or `available`.
        :param Sequence[_builtins.str] values: Only retrieves sizes which keys has value that matches
               one of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the sizes by this key. This may be one of `slug`,
        `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
        `price_hourly`, or `available`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Only retrieves sizes which keys has value that matches
        one of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetSizesSizeResult(dict):
    def __init__(__self__, *,
                 available: _builtins.bool,
                 disk: _builtins.int,
                 memory: _builtins.int,
                 price_hourly: _builtins.float,
                 price_monthly: _builtins.float,
                 regions: Sequence[_builtins.str],
                 slug: _builtins.str,
                 transfer: _builtins.float,
                 vcpus: _builtins.int):
        """
        :param _builtins.bool available: This represents whether new Droplets can be created with this size.
        :param _builtins.int disk: The amount of disk space set aside for Droplets of this size. The value is measured in gigabytes.
        :param _builtins.int memory: The amount of RAM allocated to Droplets created of this size. The value is measured in megabytes.
        :param _builtins.float price_hourly: The hourly cost of Droplets created in this size as measured hourly. The value is measured in US dollars.
        :param _builtins.float price_monthly: The monthly cost of Droplets created in this size if they are kept for an entire month. The value is measured in US dollars.
        :param Sequence[_builtins.str] regions: List of region slugs where Droplets can be created in this size.
        :param _builtins.str slug: A human-readable string that is used to uniquely identify each size.
        :param _builtins.float transfer: The amount of transfer bandwidth that is available for Droplets created in this size. This only counts traffic on the public interface. The value is given in terabytes.
        :param _builtins.int vcpus: The number of CPUs allocated to Droplets of this size.
        """
        pulumi.set(__self__, "available", available)
        pulumi.set(__self__, "disk", disk)
        pulumi.set(__self__, "memory", memory)
        pulumi.set(__self__, "price_hourly", price_hourly)
        pulumi.set(__self__, "price_monthly", price_monthly)
        pulumi.set(__self__, "regions", regions)
        pulumi.set(__self__, "slug", slug)
        pulumi.set(__self__, "transfer", transfer)
        pulumi.set(__self__, "vcpus", vcpus)

    @_builtins.property
    @pulumi.getter
    def available(self) -> _builtins.bool:
        """
        This represents whether new Droplets can be created with this size.
        """
        return pulumi.get(self, "available")

    @_builtins.property
    @pulumi.getter
    def disk(self) -> _builtins.int:
        """
        The amount of disk space set aside for Droplets of this size. The value is measured in gigabytes.
        """
        return pulumi.get(self, "disk")

    @_builtins.property
    @pulumi.getter
    def memory(self) -> _builtins.int:
        """
        The amount of RAM allocated to Droplets created of this size. The value is measured in megabytes.
        """
        return pulumi.get(self, "memory")

    @_builtins.property
    @pulumi.getter(name="priceHourly")
    def price_hourly(self) -> _builtins.float:
        """
        The hourly cost of Droplets created in this size as measured hourly. The value is measured in US dollars.
        """
        return pulumi.get(self, "price_hourly")

    @_builtins.property
    @pulumi.getter(name="priceMonthly")
    def price_monthly(self) -> _builtins.float:
        """
        The monthly cost of Droplets created in this size if they are kept for an entire month. The value is measured in US dollars.
        """
        return pulumi.get(self, "price_monthly")

    @_builtins.property
    @pulumi.getter
    def regions(self) -> Sequence[_builtins.str]:
        """
        List of region slugs where Droplets can be created in this size.
        """
        return pulumi.get(self, "regions")

    @_builtins.property
    @pulumi.getter
    def slug(self) -> _builtins.str:
        """
        A human-readable string that is used to uniquely identify each size.
        """
        return pulumi.get(self, "slug")

    @_builtins.property
    @pulumi.getter
    def transfer(self) -> _builtins.float:
        """
        The amount of transfer bandwidth that is available for Droplets created in this size. This only counts traffic on the public interface. The value is given in terabytes.
        """
        return pulumi.get(self, "transfer")

    @_builtins.property
    @pulumi.getter
    def vcpus(self) -> _builtins.int:
        """
        The number of CPUs allocated to Droplets of this size.
        """
        return pulumi.get(self, "vcpus")


@pulumi.output_type
class GetSizesSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the sizes by this key. This may be one of `slug`,
               `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the sizes by this key. This may be one of `slug`,
        `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetSpacesBucketsBucketResult(dict):
    def __init__(__self__, *,
                 bucket_domain_name: _builtins.str,
                 endpoint: _builtins.str,
                 name: _builtins.str,
                 region: _builtins.str,
                 urn: _builtins.str):
        """
        :param _builtins.str bucket_domain_name: The FQDN of the bucket (e.g. bucket-name.nyc3.digitaloceanspaces.com)
        :param _builtins.str endpoint: The FQDN of the bucket without the bucket name (e.g. nyc3.digitaloceanspaces.com)
        :param _builtins.str name: The name of the Spaces bucket
        :param _builtins.str region: The slug of the region where the bucket is stored.
        :param _builtins.str urn: The uniform resource name of the bucket
        """
        pulumi.set(__self__, "bucket_domain_name", bucket_domain_name)
        pulumi.set(__self__, "endpoint", endpoint)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "urn", urn)

    @_builtins.property
    @pulumi.getter(name="bucketDomainName")
    def bucket_domain_name(self) -> _builtins.str:
        """
        The FQDN of the bucket (e.g. bucket-name.nyc3.digitaloceanspaces.com)
        """
        return pulumi.get(self, "bucket_domain_name")

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> _builtins.str:
        """
        The FQDN of the bucket without the bucket name (e.g. nyc3.digitaloceanspaces.com)
        """
        return pulumi.get(self, "endpoint")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the Spaces bucket
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def region(self) -> _builtins.str:
        """
        The slug of the region where the bucket is stored.
        """
        return pulumi.get(self, "region")

    @_builtins.property
    @pulumi.getter
    def urn(self) -> _builtins.str:
        """
        The uniform resource name of the bucket
        """
        return pulumi.get(self, "urn")


@pulumi.output_type
class GetSpacesBucketsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves Spaces buckets
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves Spaces buckets
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetSpacesBucketsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetSpacesKeyGrantResult(dict):
    def __init__(__self__, *,
                 bucket: _builtins.str,
                 permission: _builtins.str):
        """
        :param _builtins.str bucket: The name of the bucket to grant the key access to.
        :param _builtins.str permission: The permission to grant the key. Valid values are `read`, `readwrite`, or `fullaccess`.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The name of the bucket to grant the key access to.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter
    def permission(self) -> _builtins.str:
        """
        The permission to grant the key. Valid values are `read`, `readwrite`, or `fullaccess`.
        """
        return pulumi.get(self, "permission")


@pulumi.output_type
class GetSshKeysFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        :param Sequence[_builtins.str] values: A list of values to match against the key field. Only retrieves SSH keys where the key field matches one or more of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the key field. Only retrieves SSH keys where the key field matches one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetSshKeysSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetSshKeysSshKeyResult(dict):
    def __init__(__self__, *,
                 fingerprint: _builtins.str,
                 id: _builtins.int,
                 name: _builtins.str,
                 public_key: _builtins.str):
        """
        :param _builtins.str fingerprint: The fingerprint of the public key of the ssh key.
        :param _builtins.int id: The ID of the ssh key.
        :param _builtins.str name: The name of the ssh key.
        :param _builtins.str public_key: The public key of the ssh key.
        """
        pulumi.set(__self__, "fingerprint", fingerprint)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "public_key", public_key)

    @_builtins.property
    @pulumi.getter
    def fingerprint(self) -> _builtins.str:
        """
        The fingerprint of the public key of the ssh key.
        """
        return pulumi.get(self, "fingerprint")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.int:
        """
        The ID of the ssh key.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the ssh key.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> _builtins.str:
        """
        The public key of the ssh key.
        """
        return pulumi.get(self, "public_key")


@pulumi.output_type
class GetTagsFilterResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        :param Sequence[_builtins.str] values: Only retrieves tags which keys has value that matches
               one of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Only retrieves tags which keys has value that matches
        one of the values provided here.
        """
        return pulumi.get(self, "values")

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")


@pulumi.output_type
class GetTagsSortResult(dict):
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        return pulumi.get(self, "key")

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")


@pulumi.output_type
class GetTagsTagResult(dict):
    def __init__(__self__, *,
                 databases_count: _builtins.int,
                 droplets_count: _builtins.int,
                 images_count: _builtins.int,
                 name: _builtins.str,
                 total_resource_count: _builtins.int,
                 volume_snapshots_count: _builtins.int,
                 volumes_count: _builtins.int):
        """
        :param _builtins.int databases_count: A count of the database clusters that the tag is applied to.
        :param _builtins.int droplets_count: A count of the Droplets the tag is applied to.
        :param _builtins.int images_count: A count of the images that the tag is applied to.
        :param _builtins.str name: The name of the tag.
        :param _builtins.int total_resource_count: A count of the total number of resources that the tag is applied to.
        :param _builtins.int volume_snapshots_count: A count of the volume snapshots that the tag is applied to.
        :param _builtins.int volumes_count: A count of the volumes that the tag is applied to.
        """
        pulumi.set(__self__, "databases_count", databases_count)
        pulumi.set(__self__, "droplets_count", droplets_count)
        pulumi.set(__self__, "images_count", images_count)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "total_resource_count", total_resource_count)
        pulumi.set(__self__, "volume_snapshots_count", volume_snapshots_count)
        pulumi.set(__self__, "volumes_count", volumes_count)

    @_builtins.property
    @pulumi.getter(name="databasesCount")
    def databases_count(self) -> _builtins.int:
        """
        A count of the database clusters that the tag is applied to.
        """
        return pulumi.get(self, "databases_count")

    @_builtins.property
    @pulumi.getter(name="dropletsCount")
    def droplets_count(self) -> _builtins.int:
        """
        A count of the Droplets the tag is applied to.
        """
        return pulumi.get(self, "droplets_count")

    @_builtins.property
    @pulumi.getter(name="imagesCount")
    def images_count(self) -> _builtins.int:
        """
        A count of the images that the tag is applied to.
        """
        return pulumi.get(self, "images_count")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the tag.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="totalResourceCount")
    def total_resource_count(self) -> _builtins.int:
        """
        A count of the total number of resources that the tag is applied to.
        """
        return pulumi.get(self, "total_resource_count")

    @_builtins.property
    @pulumi.getter(name="volumeSnapshotsCount")
    def volume_snapshots_count(self) -> _builtins.int:
        """
        A count of the volume snapshots that the tag is applied to.
        """
        return pulumi.get(self, "volume_snapshots_count")

    @_builtins.property
    @pulumi.getter(name="volumesCount")
    def volumes_count(self) -> _builtins.int:
        """
        A count of the volumes that the tag is applied to.
        """
        return pulumi.get(self, "volumes_count")


@pulumi.output_type
class GetVpcNatGatewayEgressResult(dict):
    def __init__(__self__, *,
                 public_gateways: Sequence['outputs.GetVpcNatGatewayEgressPublicGatewayResult']):
        """
        :param Sequence['GetVpcNatGatewayEgressPublicGatewayArgs'] public_gateways: List of public gateway IPs
        """
        pulumi.set(__self__, "public_gateways", public_gateways)

    @_builtins.property
    @pulumi.getter(name="publicGateways")
    def public_gateways(self) -> Sequence['outputs.GetVpcNatGatewayEgressPublicGatewayResult']:
        """
        List of public gateway IPs
        """
        return pulumi.get(self, "public_gateways")


@pulumi.output_type
class GetVpcNatGatewayEgressPublicGatewayResult(dict):
    def __init__(__self__, *,
                 ipv4: _builtins.str):
        """
        :param _builtins.str ipv4: IPv4 address
        """
        pulumi.set(__self__, "ipv4", ipv4)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> _builtins.str:
        """
        IPv4 address
        """
        return pulumi.get(self, "ipv4")


@pulumi.output_type
class GetVpcNatGatewayVpcResult(dict):
    def __init__(__self__, *,
                 default_gateway: _builtins.bool,
                 gateway_ip: _builtins.str,
                 vpc_uuid: _builtins.str):
        """
        :param _builtins.bool default_gateway: Indicates if this is the default VPC NAT Gateway in the VPC
        :param _builtins.str gateway_ip: Gateway IP of the VPC NAT Gateway
        :param _builtins.str vpc_uuid: ID of the ingress VPC
        """
        pulumi.set(__self__, "default_gateway", default_gateway)
        pulumi.set(__self__, "gateway_ip", gateway_ip)
        pulumi.set(__self__, "vpc_uuid", vpc_uuid)

    @_builtins.property
    @pulumi.getter(name="defaultGateway")
    def default_gateway(self) -> _builtins.bool:
        """
        Indicates if this is the default VPC NAT Gateway in the VPC
        """
        return pulumi.get(self, "default_gateway")

    @_builtins.property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> _builtins.str:
        """
        Gateway IP of the VPC NAT Gateway
        """
        return pulumi.get(self, "gateway_ip")

    @_builtins.property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> _builtins.str:
        """
        ID of the ingress VPC
        """
        return pulumi.get(self, "vpc_uuid")


