# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from ._enums import *

__all__ = [
    'AppDedicatedIpArgs',
    'AppDedicatedIpArgsDict',
    'AppSpecArgs',
    'AppSpecArgsDict',
    'AppSpecAlertArgs',
    'AppSpecAlertArgsDict',
    'AppSpecAlertDestinationsArgs',
    'AppSpecAlertDestinationsArgsDict',
    'AppSpecAlertDestinationsSlackWebhookArgs',
    'AppSpecAlertDestinationsSlackWebhookArgsDict',
    'AppSpecDatabaseArgs',
    'AppSpecDatabaseArgsDict',
    'AppSpecDomainNameArgs',
    'AppSpecDomainNameArgsDict',
    'AppSpecEgressArgs',
    'AppSpecEgressArgsDict',
    'AppSpecEnvArgs',
    'AppSpecEnvArgsDict',
    'AppSpecFunctionArgs',
    'AppSpecFunctionArgsDict',
    'AppSpecFunctionAlertArgs',
    'AppSpecFunctionAlertArgsDict',
    'AppSpecFunctionAlertDestinationsArgs',
    'AppSpecFunctionAlertDestinationsArgsDict',
    'AppSpecFunctionAlertDestinationsSlackWebhookArgs',
    'AppSpecFunctionAlertDestinationsSlackWebhookArgsDict',
    'AppSpecFunctionBitbucketArgs',
    'AppSpecFunctionBitbucketArgsDict',
    'AppSpecFunctionCorsArgs',
    'AppSpecFunctionCorsArgsDict',
    'AppSpecFunctionCorsAllowOriginsArgs',
    'AppSpecFunctionCorsAllowOriginsArgsDict',
    'AppSpecFunctionEnvArgs',
    'AppSpecFunctionEnvArgsDict',
    'AppSpecFunctionGitArgs',
    'AppSpecFunctionGitArgsDict',
    'AppSpecFunctionGithubArgs',
    'AppSpecFunctionGithubArgsDict',
    'AppSpecFunctionGitlabArgs',
    'AppSpecFunctionGitlabArgsDict',
    'AppSpecFunctionLogDestinationArgs',
    'AppSpecFunctionLogDestinationArgsDict',
    'AppSpecFunctionLogDestinationDatadogArgs',
    'AppSpecFunctionLogDestinationDatadogArgsDict',
    'AppSpecFunctionLogDestinationLogtailArgs',
    'AppSpecFunctionLogDestinationLogtailArgsDict',
    'AppSpecFunctionLogDestinationOpenSearchArgs',
    'AppSpecFunctionLogDestinationOpenSearchArgsDict',
    'AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs',
    'AppSpecFunctionLogDestinationOpenSearchBasicAuthArgsDict',
    'AppSpecFunctionLogDestinationPapertrailArgs',
    'AppSpecFunctionLogDestinationPapertrailArgsDict',
    'AppSpecFunctionRouteArgs',
    'AppSpecFunctionRouteArgsDict',
    'AppSpecIngressArgs',
    'AppSpecIngressArgsDict',
    'AppSpecIngressRuleArgs',
    'AppSpecIngressRuleArgsDict',
    'AppSpecIngressRuleComponentArgs',
    'AppSpecIngressRuleComponentArgsDict',
    'AppSpecIngressRuleCorsArgs',
    'AppSpecIngressRuleCorsArgsDict',
    'AppSpecIngressRuleCorsAllowOriginsArgs',
    'AppSpecIngressRuleCorsAllowOriginsArgsDict',
    'AppSpecIngressRuleMatchArgs',
    'AppSpecIngressRuleMatchArgsDict',
    'AppSpecIngressRuleMatchPathArgs',
    'AppSpecIngressRuleMatchPathArgsDict',
    'AppSpecIngressRuleRedirectArgs',
    'AppSpecIngressRuleRedirectArgsDict',
    'AppSpecJobArgs',
    'AppSpecJobArgsDict',
    'AppSpecJobAlertArgs',
    'AppSpecJobAlertArgsDict',
    'AppSpecJobAlertDestinationsArgs',
    'AppSpecJobAlertDestinationsArgsDict',
    'AppSpecJobAlertDestinationsSlackWebhookArgs',
    'AppSpecJobAlertDestinationsSlackWebhookArgsDict',
    'AppSpecJobBitbucketArgs',
    'AppSpecJobBitbucketArgsDict',
    'AppSpecJobEnvArgs',
    'AppSpecJobEnvArgsDict',
    'AppSpecJobGitArgs',
    'AppSpecJobGitArgsDict',
    'AppSpecJobGithubArgs',
    'AppSpecJobGithubArgsDict',
    'AppSpecJobGitlabArgs',
    'AppSpecJobGitlabArgsDict',
    'AppSpecJobImageArgs',
    'AppSpecJobImageArgsDict',
    'AppSpecJobImageDeployOnPushArgs',
    'AppSpecJobImageDeployOnPushArgsDict',
    'AppSpecJobLogDestinationArgs',
    'AppSpecJobLogDestinationArgsDict',
    'AppSpecJobLogDestinationDatadogArgs',
    'AppSpecJobLogDestinationDatadogArgsDict',
    'AppSpecJobLogDestinationLogtailArgs',
    'AppSpecJobLogDestinationLogtailArgsDict',
    'AppSpecJobLogDestinationOpenSearchArgs',
    'AppSpecJobLogDestinationOpenSearchArgsDict',
    'AppSpecJobLogDestinationOpenSearchBasicAuthArgs',
    'AppSpecJobLogDestinationOpenSearchBasicAuthArgsDict',
    'AppSpecJobLogDestinationPapertrailArgs',
    'AppSpecJobLogDestinationPapertrailArgsDict',
    'AppSpecJobTerminationArgs',
    'AppSpecJobTerminationArgsDict',
    'AppSpecMaintenanceArgs',
    'AppSpecMaintenanceArgsDict',
    'AppSpecServiceArgs',
    'AppSpecServiceArgsDict',
    'AppSpecServiceAlertArgs',
    'AppSpecServiceAlertArgsDict',
    'AppSpecServiceAlertDestinationsArgs',
    'AppSpecServiceAlertDestinationsArgsDict',
    'AppSpecServiceAlertDestinationsSlackWebhookArgs',
    'AppSpecServiceAlertDestinationsSlackWebhookArgsDict',
    'AppSpecServiceAutoscalingArgs',
    'AppSpecServiceAutoscalingArgsDict',
    'AppSpecServiceAutoscalingMetricsArgs',
    'AppSpecServiceAutoscalingMetricsArgsDict',
    'AppSpecServiceAutoscalingMetricsCpuArgs',
    'AppSpecServiceAutoscalingMetricsCpuArgsDict',
    'AppSpecServiceBitbucketArgs',
    'AppSpecServiceBitbucketArgsDict',
    'AppSpecServiceCorsArgs',
    'AppSpecServiceCorsArgsDict',
    'AppSpecServiceCorsAllowOriginsArgs',
    'AppSpecServiceCorsAllowOriginsArgsDict',
    'AppSpecServiceEnvArgs',
    'AppSpecServiceEnvArgsDict',
    'AppSpecServiceGitArgs',
    'AppSpecServiceGitArgsDict',
    'AppSpecServiceGithubArgs',
    'AppSpecServiceGithubArgsDict',
    'AppSpecServiceGitlabArgs',
    'AppSpecServiceGitlabArgsDict',
    'AppSpecServiceHealthCheckArgs',
    'AppSpecServiceHealthCheckArgsDict',
    'AppSpecServiceImageArgs',
    'AppSpecServiceImageArgsDict',
    'AppSpecServiceImageDeployOnPushArgs',
    'AppSpecServiceImageDeployOnPushArgsDict',
    'AppSpecServiceLogDestinationArgs',
    'AppSpecServiceLogDestinationArgsDict',
    'AppSpecServiceLogDestinationDatadogArgs',
    'AppSpecServiceLogDestinationDatadogArgsDict',
    'AppSpecServiceLogDestinationLogtailArgs',
    'AppSpecServiceLogDestinationLogtailArgsDict',
    'AppSpecServiceLogDestinationOpenSearchArgs',
    'AppSpecServiceLogDestinationOpenSearchArgsDict',
    'AppSpecServiceLogDestinationOpenSearchBasicAuthArgs',
    'AppSpecServiceLogDestinationOpenSearchBasicAuthArgsDict',
    'AppSpecServiceLogDestinationPapertrailArgs',
    'AppSpecServiceLogDestinationPapertrailArgsDict',
    'AppSpecServiceRouteArgs',
    'AppSpecServiceRouteArgsDict',
    'AppSpecServiceTerminationArgs',
    'AppSpecServiceTerminationArgsDict',
    'AppSpecStaticSiteArgs',
    'AppSpecStaticSiteArgsDict',
    'AppSpecStaticSiteBitbucketArgs',
    'AppSpecStaticSiteBitbucketArgsDict',
    'AppSpecStaticSiteCorsArgs',
    'AppSpecStaticSiteCorsArgsDict',
    'AppSpecStaticSiteCorsAllowOriginsArgs',
    'AppSpecStaticSiteCorsAllowOriginsArgsDict',
    'AppSpecStaticSiteEnvArgs',
    'AppSpecStaticSiteEnvArgsDict',
    'AppSpecStaticSiteGitArgs',
    'AppSpecStaticSiteGitArgsDict',
    'AppSpecStaticSiteGithubArgs',
    'AppSpecStaticSiteGithubArgsDict',
    'AppSpecStaticSiteGitlabArgs',
    'AppSpecStaticSiteGitlabArgsDict',
    'AppSpecStaticSiteRouteArgs',
    'AppSpecStaticSiteRouteArgsDict',
    'AppSpecVpcArgs',
    'AppSpecVpcArgsDict',
    'AppSpecWorkerArgs',
    'AppSpecWorkerArgsDict',
    'AppSpecWorkerAlertArgs',
    'AppSpecWorkerAlertArgsDict',
    'AppSpecWorkerAlertDestinationsArgs',
    'AppSpecWorkerAlertDestinationsArgsDict',
    'AppSpecWorkerAlertDestinationsSlackWebhookArgs',
    'AppSpecWorkerAlertDestinationsSlackWebhookArgsDict',
    'AppSpecWorkerAutoscalingArgs',
    'AppSpecWorkerAutoscalingArgsDict',
    'AppSpecWorkerAutoscalingMetricsArgs',
    'AppSpecWorkerAutoscalingMetricsArgsDict',
    'AppSpecWorkerAutoscalingMetricsCpuArgs',
    'AppSpecWorkerAutoscalingMetricsCpuArgsDict',
    'AppSpecWorkerBitbucketArgs',
    'AppSpecWorkerBitbucketArgsDict',
    'AppSpecWorkerEnvArgs',
    'AppSpecWorkerEnvArgsDict',
    'AppSpecWorkerGitArgs',
    'AppSpecWorkerGitArgsDict',
    'AppSpecWorkerGithubArgs',
    'AppSpecWorkerGithubArgsDict',
    'AppSpecWorkerGitlabArgs',
    'AppSpecWorkerGitlabArgsDict',
    'AppSpecWorkerImageArgs',
    'AppSpecWorkerImageArgsDict',
    'AppSpecWorkerImageDeployOnPushArgs',
    'AppSpecWorkerImageDeployOnPushArgsDict',
    'AppSpecWorkerLogDestinationArgs',
    'AppSpecWorkerLogDestinationArgsDict',
    'AppSpecWorkerLogDestinationDatadogArgs',
    'AppSpecWorkerLogDestinationDatadogArgsDict',
    'AppSpecWorkerLogDestinationLogtailArgs',
    'AppSpecWorkerLogDestinationLogtailArgsDict',
    'AppSpecWorkerLogDestinationOpenSearchArgs',
    'AppSpecWorkerLogDestinationOpenSearchArgsDict',
    'AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs',
    'AppSpecWorkerLogDestinationOpenSearchBasicAuthArgsDict',
    'AppSpecWorkerLogDestinationPapertrailArgs',
    'AppSpecWorkerLogDestinationPapertrailArgsDict',
    'AppSpecWorkerTerminationArgs',
    'AppSpecWorkerTerminationArgsDict',
    'DatabaseClusterBackupRestoreArgs',
    'DatabaseClusterBackupRestoreArgsDict',
    'DatabaseClusterMaintenanceWindowArgs',
    'DatabaseClusterMaintenanceWindowArgsDict',
    'DatabaseFirewallRuleArgs',
    'DatabaseFirewallRuleArgsDict',
    'DatabaseKafkaTopicConfigArgs',
    'DatabaseKafkaTopicConfigArgsDict',
    'DatabaseOnlineMigrationSourceArgs',
    'DatabaseOnlineMigrationSourceArgsDict',
    'DatabasePostgresqlConfigPgbouncerArgs',
    'DatabasePostgresqlConfigPgbouncerArgsDict',
    'DatabasePostgresqlConfigTimescaledbArgs',
    'DatabasePostgresqlConfigTimescaledbArgsDict',
    'DatabaseUserSettingArgs',
    'DatabaseUserSettingArgsDict',
    'DatabaseUserSettingAclArgs',
    'DatabaseUserSettingAclArgsDict',
    'DatabaseUserSettingOpensearchAclArgs',
    'DatabaseUserSettingOpensearchAclArgsDict',
    'DropletAutoscaleConfigArgs',
    'DropletAutoscaleConfigArgsDict',
    'DropletAutoscaleCurrentUtilizationArgs',
    'DropletAutoscaleCurrentUtilizationArgsDict',
    'DropletAutoscaleDropletTemplateArgs',
    'DropletAutoscaleDropletTemplateArgsDict',
    'DropletBackupPolicyArgs',
    'DropletBackupPolicyArgsDict',
    'FirewallInboundRuleArgs',
    'FirewallInboundRuleArgsDict',
    'FirewallOutboundRuleArgs',
    'FirewallOutboundRuleArgsDict',
    'FirewallPendingChangeArgs',
    'FirewallPendingChangeArgsDict',
    'GenaiAgentAgentGuardrailArgs',
    'GenaiAgentAgentGuardrailArgsDict',
    'GenaiAgentAnthropicApiKeyArgs',
    'GenaiAgentAnthropicApiKeyArgsDict',
    'GenaiAgentApiKeyArgs',
    'GenaiAgentApiKeyArgsDict',
    'GenaiAgentApiKeyInfoArgs',
    'GenaiAgentApiKeyInfoArgsDict',
    'GenaiAgentChatbotArgs',
    'GenaiAgentChatbotArgsDict',
    'GenaiAgentChatbotIdentifierArgs',
    'GenaiAgentChatbotIdentifierArgsDict',
    'GenaiAgentChildAgentArgs',
    'GenaiAgentChildAgentArgsDict',
    'GenaiAgentChildAgentAnthropicApiKeyArgs',
    'GenaiAgentChildAgentAnthropicApiKeyArgsDict',
    'GenaiAgentChildAgentApiKeyArgs',
    'GenaiAgentChildAgentApiKeyArgsDict',
    'GenaiAgentChildAgentApiKeyInfoArgs',
    'GenaiAgentChildAgentApiKeyInfoArgsDict',
    'GenaiAgentChildAgentChatbotArgs',
    'GenaiAgentChildAgentChatbotArgsDict',
    'GenaiAgentChildAgentChatbotIdentifierArgs',
    'GenaiAgentChildAgentChatbotIdentifierArgsDict',
    'GenaiAgentChildAgentDeploymentArgs',
    'GenaiAgentChildAgentDeploymentArgsDict',
    'GenaiAgentDeploymentArgs',
    'GenaiAgentDeploymentArgsDict',
    'GenaiAgentFunctionArgs',
    'GenaiAgentFunctionArgsDict',
    'GenaiAgentKnowledgeBaseArgs',
    'GenaiAgentKnowledgeBaseArgsDict',
    'GenaiAgentKnowledgeBaseLastIndexingJobArgs',
    'GenaiAgentKnowledgeBaseLastIndexingJobArgsDict',
    'GenaiAgentModelArgs',
    'GenaiAgentModelArgsDict',
    'GenaiAgentModelAgreementArgs',
    'GenaiAgentModelAgreementArgsDict',
    'GenaiAgentModelVersionArgs',
    'GenaiAgentModelVersionArgsDict',
    'GenaiAgentOpenAiApiKeyArgs',
    'GenaiAgentOpenAiApiKeyArgsDict',
    'GenaiAgentParentAgentArgs',
    'GenaiAgentParentAgentArgsDict',
    'GenaiAgentParentAgentAnthropicApiKeyArgs',
    'GenaiAgentParentAgentAnthropicApiKeyArgsDict',
    'GenaiAgentParentAgentApiKeyArgs',
    'GenaiAgentParentAgentApiKeyArgsDict',
    'GenaiAgentParentAgentApiKeyInfoArgs',
    'GenaiAgentParentAgentApiKeyInfoArgsDict',
    'GenaiAgentParentAgentChatbotArgs',
    'GenaiAgentParentAgentChatbotArgsDict',
    'GenaiAgentParentAgentChatbotIdentifierArgs',
    'GenaiAgentParentAgentChatbotIdentifierArgsDict',
    'GenaiAgentParentAgentDeploymentArgs',
    'GenaiAgentParentAgentDeploymentArgsDict',
    'GenaiAgentTemplateArgs',
    'GenaiAgentTemplateArgsDict',
    'GenaiAgentTemplateKnowledgeBaseArgs',
    'GenaiAgentTemplateKnowledgeBaseArgsDict',
    'GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs',
    'GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgsDict',
    'GenaiAgentTemplateModelArgs',
    'GenaiAgentTemplateModelArgsDict',
    'GenaiAgentTemplateModelAgreementArgs',
    'GenaiAgentTemplateModelAgreementArgsDict',
    'GenaiAgentTemplateModelVersionArgs',
    'GenaiAgentTemplateModelVersionArgsDict',
    'GenaiKnowledgeBaseDataSourceArgs',
    'GenaiKnowledgeBaseDataSourceArgsDict',
    'GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgs',
    'GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgsDict',
    'GenaiKnowledgeBaseDataSourceLastIndexingJobArgs',
    'GenaiKnowledgeBaseDataSourceLastIndexingJobArgsDict',
    'GenaiKnowledgeBaseDataSourceSpacesDataSourceArgs',
    'GenaiKnowledgeBaseDataSourceSpacesDataSourceArgsDict',
    'GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgs',
    'GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgsDict',
    'GenaiKnowledgeBaseLastIndexingJobArgs',
    'GenaiKnowledgeBaseLastIndexingJobArgsDict',
    'GenaiOpenaiApiKeyModelArgs',
    'GenaiOpenaiApiKeyModelArgsDict',
    'GenaiOpenaiApiKeyModelAgreementArgs',
    'GenaiOpenaiApiKeyModelAgreementArgsDict',
    'GenaiOpenaiApiKeyModelVersionArgs',
    'GenaiOpenaiApiKeyModelVersionArgsDict',
    'KubernetesClusterClusterAutoscalerConfigurationArgs',
    'KubernetesClusterClusterAutoscalerConfigurationArgsDict',
    'KubernetesClusterControlPlaneFirewallArgs',
    'KubernetesClusterControlPlaneFirewallArgsDict',
    'KubernetesClusterKubeConfigArgs',
    'KubernetesClusterKubeConfigArgsDict',
    'KubernetesClusterMaintenancePolicyArgs',
    'KubernetesClusterMaintenancePolicyArgsDict',
    'KubernetesClusterNodePoolArgs',
    'KubernetesClusterNodePoolArgsDict',
    'KubernetesClusterNodePoolNodeArgs',
    'KubernetesClusterNodePoolNodeArgsDict',
    'KubernetesClusterNodePoolTaintArgs',
    'KubernetesClusterNodePoolTaintArgsDict',
    'KubernetesClusterRoutingAgentArgs',
    'KubernetesClusterRoutingAgentArgsDict',
    'KubernetesNodePoolNodeArgs',
    'KubernetesNodePoolNodeArgsDict',
    'KubernetesNodePoolTaintArgs',
    'KubernetesNodePoolTaintArgsDict',
    'LoadBalancerDomainArgs',
    'LoadBalancerDomainArgsDict',
    'LoadBalancerFirewallArgs',
    'LoadBalancerFirewallArgsDict',
    'LoadBalancerForwardingRuleArgs',
    'LoadBalancerForwardingRuleArgsDict',
    'LoadBalancerGlbSettingsArgs',
    'LoadBalancerGlbSettingsArgsDict',
    'LoadBalancerGlbSettingsCdnArgs',
    'LoadBalancerGlbSettingsCdnArgsDict',
    'LoadBalancerHealthcheckArgs',
    'LoadBalancerHealthcheckArgsDict',
    'LoadBalancerStickySessionsArgs',
    'LoadBalancerStickySessionsArgsDict',
    'MonitorAlertAlertsArgs',
    'MonitorAlertAlertsArgsDict',
    'MonitorAlertAlertsSlackArgs',
    'MonitorAlertAlertsSlackArgsDict',
    'PartnerAttachmentBgpArgs',
    'PartnerAttachmentBgpArgsDict',
    'SpacesBucketCorsConfigurationCorsRuleArgs',
    'SpacesBucketCorsConfigurationCorsRuleArgsDict',
    'SpacesBucketCorsRuleArgs',
    'SpacesBucketCorsRuleArgsDict',
    'SpacesBucketLifecycleRuleArgs',
    'SpacesBucketLifecycleRuleArgsDict',
    'SpacesBucketLifecycleRuleExpirationArgs',
    'SpacesBucketLifecycleRuleExpirationArgsDict',
    'SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs',
    'SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgsDict',
    'SpacesBucketVersioningArgs',
    'SpacesBucketVersioningArgsDict',
    'SpacesKeyGrantArgs',
    'SpacesKeyGrantArgsDict',
    'UptimeAlertNotificationArgs',
    'UptimeAlertNotificationArgsDict',
    'UptimeAlertNotificationSlackArgs',
    'UptimeAlertNotificationSlackArgsDict',
    'VpcNatGatewayEgressArgs',
    'VpcNatGatewayEgressArgsDict',
    'VpcNatGatewayEgressPublicGatewayArgs',
    'VpcNatGatewayEgressPublicGatewayArgsDict',
    'VpcNatGatewayVpcArgs',
    'VpcNatGatewayVpcArgsDict',
    'GetAppDedicatedIpArgs',
    'GetAppDedicatedIpArgsDict',
    'GetDomainsFilterArgs',
    'GetDomainsFilterArgsDict',
    'GetDomainsSortArgs',
    'GetDomainsSortArgsDict',
    'GetDropletsFilterArgs',
    'GetDropletsFilterArgsDict',
    'GetDropletsSortArgs',
    'GetDropletsSortArgsDict',
    'GetFirewallInboundRuleArgs',
    'GetFirewallInboundRuleArgsDict',
    'GetFirewallOutboundRuleArgs',
    'GetFirewallOutboundRuleArgsDict',
    'GetGenaiAgentAgentGuardrailArgs',
    'GetGenaiAgentAgentGuardrailArgsDict',
    'GetGenaiAgentAnthropicApiKeyArgs',
    'GetGenaiAgentAnthropicApiKeyArgsDict',
    'GetGenaiAgentApiKeyArgs',
    'GetGenaiAgentApiKeyArgsDict',
    'GetGenaiAgentApiKeyInfoArgs',
    'GetGenaiAgentApiKeyInfoArgsDict',
    'GetGenaiAgentChatbotArgs',
    'GetGenaiAgentChatbotArgsDict',
    'GetGenaiAgentChatbotIdentifierArgs',
    'GetGenaiAgentChatbotIdentifierArgsDict',
    'GetGenaiAgentDeploymentArgs',
    'GetGenaiAgentDeploymentArgsDict',
    'GetGenaiAgentFunctionArgs',
    'GetGenaiAgentFunctionArgsDict',
    'GetGenaiAgentKnowledgeBaseArgs',
    'GetGenaiAgentKnowledgeBaseArgsDict',
    'GetGenaiAgentKnowledgeBaseLastIndexingJobArgs',
    'GetGenaiAgentKnowledgeBaseLastIndexingJobArgsDict',
    'GetGenaiAgentModelArgs',
    'GetGenaiAgentModelArgsDict',
    'GetGenaiAgentModelAgreementArgs',
    'GetGenaiAgentModelAgreementArgsDict',
    'GetGenaiAgentModelVersionArgs',
    'GetGenaiAgentModelVersionArgsDict',
    'GetGenaiAgentOpenAiApiKeyArgs',
    'GetGenaiAgentOpenAiApiKeyArgsDict',
    'GetGenaiAgentTemplateArgs',
    'GetGenaiAgentTemplateArgsDict',
    'GetGenaiAgentTemplateKnowledgeBaseArgs',
    'GetGenaiAgentTemplateKnowledgeBaseArgsDict',
    'GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs',
    'GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgsDict',
    'GetGenaiAgentTemplateModelArgs',
    'GetGenaiAgentTemplateModelArgsDict',
    'GetGenaiAgentTemplateModelAgreementArgs',
    'GetGenaiAgentTemplateModelAgreementArgsDict',
    'GetGenaiAgentTemplateModelVersionArgs',
    'GetGenaiAgentTemplateModelVersionArgsDict',
    'GetGenaiAgentVersionsFilterArgs',
    'GetGenaiAgentVersionsFilterArgsDict',
    'GetGenaiAgentVersionsSortArgs',
    'GetGenaiAgentVersionsSortArgsDict',
    'GetGenaiAgentsFilterArgs',
    'GetGenaiAgentsFilterArgsDict',
    'GetGenaiAgentsSortArgs',
    'GetGenaiAgentsSortArgsDict',
    'GetGenaiKnowledgeBaseLastIndexingJobArgs',
    'GetGenaiKnowledgeBaseLastIndexingJobArgsDict',
    'GetGenaiKnowledgeBasesFilterArgs',
    'GetGenaiKnowledgeBasesFilterArgsDict',
    'GetGenaiKnowledgeBasesSortArgs',
    'GetGenaiKnowledgeBasesSortArgsDict',
    'GetGenaiOpenaiApiKeysFilterArgs',
    'GetGenaiOpenaiApiKeysFilterArgsDict',
    'GetGenaiOpenaiApiKeysSortArgs',
    'GetGenaiOpenaiApiKeysSortArgsDict',
    'GetImagesFilterArgs',
    'GetImagesFilterArgsDict',
    'GetImagesSortArgs',
    'GetImagesSortArgsDict',
    'GetKubernetesClusterClusterAutoscalerConfigurationArgs',
    'GetKubernetesClusterClusterAutoscalerConfigurationArgsDict',
    'GetKubernetesClusterRoutingAgentArgs',
    'GetKubernetesClusterRoutingAgentArgsDict',
    'GetPartnerAttachmentBgpArgs',
    'GetPartnerAttachmentBgpArgsDict',
    'GetProjectsFilterArgs',
    'GetProjectsFilterArgsDict',
    'GetProjectsSortArgs',
    'GetProjectsSortArgsDict',
    'GetRecordsFilterArgs',
    'GetRecordsFilterArgsDict',
    'GetRecordsSortArgs',
    'GetRecordsSortArgsDict',
    'GetRegionsFilterArgs',
    'GetRegionsFilterArgsDict',
    'GetRegionsSortArgs',
    'GetRegionsSortArgsDict',
    'GetSizesFilterArgs',
    'GetSizesFilterArgsDict',
    'GetSizesSortArgs',
    'GetSizesSortArgsDict',
    'GetSpacesBucketsFilterArgs',
    'GetSpacesBucketsFilterArgsDict',
    'GetSpacesBucketsSortArgs',
    'GetSpacesBucketsSortArgsDict',
    'GetSshKeysFilterArgs',
    'GetSshKeysFilterArgsDict',
    'GetSshKeysSortArgs',
    'GetSshKeysSortArgsDict',
    'GetTagsFilterArgs',
    'GetTagsFilterArgsDict',
    'GetTagsSortArgs',
    'GetTagsSortArgsDict',
]

MYPY = False

if not MYPY:
    class AppDedicatedIpArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the app.
        """
        ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP address of the dedicated egress IP.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
        """
elif False:
    AppDedicatedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDedicatedIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 ip: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the app.
        :param pulumi.Input[_builtins.str] ip: The IP address of the dedicated egress IP.
        :param pulumi.Input[_builtins.str] status: The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the app.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP address of the dedicated egress IP.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class AppSpecArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecDatabaseArgsDict']]]]
        disable_edge_cache: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A boolean indicating whether to disable the edge cache for this app. Default: `false`. Available only for non-static sites. Requires custom domains and applies to all the domains of the app.
        """
        disable_email_obfuscation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A boolean indicating whether to disable email obfuscation for this app. Default: `false`. Requires custom domains and applies to all the domains of the app.
        """
        domain_names: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgsDict']]]]
        """
        Describes a domain where the application will be made available.
        """
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        egresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgsDict']]]]
        """
        Specification for app egress configurations.
        """
        enhanced_threat_control_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A boolean, when set to `true`, enables enhanced analyzing of incoming traffic to prevent layer 7 DDoS attacks. Default: `false`. Requires custom domains and applies to all the domains of the app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        features: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/reference/apps/list-buildpacks/)
        """
        functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionArgsDict']]]]
        ingress: NotRequired[pulumi.Input['AppSpecIngressArgsDict']]
        """
        Specification for component routing, rewrites, and redirects.
        """
        jobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobArgsDict']]]]
        maintenance: NotRequired[pulumi.Input['AppSpecMaintenanceArgsDict']]
        """
        Specification to configure maintenance settings for the app, such as maintenance mode and archiving the app.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The slug for the DigitalOcean data center region hosting the app.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceArgsDict']]]]
        static_sites: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteArgsDict']]]]
        vpcs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecVpcArgsDict']]]]
        """
        Specification for VPC.
        """
        workers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerArgsDict']]]]
elif False:
    AppSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgs']]]] = None,
                 databases: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDatabaseArgs']]]] = None,
                 disable_edge_cache: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_email_obfuscation: Optional[pulumi.Input[_builtins.bool]] = None,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgs']]]] = None,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 egresses: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgs']]]] = None,
                 enhanced_threat_control_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgs']]]] = None,
                 features: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 functions: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionArgs']]]] = None,
                 ingress: Optional[pulumi.Input['AppSpecIngressArgs']] = None,
                 jobs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobArgs']]]] = None,
                 maintenance: Optional[pulumi.Input['AppSpecMaintenanceArgs']] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceArgs']]]] = None,
                 static_sites: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteArgs']]]] = None,
                 vpcs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecVpcArgs']]]] = None,
                 workers: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input[_builtins.bool] disable_edge_cache: A boolean indicating whether to disable the edge cache for this app. Default: `false`. Available only for non-static sites. Requires custom domains and applies to all the domains of the app.
        :param pulumi.Input[_builtins.bool] disable_email_obfuscation: A boolean indicating whether to disable email obfuscation for this app. Default: `false`. Requires custom domains and applies to all the domains of the app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgs']]] domain_names: Describes a domain where the application will be made available.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgs']]] egresses: Specification for app egress configurations.
        :param pulumi.Input[_builtins.bool] enhanced_threat_control_enabled: A boolean, when set to `true`, enables enhanced analyzing of incoming traffic to prevent layer 7 DDoS attacks. Default: `false`. Requires custom domains and applies to all the domains of the app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] features: A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/reference/apps/list-buildpacks/)
        :param pulumi.Input['AppSpecIngressArgs'] ingress: Specification for component routing, rewrites, and redirects.
        :param pulumi.Input['AppSpecMaintenanceArgs'] maintenance: Specification to configure maintenance settings for the app, such as maintenance mode and archiving the app.
        :param pulumi.Input[_builtins.str] region: The slug for the DigitalOcean data center region hosting the app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecVpcArgs']]] vpcs: Specification for VPC.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if disable_edge_cache is not None:
            pulumi.set(__self__, "disable_edge_cache", disable_edge_cache)
        if disable_email_obfuscation is not None:
            pulumi.set(__self__, "disable_email_obfuscation", disable_email_obfuscation)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if domains is not None:
            warnings.warn("""This attribute has been replaced by `domain` which supports additional functionality.""", DeprecationWarning)
            pulumi.log.warn("""domains is deprecated: This attribute has been replaced by `domain` which supports additional functionality.""")
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if egresses is not None:
            pulumi.set(__self__, "egresses", egresses)
        if enhanced_threat_control_enabled is not None:
            pulumi.set(__self__, "enhanced_threat_control_enabled", enhanced_threat_control_enabled)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if maintenance is not None:
            pulumi.set(__self__, "maintenance", maintenance)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if static_sites is not None:
            pulumi.set(__self__, "static_sites", static_sites)
        if vpcs is not None:
            pulumi.set(__self__, "vpcs", vpcs)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDatabaseArgs']]]]:
        return pulumi.get(self, "databases")

    @databases.setter
    def databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDatabaseArgs']]]]):
        pulumi.set(self, "databases", value)

    @_builtins.property
    @pulumi.getter(name="disableEdgeCache")
    def disable_edge_cache(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A boolean indicating whether to disable the edge cache for this app. Default: `false`. Available only for non-static sites. Requires custom domains and applies to all the domains of the app.
        """
        return pulumi.get(self, "disable_edge_cache")

    @disable_edge_cache.setter
    def disable_edge_cache(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_edge_cache", value)

    @_builtins.property
    @pulumi.getter(name="disableEmailObfuscation")
    def disable_email_obfuscation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A boolean indicating whether to disable email obfuscation for this app. Default: `false`. Requires custom domains and applies to all the domains of the app.
        """
        return pulumi.get(self, "disable_email_obfuscation")

    @disable_email_obfuscation.setter
    def disable_email_obfuscation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_email_obfuscation", value)

    @_builtins.property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgs']]]]:
        """
        Describes a domain where the application will be made available.
        """
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgs']]]]):
        pulumi.set(self, "domain_names", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""This attribute has been replaced by `domain` which supports additional functionality.""")
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "domains", value)

    @_builtins.property
    @pulumi.getter
    def egresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgs']]]]:
        """
        Specification for app egress configurations.
        """
        return pulumi.get(self, "egresses")

    @egresses.setter
    def egresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgs']]]]):
        pulumi.set(self, "egresses", value)

    @_builtins.property
    @pulumi.getter(name="enhancedThreatControlEnabled")
    def enhanced_threat_control_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A boolean, when set to `true`, enables enhanced analyzing of incoming traffic to prevent layer 7 DDoS attacks. Default: `false`. Requires custom domains and applies to all the domains of the app.
        """
        return pulumi.get(self, "enhanced_threat_control_enabled")

    @enhanced_threat_control_enabled.setter
    def enhanced_threat_control_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enhanced_threat_control_enabled", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/reference/apps/list-buildpacks/)
        """
        return pulumi.get(self, "features")

    @features.setter
    def features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "features", value)

    @_builtins.property
    @pulumi.getter
    def functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionArgs']]]]:
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionArgs']]]]):
        pulumi.set(self, "functions", value)

    @_builtins.property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input['AppSpecIngressArgs']]:
        """
        Specification for component routing, rewrites, and redirects.
        """
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input['AppSpecIngressArgs']]):
        pulumi.set(self, "ingress", value)

    @_builtins.property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobArgs']]]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobArgs']]]]):
        pulumi.set(self, "jobs", value)

    @_builtins.property
    @pulumi.getter
    def maintenance(self) -> Optional[pulumi.Input['AppSpecMaintenanceArgs']]:
        """
        Specification to configure maintenance settings for the app, such as maintenance mode and archiving the app.
        """
        return pulumi.get(self, "maintenance")

    @maintenance.setter
    def maintenance(self, value: Optional[pulumi.Input['AppSpecMaintenanceArgs']]):
        pulumi.set(self, "maintenance", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The slug for the DigitalOcean data center region hosting the app.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceArgs']]]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceArgs']]]]):
        pulumi.set(self, "services", value)

    @_builtins.property
    @pulumi.getter(name="staticSites")
    def static_sites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteArgs']]]]:
        return pulumi.get(self, "static_sites")

    @static_sites.setter
    def static_sites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteArgs']]]]):
        pulumi.set(self, "static_sites", value)

    @_builtins.property
    @pulumi.getter
    def vpcs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecVpcArgs']]]]:
        """
        Specification for VPC.
        """
        return pulumi.get(self, "vpcs")

    @vpcs.setter
    def vpcs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecVpcArgs']]]]):
        pulumi.set(self, "vpcs", value)

    @_builtins.property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerArgs']]]]:
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerArgs']]]]):
        pulumi.set(self, "workers", value)


if not MYPY:
    class AppSpecAlertArgsDict(TypedDict):
        rule: pulumi.Input[_builtins.str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        destinations: NotRequired[pulumi.Input['AppSpecAlertDestinationsArgsDict']]
        """
        Specification for alert destination.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecAlertArgs:
    def __init__(__self__, *,
                 rule: pulumi.Input[_builtins.str],
                 destinations: Optional[pulumi.Input['AppSpecAlertDestinationsArgs']] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input['AppSpecAlertDestinationsArgs'] destinations: Specification for alert destination.
        :param pulumi.Input[_builtins.bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "rule", rule)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input['AppSpecAlertDestinationsArgs']]:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input['AppSpecAlertDestinationsArgs']]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecAlertDestinationsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        slack_webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertDestinationsSlackWebhookArgsDict']]]]
        """
        Determines which slack channels or users receive alerts.
        """
elif False:
    AppSpecAlertDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecAlertDestinationsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slack_webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertDestinationsSlackWebhookArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecAlertDestinationsSlackWebhookArgs']]] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertDestinationsSlackWebhookArgs']]]]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")

    @slack_webhooks.setter
    def slack_webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertDestinationsSlackWebhookArgs']]]]):
        pulumi.set(self, "slack_webhooks", value)


if not MYPY:
    class AppSpecAlertDestinationsSlackWebhookArgsDict(TypedDict):
        channel: pulumi.Input[_builtins.str]
        """
        The Slack channel to send notifications to.
        """
        url: pulumi.Input[_builtins.str]
        """
        The Slack webhook URL.
        """
elif False:
    AppSpecAlertDestinationsSlackWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecAlertDestinationsSlackWebhookArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] channel: The Slack channel to send notifications to.
        :param pulumi.Input[_builtins.str] url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AppSpecDatabaseArgsDict(TypedDict):
        cluster_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        db_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the MySQL or PostgreSQL database to configure.
        """
        db_user: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the MySQL or PostgreSQL user to configure.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        engine: NotRequired[pulumi.Input[_builtins.str]]
        """
        The database engine to use (`MYSQL`, `PG`, `REDIS`, `MONGODB`, `KAFKA`, or `OPENSEARCH`).
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the component.
        """
        production: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether this is a production or dev database.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the database engine.
        """
elif False:
    AppSpecDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecDatabaseArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 db_name: Optional[pulumi.Input[_builtins.str]] = None,
                 db_user: Optional[pulumi.Input[_builtins.str]] = None,
                 engine: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 production: Optional[pulumi.Input[_builtins.bool]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[_builtins.str] db_name: The name of the MySQL or PostgreSQL database to configure.
        :param pulumi.Input[_builtins.str] db_user: The name of the MySQL or PostgreSQL user to configure.
               
               This resource supports customized create timeouts. The default timeout is 30 minutes.
        :param pulumi.Input[_builtins.str] engine: The database engine to use (`MYSQL`, `PG`, `REDIS`, `MONGODB`, `KAFKA`, or `OPENSEARCH`).
        :param pulumi.Input[_builtins.str] name: The name of the component.
        :param pulumi.Input[_builtins.bool] production: Whether this is a production or dev database.
        :param pulumi.Input[_builtins.str] version: The version of the database engine.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if production is not None:
            pulumi.set(__self__, "production", production)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the MySQL or PostgreSQL database to configure.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_name", value)

    @_builtins.property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the MySQL or PostgreSQL user to configure.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        return pulumi.get(self, "db_user")

    @db_user.setter
    def db_user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "db_user", value)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The database engine to use (`MYSQL`, `PG`, `REDIS`, `MONGODB`, `KAFKA`, or `OPENSEARCH`).
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "engine", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def production(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether this is a production or dev database.
        """
        return pulumi.get(self, "production")

    @production.setter
    def production(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "production", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the database engine.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class AppSpecDomainNameArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The hostname for the domain.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The domain type, which can be one of the following:
        - `DEFAULT`: The default .ondigitalocean.app domain assigned to this app.
        - `PRIMARY`: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
        - `ALIAS`: A non-primary domain.
        """
        wildcard: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
        """
        zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
elif False:
    AppSpecDomainNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecDomainNameArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 wildcard: Optional[pulumi.Input[_builtins.bool]] = None,
                 zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The hostname for the domain.
        :param pulumi.Input[_builtins.str] type: The domain type, which can be one of the following:
               - `DEFAULT`: The default .ondigitalocean.app domain assigned to this app.
               - `PRIMARY`: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
               - `ALIAS`: A non-primary domain.
        :param pulumi.Input[_builtins.bool] wildcard: A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
        :param pulumi.Input[_builtins.str] zone: If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
        pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The hostname for the domain.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The domain type, which can be one of the following:
        - `DEFAULT`: The default .ondigitalocean.app domain assigned to this app.
        - `PRIMARY`: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
        - `ALIAS`: A non-primary domain.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wildcard", value)

    @_builtins.property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class AppSpecEgressArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The app egress type: `AUTOASSIGN`, `DEDICATED_IP`
        """
elif False:
    AppSpecEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecEgressArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The app egress type: `AUTOASSIGN`, `DEDICATED_IP`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The app egress type: `AUTOASSIGN`, `DEDICATED_IP`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppSpecEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the environment variable.
        :param pulumi.Input[_builtins.str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[_builtins.str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[_builtins.str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecFunctionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        bitbucket: NotRequired[pulumi.Input['AppSpecFunctionBitbucketArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        cors: NotRequired[pulumi.Input['AppSpecFunctionCorsArgsDict']]
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        git: NotRequired[pulumi.Input['AppSpecFunctionGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecFunctionGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecFunctionGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        log_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgsDict']]]]
        """
        Describes a log forwarding destination.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgsDict']]]]
        """
        An HTTP paths that should be routed to this component.
        """
        source_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional path to the working directory to use for the build.
        """
elif False:
    AppSpecFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgs']]]] = None,
                 bitbucket: Optional[pulumi.Input['AppSpecFunctionBitbucketArgs']] = None,
                 cors: Optional[pulumi.Input['AppSpecFunctionCorsArgs']] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgs']]]] = None,
                 git: Optional[pulumi.Input['AppSpecFunctionGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecFunctionGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecFunctionGitlabArgs']] = None,
                 log_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgs']]]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgs']]]] = None,
                 source_dir: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input['AppSpecFunctionBitbucketArgs'] bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecFunctionCorsArgs'] cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input['AppSpecFunctionGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecFunctionGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecFunctionGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgs']]] log_destinations: Describes a log forwarding destination.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgs']]] routes: An HTTP paths that should be routed to this component.
        :param pulumi.Input[_builtins.str] source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if cors is not None:
            warnings.warn("""Service level CORS rules are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""cors is deprecated: Service level CORS rules are deprecated in favor of ingresses""")
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if routes is not None:
            warnings.warn("""Service level routes are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""routes is deprecated: Service level routes are deprecated in favor of ingresses""")
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional[pulumi.Input['AppSpecFunctionBitbucketArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @bitbucket.setter
    def bitbucket(self, value: Optional[pulumi.Input['AppSpecFunctionBitbucketArgs']]):
        pulumi.set(self, "bitbucket", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional[pulumi.Input['AppSpecFunctionCorsArgs']]:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppSpecFunctionCorsArgs']]):
        pulumi.set(self, "cors", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecFunctionGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecFunctionGitArgs']]):
        pulumi.set(self, "git", value)

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecFunctionGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecFunctionGithubArgs']]):
        pulumi.set(self, "github", value)

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecFunctionGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecFunctionGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgs']]]]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @log_destinations.setter
    def log_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgs']]]]):
        pulumi.set(self, "log_destinations", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgs']]]]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_dir", value)


if not MYPY:
    class AppSpecFunctionAlertArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        rule: pulumi.Input[_builtins.str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        value: pulumi.Input[_builtins.float]
        """
        The threshold for the type of the warning.
        """
        window: pulumi.Input[_builtins.str]
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        destinations: NotRequired[pulumi.Input['AppSpecFunctionAlertDestinationsArgsDict']]
        """
        Specification for alert destination.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecFunctionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionAlertArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 rule: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.float],
                 window: pulumi.Input[_builtins.str],
                 destinations: Optional[pulumi.Input['AppSpecFunctionAlertDestinationsArgs']] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param pulumi.Input[_builtins.str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[_builtins.float] value: The threshold for the type of the warning.
        :param pulumi.Input[_builtins.str] window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param pulumi.Input['AppSpecFunctionAlertDestinationsArgs'] destinations: Specification for alert destination.
        :param pulumi.Input[_builtins.bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.float]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def window(self) -> pulumi.Input[_builtins.str]:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "window", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input['AppSpecFunctionAlertDestinationsArgs']]:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input['AppSpecFunctionAlertDestinationsArgs']]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecFunctionAlertDestinationsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        slack_webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertDestinationsSlackWebhookArgsDict']]]]
        """
        Determines which slack channels or users receive alerts.
        """
elif False:
    AppSpecFunctionAlertDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionAlertDestinationsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slack_webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertDestinationsSlackWebhookArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertDestinationsSlackWebhookArgs']]] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertDestinationsSlackWebhookArgs']]]]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")

    @slack_webhooks.setter
    def slack_webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertDestinationsSlackWebhookArgs']]]]):
        pulumi.set(self, "slack_webhooks", value)


if not MYPY:
    class AppSpecFunctionAlertDestinationsSlackWebhookArgsDict(TypedDict):
        channel: pulumi.Input[_builtins.str]
        """
        The Slack channel to send notifications to.
        """
        url: pulumi.Input[_builtins.str]
        """
        The Slack webhook URL.
        """
elif False:
    AppSpecFunctionAlertDestinationsSlackWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionAlertDestinationsSlackWebhookArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] channel: The Slack channel to send notifications to.
        :param pulumi.Input[_builtins.str] url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AppSpecFunctionBitbucketArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecFunctionBitbucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionBitbucketArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecFunctionCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        allow_origins: NotRequired[pulumi.Input['AppSpecFunctionCorsAllowOriginsArgsDict']]
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        max_age: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
elif False:
    AppSpecFunctionCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input['AppSpecFunctionCorsAllowOriginsArgs']] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param pulumi.Input['AppSpecFunctionCorsAllowOriginsArgs'] allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param pulumi.Input[_builtins.str] max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input['AppSpecFunctionCorsAllowOriginsArgs']]:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input['AppSpecFunctionCorsAllowOriginsArgs']]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AppSpecFunctionCorsAllowOriginsArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        Exact string match.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix-based match.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        RE2 style regex-based match.
        """
elif False:
    AppSpecFunctionCorsAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionCorsAllowOriginsArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exact: Exact string match.
        :param pulumi.Input[_builtins.str] prefix: Prefix-based match.
        :param pulumi.Input[_builtins.str] regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            warnings.warn("""Prefix-based matching has been deprecated in favor of regex-based matching.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Prefix-based matching has been deprecated in favor of regex-based matching.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AppSpecFunctionEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecFunctionEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the environment variable.
        :param pulumi.Input[_builtins.str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[_builtins.str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[_builtins.str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecFunctionGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecFunctionGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 repo_clone_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecFunctionGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecFunctionGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecFunctionGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecFunctionGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecFunctionLogDestinationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        datadog: NotRequired[pulumi.Input['AppSpecFunctionLogDestinationDatadogArgsDict']]
        """
        Datadog configuration.
        """
        logtail: NotRequired[pulumi.Input['AppSpecFunctionLogDestinationLogtailArgsDict']]
        """
        Logtail configuration.
        """
        open_search: NotRequired[pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgsDict']]
        """
        OpenSearch configuration.
        """
        papertrail: NotRequired[pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgsDict']]
        """
        Papertrail configuration.
        """
elif False:
    AppSpecFunctionLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 datadog: Optional[pulumi.Input['AppSpecFunctionLogDestinationDatadogArgs']] = None,
                 logtail: Optional[pulumi.Input['AppSpecFunctionLogDestinationLogtailArgs']] = None,
                 open_search: Optional[pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgs']] = None,
                 papertrail: Optional[pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param pulumi.Input['AppSpecFunctionLogDestinationDatadogArgs'] datadog: Datadog configuration.
        :param pulumi.Input['AppSpecFunctionLogDestinationLogtailArgs'] logtail: Logtail configuration.
        :param pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgs'] open_search: OpenSearch configuration.
        :param pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgs'] papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional[pulumi.Input['AppSpecFunctionLogDestinationDatadogArgs']]:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @datadog.setter
    def datadog(self, value: Optional[pulumi.Input['AppSpecFunctionLogDestinationDatadogArgs']]):
        pulumi.set(self, "datadog", value)

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional[pulumi.Input['AppSpecFunctionLogDestinationLogtailArgs']]:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @logtail.setter
    def logtail(self, value: Optional[pulumi.Input['AppSpecFunctionLogDestinationLogtailArgs']]):
        pulumi.set(self, "logtail", value)

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgs']]:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgs']]):
        pulumi.set(self, "open_search", value)

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional[pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgs']]:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")

    @papertrail.setter
    def papertrail(self, value: Optional[pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgs']]):
        pulumi.set(self, "papertrail", value)


if not MYPY:
    class AppSpecFunctionLogDestinationDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        Datadog API key.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Datadog HTTP log intake endpoint.
        """
elif False:
    AppSpecFunctionLogDestinationDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Datadog API key.
        :param pulumi.Input[_builtins.str] endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecFunctionLogDestinationLogtailArgsDict(TypedDict):
        token: pulumi.Input[_builtins.str]
        """
        Logtail token.
        """
elif False:
    AppSpecFunctionLogDestinationLogtailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationLogtailArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppSpecFunctionLogDestinationOpenSearchArgsDict(TypedDict):
        basic_auth: pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgsDict']
        """
        Basic authentication details.
        """
        cluster_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenSearch endpoint.
        """
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenSearch index name.
        """
elif False:
    AppSpecFunctionLogDestinationOpenSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationOpenSearchArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs'],
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs'] basic_auth: Basic authentication details.
        :param pulumi.Input[_builtins.str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[_builtins.str] endpoint: OpenSearch endpoint.
        :param pulumi.Input[_builtins.str] index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs']:
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class AppSpecFunctionLogDestinationOpenSearchBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for basic authentication.
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        user for basic authentication.
        """
elif False:
    AppSpecFunctionLogDestinationOpenSearchBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic authentication.
        :param pulumi.Input[_builtins.str] user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AppSpecFunctionLogDestinationPapertrailArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Papertrail syslog endpoint.
        """
elif False:
    AppSpecFunctionLogDestinationPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationPapertrailArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecFunctionRouteArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Paths must start with `/` and must be unique within the app.
        """
        preserve_path_prefix: NotRequired[pulumi.Input[_builtins.bool]]
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
elif False:
    AppSpecFunctionRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionRouteArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 preserve_path_prefix: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] path: Paths must start with `/` and must be unique within the app.
        :param pulumi.Input[_builtins.bool] preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @preserve_path_prefix.setter
    def preserve_path_prefix(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_path_prefix", value)


if not MYPY:
    class AppSpecIngressArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgsDict']]]]
        """
        Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
elif False:
    AppSpecIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgs']]] rules: Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @_builtins.property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgs']]]]:
        """
        Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AppSpecIngressRuleArgsDict(TypedDict):
        component: NotRequired[pulumi.Input['AppSpecIngressRuleComponentArgsDict']]
        """
        The component to route to. Only one of `component` or `redirect` may be set.
        """
        cors: NotRequired[pulumi.Input['AppSpecIngressRuleCorsArgsDict']]
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        match: NotRequired[pulumi.Input['AppSpecIngressRuleMatchArgsDict']]
        """
        The match configuration for the rule
        """
        redirect: NotRequired[pulumi.Input['AppSpecIngressRuleRedirectArgsDict']]
        """
        The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
elif False:
    AppSpecIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input['AppSpecIngressRuleComponentArgs']] = None,
                 cors: Optional[pulumi.Input['AppSpecIngressRuleCorsArgs']] = None,
                 match: Optional[pulumi.Input['AppSpecIngressRuleMatchArgs']] = None,
                 redirect: Optional[pulumi.Input['AppSpecIngressRuleRedirectArgs']] = None):
        """
        :param pulumi.Input['AppSpecIngressRuleComponentArgs'] component: The component to route to. Only one of `component` or `redirect` may be set.
        :param pulumi.Input['AppSpecIngressRuleCorsArgs'] cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param pulumi.Input['AppSpecIngressRuleMatchArgs'] match: The match configuration for the rule
        :param pulumi.Input['AppSpecIngressRuleRedirectArgs'] redirect: The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @_builtins.property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input['AppSpecIngressRuleComponentArgs']]:
        """
        The component to route to. Only one of `component` or `redirect` may be set.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input['AppSpecIngressRuleComponentArgs']]):
        pulumi.set(self, "component", value)

    @_builtins.property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['AppSpecIngressRuleCorsArgs']]:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppSpecIngressRuleCorsArgs']]):
        pulumi.set(self, "cors", value)

    @_builtins.property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['AppSpecIngressRuleMatchArgs']]:
        """
        The match configuration for the rule
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['AppSpecIngressRuleMatchArgs']]):
        pulumi.set(self, "match", value)

    @_builtins.property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['AppSpecIngressRuleRedirectArgs']]:
        """
        The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['AppSpecIngressRuleRedirectArgs']]):
        pulumi.set(self, "redirect", value)


if not MYPY:
    class AppSpecIngressRuleComponentArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the component to route to.
        """
        preserve_path_prefix: NotRequired[pulumi.Input[_builtins.bool]]
        """
        An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
        """
        rewrite: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with `preserve_path_prefix`.
        """
elif False:
    AppSpecIngressRuleComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleComponentArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 preserve_path_prefix: Optional[pulumi.Input[_builtins.bool]] = None,
                 rewrite: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the component to route to.
        :param pulumi.Input[_builtins.bool] preserve_path_prefix: An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
        :param pulumi.Input[_builtins.str] rewrite: An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with `preserve_path_prefix`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)
        if rewrite is not None:
            pulumi.set(__self__, "rewrite", rewrite)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the component to route to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @preserve_path_prefix.setter
    def preserve_path_prefix(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_path_prefix", value)

    @_builtins.property
    @pulumi.getter
    def rewrite(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with `preserve_path_prefix`.
        """
        return pulumi.get(self, "rewrite")

    @rewrite.setter
    def rewrite(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "rewrite", value)


if not MYPY:
    class AppSpecIngressRuleCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        allow_origins: NotRequired[pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgsDict']]
        """
        The `Access-Control-Allow-Origin` can be
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        max_age: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
elif False:
    AppSpecIngressRuleCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgs']] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_methods: The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        :param pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgs'] allow_origins: The `Access-Control-Allow-Origin` can be
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        :param pulumi.Input[_builtins.str] max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgs']]:
        """
        The `Access-Control-Allow-Origin` can be
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgs']]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AppSpecIngressRuleCorsAllowOriginsArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the client’s origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
elif False:
    AppSpecIngressRuleCorsAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleCorsAllowOriginsArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exact: The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        :param pulumi.Input[_builtins.str] prefix: The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        :param pulumi.Input[_builtins.str] regex: The `Access-Control-Allow-Origin` header will be set to the client's origin if the client’s origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            warnings.warn("""Prefix-based matching has been deprecated in favor of regex-based matching.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Prefix-based matching has been deprecated in favor of regex-based matching.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the client’s origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AppSpecIngressRuleMatchArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['AppSpecIngressRuleMatchPathArgsDict']]
        """
        The path to match on.
        """
elif False:
    AppSpecIngressRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleMatchArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['AppSpecIngressRuleMatchPathArgs']] = None):
        """
        :param pulumi.Input['AppSpecIngressRuleMatchPathArgs'] path: The path to match on.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['AppSpecIngressRuleMatchPathArgs']]:
        """
        The path to match on.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['AppSpecIngressRuleMatchPathArgs']]):
        pulumi.set(self, "path", value)


if not MYPY:
    class AppSpecIngressRuleMatchPathArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix-based match.
        """
elif False:
    AppSpecIngressRuleMatchPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleMatchPathArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] prefix: Prefix-based match.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AppSpecIngressRuleRedirectArgsDict(TypedDict):
        authority: NotRequired[pulumi.Input[_builtins.str]]
        """
        The authority/host to redirect to. This can be a hostname or IP address.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The port to redirect to.
        """
        redirect_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The redirect code to use. Supported values are `300`, `301`, `302`, `303`, `304`, `307`, `308`.
        """
        scheme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The scheme to redirect to. Supported values are `http` or `https`
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional URI path to redirect to.
        """
elif False:
    AppSpecIngressRuleRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleRedirectArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input[_builtins.str]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 redirect_code: Optional[pulumi.Input[_builtins.int]] = None,
                 scheme: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] authority: The authority/host to redirect to. This can be a hostname or IP address.
        :param pulumi.Input[_builtins.int] port: The port to redirect to.
        :param pulumi.Input[_builtins.int] redirect_code: The redirect code to use. Supported values are `300`, `301`, `302`, `303`, `304`, `307`, `308`.
        :param pulumi.Input[_builtins.str] scheme: The scheme to redirect to. Supported values are `http` or `https`
        :param pulumi.Input[_builtins.str] uri: An optional URI path to redirect to.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The authority/host to redirect to. This can be a hostname or IP address.
        """
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "authority", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The port to redirect to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The redirect code to use. Supported values are `300`, `301`, `302`, `303`, `304`, `307`, `308`.
        """
        return pulumi.get(self, "redirect_code")

    @redirect_code.setter
    def redirect_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "redirect_code", value)

    @_builtins.property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The scheme to redirect to. Supported values are `http` or `https`
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scheme", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional URI path to redirect to.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AppSpecJobArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        bitbucket: NotRequired[pulumi.Input['AppSpecJobBitbucketArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        build_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional build command to run while building this component from source.
        """
        dockerfile_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        environment_slug: NotRequired[pulumi.Input[_builtins.str]]
        """
        An environment slug describing the type of this app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        git: NotRequired[pulumi.Input['AppSpecJobGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecJobGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecJobGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        image: NotRequired[pulumi.Input['AppSpecJobImageArgsDict']]
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of instances that this component should be scaled to.
        """
        instance_size_slug: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        kind: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of job and when it will be run during the deployment process. It may be one of:
        - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
        - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
        - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
        - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        """
        log_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgsDict']]]]
        """
        Describes a log forwarding destination.
        """
        run_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional run command to override the component's default.
        """
        source_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional path to the working directory to use for the build.
        """
        termination: NotRequired[pulumi.Input['AppSpecJobTerminationArgsDict']]
        """
        Contains a component's termination parameters.
        """
elif False:
    AppSpecJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgs']]]] = None,
                 bitbucket: Optional[pulumi.Input['AppSpecJobBitbucketArgs']] = None,
                 build_command: Optional[pulumi.Input[_builtins.str]] = None,
                 dockerfile_path: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_slug: Optional[pulumi.Input[_builtins.str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgs']]]] = None,
                 git: Optional[pulumi.Input['AppSpecJobGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecJobGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecJobGitlabArgs']] = None,
                 image: Optional[pulumi.Input['AppSpecJobImageArgs']] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_size_slug: Optional[pulumi.Input[_builtins.str]] = None,
                 kind: Optional[pulumi.Input[_builtins.str]] = None,
                 log_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgs']]]] = None,
                 run_command: Optional[pulumi.Input[_builtins.str]] = None,
                 source_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 termination: Optional[pulumi.Input['AppSpecJobTerminationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input['AppSpecJobBitbucketArgs'] bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param pulumi.Input[_builtins.str] build_command: An optional build command to run while building this component from source.
        :param pulumi.Input[_builtins.str] dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param pulumi.Input[_builtins.str] environment_slug: An environment slug describing the type of this app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input['AppSpecJobGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecJobGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecJobGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecJobImageArgs'] image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[_builtins.int] instance_count: The amount of instances that this component should be scaled to.
        :param pulumi.Input[_builtins.str] instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param pulumi.Input[_builtins.str] kind: The type of job and when it will be run during the deployment process. It may be one of:
               - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
               - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
               - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
               - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgs']]] log_destinations: Describes a log forwarding destination.
        :param pulumi.Input[_builtins.str] run_command: An optional run command to override the component's default.
        :param pulumi.Input[_builtins.str] source_dir: An optional path to the working directory to use for the build.
        :param pulumi.Input['AppSpecJobTerminationArgs'] termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional[pulumi.Input['AppSpecJobBitbucketArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @bitbucket.setter
    def bitbucket(self, value: Optional[pulumi.Input['AppSpecJobBitbucketArgs']]):
        pulumi.set(self, "bitbucket", value)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_command", value)

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dockerfile_path", value)

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @environment_slug.setter
    def environment_slug(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_slug", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecJobGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecJobGitArgs']]):
        pulumi.set(self, "git", value)

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecJobGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecJobGithubArgs']]):
        pulumi.set(self, "github", value)

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecJobGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecJobGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['AppSpecJobImageArgs']]:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['AppSpecJobImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @instance_size_slug.setter
    def instance_size_slug(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_size_slug", value)

    @_builtins.property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of job and when it will be run during the deployment process. It may be one of:
        - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
        - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
        - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
        - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kind", value)

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgs']]]]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @log_destinations.setter
    def log_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgs']]]]):
        pulumi.set(self, "log_destinations", value)

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @run_command.setter
    def run_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "run_command", value)

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_dir", value)

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional[pulumi.Input['AppSpecJobTerminationArgs']]:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")

    @termination.setter
    def termination(self, value: Optional[pulumi.Input['AppSpecJobTerminationArgs']]):
        pulumi.set(self, "termination", value)


if not MYPY:
    class AppSpecJobAlertArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        rule: pulumi.Input[_builtins.str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        value: pulumi.Input[_builtins.float]
        """
        The threshold for the type of the warning.
        """
        window: pulumi.Input[_builtins.str]
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        destinations: NotRequired[pulumi.Input['AppSpecJobAlertDestinationsArgsDict']]
        """
        Specification for alert destination.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecJobAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobAlertArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 rule: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.float],
                 window: pulumi.Input[_builtins.str],
                 destinations: Optional[pulumi.Input['AppSpecJobAlertDestinationsArgs']] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param pulumi.Input[_builtins.str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[_builtins.float] value: The threshold for the type of the warning.
        :param pulumi.Input[_builtins.str] window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param pulumi.Input['AppSpecJobAlertDestinationsArgs'] destinations: Specification for alert destination.
        :param pulumi.Input[_builtins.bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.float]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def window(self) -> pulumi.Input[_builtins.str]:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "window", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input['AppSpecJobAlertDestinationsArgs']]:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input['AppSpecJobAlertDestinationsArgs']]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecJobAlertDestinationsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        slack_webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertDestinationsSlackWebhookArgsDict']]]]
        """
        Determines which slack channels or users receive alerts.
        """
elif False:
    AppSpecJobAlertDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobAlertDestinationsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slack_webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertDestinationsSlackWebhookArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertDestinationsSlackWebhookArgs']]] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertDestinationsSlackWebhookArgs']]]]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")

    @slack_webhooks.setter
    def slack_webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertDestinationsSlackWebhookArgs']]]]):
        pulumi.set(self, "slack_webhooks", value)


if not MYPY:
    class AppSpecJobAlertDestinationsSlackWebhookArgsDict(TypedDict):
        channel: pulumi.Input[_builtins.str]
        """
        The Slack channel to send notifications to.
        """
        url: pulumi.Input[_builtins.str]
        """
        The Slack webhook URL.
        """
elif False:
    AppSpecJobAlertDestinationsSlackWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobAlertDestinationsSlackWebhookArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] channel: The Slack channel to send notifications to.
        :param pulumi.Input[_builtins.str] url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AppSpecJobBitbucketArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecJobBitbucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobBitbucketArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecJobEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecJobEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the environment variable.
        :param pulumi.Input[_builtins.str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[_builtins.str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[_builtins.str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecJobGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecJobGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 repo_clone_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecJobGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecJobGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecJobGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecJobGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecJobImageArgsDict(TypedDict):
        registry_type: pulumi.Input[_builtins.str]
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        repository: pulumi.Input[_builtins.str]
        """
        The repository name.
        """
        deploy_on_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgsDict']]]]
        """
        Configures automatically deploying images pushed to DOCR.
        """
        digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        registry: NotRequired[pulumi.Input[_builtins.str]]
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        registry_credentials: NotRequired[pulumi.Input[_builtins.str]]
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository tag. Defaults to `latest` if not provided.
        """
elif False:
    AppSpecJobImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobImageArgs:
    def __init__(__self__, *,
                 registry_type: pulumi.Input[_builtins.str],
                 repository: pulumi.Input[_builtins.str],
                 deploy_on_pushes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgs']]]] = None,
                 digest: Optional[pulumi.Input[_builtins.str]] = None,
                 registry: Optional[pulumi.Input[_builtins.str]] = None,
                 registry_credentials: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param pulumi.Input[_builtins.str] repository: The repository name.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgs']]] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param pulumi.Input[_builtins.str] digest: The image digest. Cannot be specified if `tag` is provided.
        :param pulumi.Input[_builtins.str] registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param pulumi.Input[_builtins.str] registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param pulumi.Input[_builtins.str] tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> pulumi.Input[_builtins.str]:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @registry_type.setter
    def registry_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_type", value)

    @_builtins.property
    @pulumi.getter
    def repository(self) -> pulumi.Input[_builtins.str]:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "repository", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgs']]]]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @deploy_on_pushes.setter
    def deploy_on_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgs']]]]):
        pulumi.set(self, "deploy_on_pushes", value)

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry", value)

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @registry_credentials.setter
    def registry_credentials(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_credentials", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class AppSpecJobImageDeployOnPushArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy images pushed to DOCR.
        """
elif False:
    AppSpecJobImageDeployOnPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobImageDeployOnPushArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AppSpecJobLogDestinationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        datadog: NotRequired[pulumi.Input['AppSpecJobLogDestinationDatadogArgsDict']]
        """
        Datadog configuration.
        """
        logtail: NotRequired[pulumi.Input['AppSpecJobLogDestinationLogtailArgsDict']]
        """
        Logtail configuration.
        """
        open_search: NotRequired[pulumi.Input['AppSpecJobLogDestinationOpenSearchArgsDict']]
        """
        OpenSearch configuration.
        """
        papertrail: NotRequired[pulumi.Input['AppSpecJobLogDestinationPapertrailArgsDict']]
        """
        Papertrail configuration.
        """
elif False:
    AppSpecJobLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 datadog: Optional[pulumi.Input['AppSpecJobLogDestinationDatadogArgs']] = None,
                 logtail: Optional[pulumi.Input['AppSpecJobLogDestinationLogtailArgs']] = None,
                 open_search: Optional[pulumi.Input['AppSpecJobLogDestinationOpenSearchArgs']] = None,
                 papertrail: Optional[pulumi.Input['AppSpecJobLogDestinationPapertrailArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param pulumi.Input['AppSpecJobLogDestinationDatadogArgs'] datadog: Datadog configuration.
        :param pulumi.Input['AppSpecJobLogDestinationLogtailArgs'] logtail: Logtail configuration.
        :param pulumi.Input['AppSpecJobLogDestinationOpenSearchArgs'] open_search: OpenSearch configuration.
        :param pulumi.Input['AppSpecJobLogDestinationPapertrailArgs'] papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional[pulumi.Input['AppSpecJobLogDestinationDatadogArgs']]:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @datadog.setter
    def datadog(self, value: Optional[pulumi.Input['AppSpecJobLogDestinationDatadogArgs']]):
        pulumi.set(self, "datadog", value)

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional[pulumi.Input['AppSpecJobLogDestinationLogtailArgs']]:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @logtail.setter
    def logtail(self, value: Optional[pulumi.Input['AppSpecJobLogDestinationLogtailArgs']]):
        pulumi.set(self, "logtail", value)

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['AppSpecJobLogDestinationOpenSearchArgs']]:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['AppSpecJobLogDestinationOpenSearchArgs']]):
        pulumi.set(self, "open_search", value)

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional[pulumi.Input['AppSpecJobLogDestinationPapertrailArgs']]:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")

    @papertrail.setter
    def papertrail(self, value: Optional[pulumi.Input['AppSpecJobLogDestinationPapertrailArgs']]):
        pulumi.set(self, "papertrail", value)


if not MYPY:
    class AppSpecJobLogDestinationDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        Datadog API key.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Datadog HTTP log intake endpoint.
        """
elif False:
    AppSpecJobLogDestinationDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Datadog API key.
        :param pulumi.Input[_builtins.str] endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecJobLogDestinationLogtailArgsDict(TypedDict):
        token: pulumi.Input[_builtins.str]
        """
        Logtail token.
        """
elif False:
    AppSpecJobLogDestinationLogtailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationLogtailArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppSpecJobLogDestinationOpenSearchArgsDict(TypedDict):
        basic_auth: pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgsDict']
        """
        Basic authentication details.
        """
        cluster_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenSearch endpoint.
        """
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenSearch index name.
        """
elif False:
    AppSpecJobLogDestinationOpenSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationOpenSearchArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgs'],
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgs'] basic_auth: Basic authentication details.
        :param pulumi.Input[_builtins.str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[_builtins.str] endpoint: OpenSearch endpoint.
        :param pulumi.Input[_builtins.str] index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgs']:
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class AppSpecJobLogDestinationOpenSearchBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for basic authentication.
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        user for basic authentication.
        """
elif False:
    AppSpecJobLogDestinationOpenSearchBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationOpenSearchBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic authentication.
        :param pulumi.Input[_builtins.str] user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AppSpecJobLogDestinationPapertrailArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Papertrail syslog endpoint.
        """
elif False:
    AppSpecJobLogDestinationPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationPapertrailArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecJobTerminationArgsDict(TypedDict):
        grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
elif False:
    AppSpecJobTerminationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobTerminationArgs:
    def __init__(__self__, *,
                 grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
               
               A `function` component can contain:
        """
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
        return pulumi.get(self, "grace_period_seconds")

    @grace_period_seconds.setter
    def grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "grace_period_seconds", value)


if not MYPY:
    class AppSpecMaintenanceArgsDict(TypedDict):
        archive: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the app should be archived. Setting this to true implies that enabled is set to true.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether maintenance mode should be enabled for the app.
        """
        offline_page_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        A custom offline page to display when maintenance mode is enabled or the app is archived.
        """
elif False:
    AppSpecMaintenanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecMaintenanceArgs:
    def __init__(__self__, *,
                 archive: Optional[pulumi.Input[_builtins.bool]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 offline_page_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] archive: Indicates whether the app should be archived. Setting this to true implies that enabled is set to true.
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether maintenance mode should be enabled for the app.
        :param pulumi.Input[_builtins.str] offline_page_url: A custom offline page to display when maintenance mode is enabled or the app is archived.
        """
        if archive is not None:
            pulumi.set(__self__, "archive", archive)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if offline_page_url is not None:
            pulumi.set(__self__, "offline_page_url", offline_page_url)

    @_builtins.property
    @pulumi.getter
    def archive(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the app should be archived. Setting this to true implies that enabled is set to true.
        """
        return pulumi.get(self, "archive")

    @archive.setter
    def archive(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "archive", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether maintenance mode should be enabled for the app.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="offlinePageUrl")
    def offline_page_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A custom offline page to display when maintenance mode is enabled or the app is archived.
        """
        return pulumi.get(self, "offline_page_url")

    @offline_page_url.setter
    def offline_page_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "offline_page_url", value)


if not MYPY:
    class AppSpecServiceArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        autoscaling: NotRequired[pulumi.Input['AppSpecServiceAutoscalingArgsDict']]
        """
        Configuration for automatically scaling this component based on metrics.
        """
        bitbucket: NotRequired[pulumi.Input['AppSpecServiceBitbucketArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        build_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional build command to run while building this component from source.
        """
        cors: NotRequired[pulumi.Input['AppSpecServiceCorsArgsDict']]
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        dockerfile_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        environment_slug: NotRequired[pulumi.Input[_builtins.str]]
        """
        An environment slug describing the type of this app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        git: NotRequired[pulumi.Input['AppSpecServiceGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecServiceGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecServiceGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        health_check: NotRequired[pulumi.Input['AppSpecServiceHealthCheckArgsDict']]
        """
        A health check to determine the availability of this component.
        """
        http_port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The internal port on which this service's run command will listen.
        """
        image: NotRequired[pulumi.Input['AppSpecServiceImageArgsDict']]
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of instances that this component should be scaled to.
        """
        instance_size_slug: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        internal_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        A list of ports on which this service will listen for internal traffic.
        """
        log_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgsDict']]]]
        """
        Describes a log forwarding destination.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgsDict']]]]
        """
        An HTTP paths that should be routed to this component.
        """
        run_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional run command to override the component's default.
        """
        source_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional path to the working directory to use for the build.
        """
        termination: NotRequired[pulumi.Input['AppSpecServiceTerminationArgsDict']]
        """
        Contains a component's termination parameters.
        """
elif False:
    AppSpecServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgs']]]] = None,
                 autoscaling: Optional[pulumi.Input['AppSpecServiceAutoscalingArgs']] = None,
                 bitbucket: Optional[pulumi.Input['AppSpecServiceBitbucketArgs']] = None,
                 build_command: Optional[pulumi.Input[_builtins.str]] = None,
                 cors: Optional[pulumi.Input['AppSpecServiceCorsArgs']] = None,
                 dockerfile_path: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_slug: Optional[pulumi.Input[_builtins.str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgs']]]] = None,
                 git: Optional[pulumi.Input['AppSpecServiceGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecServiceGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecServiceGitlabArgs']] = None,
                 health_check: Optional[pulumi.Input['AppSpecServiceHealthCheckArgs']] = None,
                 http_port: Optional[pulumi.Input[_builtins.int]] = None,
                 image: Optional[pulumi.Input['AppSpecServiceImageArgs']] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_size_slug: Optional[pulumi.Input[_builtins.str]] = None,
                 internal_ports: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 log_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgs']]]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgs']]]] = None,
                 run_command: Optional[pulumi.Input[_builtins.str]] = None,
                 source_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 termination: Optional[pulumi.Input['AppSpecServiceTerminationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input['AppSpecServiceAutoscalingArgs'] autoscaling: Configuration for automatically scaling this component based on metrics.
        :param pulumi.Input['AppSpecServiceBitbucketArgs'] bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param pulumi.Input[_builtins.str] build_command: An optional build command to run while building this component from source.
        :param pulumi.Input['AppSpecServiceCorsArgs'] cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param pulumi.Input[_builtins.str] dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param pulumi.Input[_builtins.str] environment_slug: An environment slug describing the type of this app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input['AppSpecServiceGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecServiceGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecServiceGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecServiceHealthCheckArgs'] health_check: A health check to determine the availability of this component.
        :param pulumi.Input[_builtins.int] http_port: The internal port on which this service's run command will listen.
        :param pulumi.Input['AppSpecServiceImageArgs'] image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[_builtins.int] instance_count: The amount of instances that this component should be scaled to.
        :param pulumi.Input[_builtins.str] instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] internal_ports: A list of ports on which this service will listen for internal traffic.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgs']]] log_destinations: Describes a log forwarding destination.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgs']]] routes: An HTTP paths that should be routed to this component.
        :param pulumi.Input[_builtins.str] run_command: An optional run command to override the component's default.
        :param pulumi.Input[_builtins.str] source_dir: An optional path to the working directory to use for the build.
        :param pulumi.Input['AppSpecServiceTerminationArgs'] termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if cors is not None:
            warnings.warn("""Service level CORS rules are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""cors is deprecated: Service level CORS rules are deprecated in favor of ingresses""")
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if internal_ports is not None:
            pulumi.set(__self__, "internal_ports", internal_ports)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if routes is not None:
            warnings.warn("""Service level routes are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""routes is deprecated: Service level routes are deprecated in favor of ingresses""")
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['AppSpecServiceAutoscalingArgs']]:
        """
        Configuration for automatically scaling this component based on metrics.
        """
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['AppSpecServiceAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional[pulumi.Input['AppSpecServiceBitbucketArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @bitbucket.setter
    def bitbucket(self, value: Optional[pulumi.Input['AppSpecServiceBitbucketArgs']]):
        pulumi.set(self, "bitbucket", value)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_command", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional[pulumi.Input['AppSpecServiceCorsArgs']]:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppSpecServiceCorsArgs']]):
        pulumi.set(self, "cors", value)

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dockerfile_path", value)

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @environment_slug.setter
    def environment_slug(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_slug", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecServiceGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecServiceGitArgs']]):
        pulumi.set(self, "git", value)

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecServiceGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecServiceGithubArgs']]):
        pulumi.set(self, "github", value)

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecServiceGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecServiceGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @_builtins.property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['AppSpecServiceHealthCheckArgs']]:
        """
        A health check to determine the availability of this component.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['AppSpecServiceHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @_builtins.property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The internal port on which this service's run command will listen.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "http_port", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['AppSpecServiceImageArgs']]:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['AppSpecServiceImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @instance_size_slug.setter
    def instance_size_slug(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_size_slug", value)

    @_builtins.property
    @pulumi.getter(name="internalPorts")
    def internal_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        A list of ports on which this service will listen for internal traffic.
        """
        return pulumi.get(self, "internal_ports")

    @internal_ports.setter
    def internal_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "internal_ports", value)

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgs']]]]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @log_destinations.setter
    def log_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgs']]]]):
        pulumi.set(self, "log_destinations", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgs']]]]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @run_command.setter
    def run_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "run_command", value)

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_dir", value)

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional[pulumi.Input['AppSpecServiceTerminationArgs']]:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")

    @termination.setter
    def termination(self, value: Optional[pulumi.Input['AppSpecServiceTerminationArgs']]):
        pulumi.set(self, "termination", value)


if not MYPY:
    class AppSpecServiceAlertArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        rule: pulumi.Input[_builtins.str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        value: pulumi.Input[_builtins.float]
        """
        The threshold for the type of the warning.
        """
        window: pulumi.Input[_builtins.str]
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        destinations: NotRequired[pulumi.Input['AppSpecServiceAlertDestinationsArgsDict']]
        """
        Specification for alert destination.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecServiceAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAlertArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 rule: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.float],
                 window: pulumi.Input[_builtins.str],
                 destinations: Optional[pulumi.Input['AppSpecServiceAlertDestinationsArgs']] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param pulumi.Input[_builtins.str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[_builtins.float] value: The threshold for the type of the warning.
        :param pulumi.Input[_builtins.str] window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param pulumi.Input['AppSpecServiceAlertDestinationsArgs'] destinations: Specification for alert destination.
        :param pulumi.Input[_builtins.bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.float]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def window(self) -> pulumi.Input[_builtins.str]:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "window", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input['AppSpecServiceAlertDestinationsArgs']]:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input['AppSpecServiceAlertDestinationsArgs']]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecServiceAlertDestinationsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        slack_webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertDestinationsSlackWebhookArgsDict']]]]
        """
        Determines which slack channels or users receive alerts.
        """
elif False:
    AppSpecServiceAlertDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAlertDestinationsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slack_webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertDestinationsSlackWebhookArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertDestinationsSlackWebhookArgs']]] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertDestinationsSlackWebhookArgs']]]]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")

    @slack_webhooks.setter
    def slack_webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertDestinationsSlackWebhookArgs']]]]):
        pulumi.set(self, "slack_webhooks", value)


if not MYPY:
    class AppSpecServiceAlertDestinationsSlackWebhookArgsDict(TypedDict):
        channel: pulumi.Input[_builtins.str]
        """
        The Slack channel to send notifications to.
        """
        url: pulumi.Input[_builtins.str]
        """
        The Slack webhook URL.
        """
elif False:
    AppSpecServiceAlertDestinationsSlackWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAlertDestinationsSlackWebhookArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] channel: The Slack channel to send notifications to.
        :param pulumi.Input[_builtins.str] url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AppSpecServiceAutoscalingArgsDict(TypedDict):
        max_instance_count: pulumi.Input[_builtins.int]
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        metrics: pulumi.Input['AppSpecServiceAutoscalingMetricsArgsDict']
        """
        The metrics that the component is scaled on.
        """
        min_instance_count: pulumi.Input[_builtins.int]
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
elif False:
    AppSpecServiceAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAutoscalingArgs:
    def __init__(__self__, *,
                 max_instance_count: pulumi.Input[_builtins.int],
                 metrics: pulumi.Input['AppSpecServiceAutoscalingMetricsArgs'],
                 min_instance_count: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count.
        :param pulumi.Input['AppSpecServiceAutoscalingMetricsArgs'] metrics: The metrics that the component is scaled on.
        :param pulumi.Input[_builtins.int] min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_instance_count", min_instance_count)

    @_builtins.property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_instance_count", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> pulumi.Input['AppSpecServiceAutoscalingMetricsArgs']:
        """
        The metrics that the component is scaled on.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input['AppSpecServiceAutoscalingMetricsArgs']):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_instance_count", value)


if not MYPY:
    class AppSpecServiceAutoscalingMetricsArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgsDict']]
        """
        Settings for scaling the component based on CPU utilization.
        """
elif False:
    AppSpecServiceAutoscalingMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAutoscalingMetricsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgs']] = None):
        """
        :param pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgs'] cpu: Settings for scaling the component based on CPU utilization.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgs']]:
        """
        Settings for scaling the component based on CPU utilization.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgs']]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class AppSpecServiceAutoscalingMetricsCpuArgsDict(TypedDict):
        percent: pulumi.Input[_builtins.int]
        """
        The average target CPU utilization for the component.
        """
elif False:
    AppSpecServiceAutoscalingMetricsCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAutoscalingMetricsCpuArgs:
    def __init__(__self__, *,
                 percent: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] percent: The average target CPU utilization for the component.
        """
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> pulumi.Input[_builtins.int]:
        """
        The average target CPU utilization for the component.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class AppSpecServiceBitbucketArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecServiceBitbucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceBitbucketArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecServiceCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        allow_origins: NotRequired[pulumi.Input['AppSpecServiceCorsAllowOriginsArgsDict']]
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        max_age: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
elif False:
    AppSpecServiceCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input['AppSpecServiceCorsAllowOriginsArgs']] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param pulumi.Input['AppSpecServiceCorsAllowOriginsArgs'] allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param pulumi.Input[_builtins.str] max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input['AppSpecServiceCorsAllowOriginsArgs']]:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input['AppSpecServiceCorsAllowOriginsArgs']]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AppSpecServiceCorsAllowOriginsArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        Exact string match.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix-based match.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        RE2 style regex-based match.
        """
elif False:
    AppSpecServiceCorsAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceCorsAllowOriginsArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exact: Exact string match.
        :param pulumi.Input[_builtins.str] prefix: Prefix-based match.
        :param pulumi.Input[_builtins.str] regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            warnings.warn("""Prefix-based matching has been deprecated in favor of regex-based matching.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Prefix-based matching has been deprecated in favor of regex-based matching.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AppSpecServiceEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecServiceEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the environment variable.
        :param pulumi.Input[_builtins.str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[_builtins.str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[_builtins.str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecServiceGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecServiceGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 repo_clone_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecServiceGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecServiceGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecServiceGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecServiceGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecServiceHealthCheckArgsDict(TypedDict):
        failure_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of failed health checks before considered unhealthy.
        """
        http_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The route path used for the HTTP health check ping.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds to wait before beginning health checks.
        """
        period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds to wait between health checks.
        """
        port: NotRequired[pulumi.Input[_builtins.int]]
        """
        The health check will be performed on this port instead of component's HTTP port.
        """
        success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of successful health checks before considered healthy.
        """
        timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds after which the check times out.
        """
elif False:
    AppSpecServiceHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceHealthCheckArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 http_path: Optional[pulumi.Input[_builtins.str]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 period_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 port: Optional[pulumi.Input[_builtins.int]] = None,
                 success_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] failure_threshold: The number of failed health checks before considered unhealthy.
        :param pulumi.Input[_builtins.str] http_path: The route path used for the HTTP health check ping.
        :param pulumi.Input[_builtins.int] initial_delay_seconds: The number of seconds to wait before beginning health checks.
        :param pulumi.Input[_builtins.int] period_seconds: The number of seconds to wait between health checks.
        :param pulumi.Input[_builtins.int] port: The health check will be performed on this port instead of component's HTTP port.
        :param pulumi.Input[_builtins.int] success_threshold: The number of successful health checks before considered healthy.
        :param pulumi.Input[_builtins.int] timeout_seconds: The number of seconds after which the check times out.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @_builtins.property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of failed health checks before considered unhealthy.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failure_threshold", value)

    @_builtins.property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The route path used for the HTTP health check ping.
        """
        return pulumi.get(self, "http_path")

    @http_path.setter
    def http_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_path", value)

    @_builtins.property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds to wait before beginning health checks.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @_builtins.property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds to wait between health checks.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "period_seconds", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The health check will be performed on this port instead of component's HTTP port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of successful health checks before considered healthy.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "success_threshold", value)

    @_builtins.property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds after which the check times out.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class AppSpecServiceImageArgsDict(TypedDict):
        registry_type: pulumi.Input[_builtins.str]
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        repository: pulumi.Input[_builtins.str]
        """
        The repository name.
        """
        deploy_on_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgsDict']]]]
        """
        Configures automatically deploying images pushed to DOCR.
        """
        digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        registry: NotRequired[pulumi.Input[_builtins.str]]
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        registry_credentials: NotRequired[pulumi.Input[_builtins.str]]
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository tag. Defaults to `latest` if not provided.
        """
elif False:
    AppSpecServiceImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceImageArgs:
    def __init__(__self__, *,
                 registry_type: pulumi.Input[_builtins.str],
                 repository: pulumi.Input[_builtins.str],
                 deploy_on_pushes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgs']]]] = None,
                 digest: Optional[pulumi.Input[_builtins.str]] = None,
                 registry: Optional[pulumi.Input[_builtins.str]] = None,
                 registry_credentials: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param pulumi.Input[_builtins.str] repository: The repository name.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgs']]] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param pulumi.Input[_builtins.str] digest: The image digest. Cannot be specified if `tag` is provided.
        :param pulumi.Input[_builtins.str] registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param pulumi.Input[_builtins.str] registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param pulumi.Input[_builtins.str] tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> pulumi.Input[_builtins.str]:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @registry_type.setter
    def registry_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_type", value)

    @_builtins.property
    @pulumi.getter
    def repository(self) -> pulumi.Input[_builtins.str]:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "repository", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgs']]]]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @deploy_on_pushes.setter
    def deploy_on_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgs']]]]):
        pulumi.set(self, "deploy_on_pushes", value)

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry", value)

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @registry_credentials.setter
    def registry_credentials(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_credentials", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class AppSpecServiceImageDeployOnPushArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy images pushed to DOCR.
        """
elif False:
    AppSpecServiceImageDeployOnPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceImageDeployOnPushArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AppSpecServiceLogDestinationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        datadog: NotRequired[pulumi.Input['AppSpecServiceLogDestinationDatadogArgsDict']]
        """
        Datadog configuration.
        """
        logtail: NotRequired[pulumi.Input['AppSpecServiceLogDestinationLogtailArgsDict']]
        """
        Logtail configuration.
        """
        open_search: NotRequired[pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgsDict']]
        """
        OpenSearch configuration.
        """
        papertrail: NotRequired[pulumi.Input['AppSpecServiceLogDestinationPapertrailArgsDict']]
        """
        Papertrail configuration.
        """
elif False:
    AppSpecServiceLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 datadog: Optional[pulumi.Input['AppSpecServiceLogDestinationDatadogArgs']] = None,
                 logtail: Optional[pulumi.Input['AppSpecServiceLogDestinationLogtailArgs']] = None,
                 open_search: Optional[pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgs']] = None,
                 papertrail: Optional[pulumi.Input['AppSpecServiceLogDestinationPapertrailArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param pulumi.Input['AppSpecServiceLogDestinationDatadogArgs'] datadog: Datadog configuration.
        :param pulumi.Input['AppSpecServiceLogDestinationLogtailArgs'] logtail: Logtail configuration.
        :param pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgs'] open_search: OpenSearch configuration.
        :param pulumi.Input['AppSpecServiceLogDestinationPapertrailArgs'] papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional[pulumi.Input['AppSpecServiceLogDestinationDatadogArgs']]:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @datadog.setter
    def datadog(self, value: Optional[pulumi.Input['AppSpecServiceLogDestinationDatadogArgs']]):
        pulumi.set(self, "datadog", value)

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional[pulumi.Input['AppSpecServiceLogDestinationLogtailArgs']]:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @logtail.setter
    def logtail(self, value: Optional[pulumi.Input['AppSpecServiceLogDestinationLogtailArgs']]):
        pulumi.set(self, "logtail", value)

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgs']]:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgs']]):
        pulumi.set(self, "open_search", value)

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional[pulumi.Input['AppSpecServiceLogDestinationPapertrailArgs']]:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")

    @papertrail.setter
    def papertrail(self, value: Optional[pulumi.Input['AppSpecServiceLogDestinationPapertrailArgs']]):
        pulumi.set(self, "papertrail", value)


if not MYPY:
    class AppSpecServiceLogDestinationDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        Datadog API key.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Datadog HTTP log intake endpoint.
        """
elif False:
    AppSpecServiceLogDestinationDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Datadog API key.
        :param pulumi.Input[_builtins.str] endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecServiceLogDestinationLogtailArgsDict(TypedDict):
        token: pulumi.Input[_builtins.str]
        """
        Logtail token.
        """
elif False:
    AppSpecServiceLogDestinationLogtailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationLogtailArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppSpecServiceLogDestinationOpenSearchArgsDict(TypedDict):
        basic_auth: pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgsDict']
        """
        Basic authentication details.
        """
        cluster_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenSearch endpoint.
        """
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenSearch index name.
        """
elif False:
    AppSpecServiceLogDestinationOpenSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationOpenSearchArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgs'],
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgs'] basic_auth: Basic authentication details.
        :param pulumi.Input[_builtins.str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[_builtins.str] endpoint: OpenSearch endpoint.
        :param pulumi.Input[_builtins.str] index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgs']:
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class AppSpecServiceLogDestinationOpenSearchBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for basic authentication.
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        user for basic authentication.
        """
elif False:
    AppSpecServiceLogDestinationOpenSearchBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationOpenSearchBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic authentication.
        :param pulumi.Input[_builtins.str] user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AppSpecServiceLogDestinationPapertrailArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Papertrail syslog endpoint.
        """
elif False:
    AppSpecServiceLogDestinationPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationPapertrailArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecServiceRouteArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Paths must start with `/` and must be unique within the app.
        """
        preserve_path_prefix: NotRequired[pulumi.Input[_builtins.bool]]
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
elif False:
    AppSpecServiceRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceRouteArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 preserve_path_prefix: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] path: Paths must start with `/` and must be unique within the app.
        :param pulumi.Input[_builtins.bool] preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @preserve_path_prefix.setter
    def preserve_path_prefix(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_path_prefix", value)


if not MYPY:
    class AppSpecServiceTerminationArgsDict(TypedDict):
        drain_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110.

        A `static_site` can contain:
        """
        grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
elif False:
    AppSpecServiceTerminationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceTerminationArgs:
    def __init__(__self__, *,
                 drain_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] drain_seconds: The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110.
               
               A `static_site` can contain:
        :param pulumi.Input[_builtins.int] grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
               
               A `function` component can contain:
        """
        if drain_seconds is not None:
            pulumi.set(__self__, "drain_seconds", drain_seconds)
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="drainSeconds")
    def drain_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds to wait between selecting a container instance for termination and issuing the TERM signal. Selecting a container instance for termination begins an asynchronous drain of new requests on upstream load-balancers. Default: 15 seconds, Minimum 1, Maximum 110.

        A `static_site` can contain:
        """
        return pulumi.get(self, "drain_seconds")

    @drain_seconds.setter
    def drain_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "drain_seconds", value)

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
        return pulumi.get(self, "grace_period_seconds")

    @grace_period_seconds.setter
    def grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "grace_period_seconds", value)


if not MYPY:
    class AppSpecStaticSiteArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the component.
        """
        bitbucket: NotRequired[pulumi.Input['AppSpecStaticSiteBitbucketArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        build_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional build command to run while building this component from source.
        """
        catchall_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        """
        cors: NotRequired[pulumi.Input['AppSpecStaticSiteCorsArgsDict']]
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        dockerfile_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        environment_slug: NotRequired[pulumi.Input[_builtins.str]]
        """
        An environment slug describing the type of this app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        error_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the error document to use when serving this static site.
        """
        git: NotRequired[pulumi.Input['AppSpecStaticSiteGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecStaticSiteGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecStaticSiteGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        index_document: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the index document to use when serving this static site.
        """
        output_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgsDict']]]]
        """
        An HTTP paths that should be routed to this component.
        """
        source_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional path to the working directory to use for the build.
        """
elif False:
    AppSpecStaticSiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 bitbucket: Optional[pulumi.Input['AppSpecStaticSiteBitbucketArgs']] = None,
                 build_command: Optional[pulumi.Input[_builtins.str]] = None,
                 catchall_document: Optional[pulumi.Input[_builtins.str]] = None,
                 cors: Optional[pulumi.Input['AppSpecStaticSiteCorsArgs']] = None,
                 dockerfile_path: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_slug: Optional[pulumi.Input[_builtins.str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgs']]]] = None,
                 error_document: Optional[pulumi.Input[_builtins.str]] = None,
                 git: Optional[pulumi.Input['AppSpecStaticSiteGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecStaticSiteGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecStaticSiteGitlabArgs']] = None,
                 index_document: Optional[pulumi.Input[_builtins.str]] = None,
                 output_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgs']]]] = None,
                 source_dir: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the component.
        :param pulumi.Input['AppSpecStaticSiteBitbucketArgs'] bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param pulumi.Input[_builtins.str] build_command: An optional build command to run while building this component from source.
        :param pulumi.Input[_builtins.str] catchall_document: The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        :param pulumi.Input['AppSpecStaticSiteCorsArgs'] cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param pulumi.Input[_builtins.str] dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param pulumi.Input[_builtins.str] environment_slug: An environment slug describing the type of this app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input[_builtins.str] error_document: The name of the error document to use when serving this static site.
        :param pulumi.Input['AppSpecStaticSiteGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecStaticSiteGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecStaticSiteGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[_builtins.str] index_document: The name of the index document to use when serving this static site.
        :param pulumi.Input[_builtins.str] output_dir: An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgs']]] routes: An HTTP paths that should be routed to this component.
        :param pulumi.Input[_builtins.str] source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if catchall_document is not None:
            pulumi.set(__self__, "catchall_document", catchall_document)
        if cors is not None:
            warnings.warn("""Service level CORS rules are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""cors is deprecated: Service level CORS rules are deprecated in favor of ingresses""")
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if output_dir is not None:
            pulumi.set(__self__, "output_dir", output_dir)
        if routes is not None:
            warnings.warn("""Service level routes are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""routes is deprecated: Service level routes are deprecated in favor of ingresses""")
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional[pulumi.Input['AppSpecStaticSiteBitbucketArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @bitbucket.setter
    def bitbucket(self, value: Optional[pulumi.Input['AppSpecStaticSiteBitbucketArgs']]):
        pulumi.set(self, "bitbucket", value)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_command", value)

    @_builtins.property
    @pulumi.getter(name="catchallDocument")
    def catchall_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        """
        return pulumi.get(self, "catchall_document")

    @catchall_document.setter
    def catchall_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "catchall_document", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional[pulumi.Input['AppSpecStaticSiteCorsArgs']]:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppSpecStaticSiteCorsArgs']]):
        pulumi.set(self, "cors", value)

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dockerfile_path", value)

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @environment_slug.setter
    def environment_slug(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_slug", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the error document to use when serving this static site.
        """
        return pulumi.get(self, "error_document")

    @error_document.setter
    def error_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_document", value)

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecStaticSiteGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecStaticSiteGitArgs']]):
        pulumi.set(self, "git", value)

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecStaticSiteGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecStaticSiteGithubArgs']]):
        pulumi.set(self, "github", value)

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecStaticSiteGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecStaticSiteGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @_builtins.property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the index document to use when serving this static site.
        """
        return pulumi.get(self, "index_document")

    @index_document.setter
    def index_document(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_document", value)

    @_builtins.property
    @pulumi.getter(name="outputDir")
    def output_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        """
        return pulumi.get(self, "output_dir")

    @output_dir.setter
    def output_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_dir", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgs']]]]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_dir", value)


if not MYPY:
    class AppSpecStaticSiteBitbucketArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecStaticSiteBitbucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteBitbucketArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecStaticSiteCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        allow_origins: NotRequired[pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgsDict']]
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        max_age: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
elif False:
    AppSpecStaticSiteCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 allow_origins: Optional[pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgs']] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgs'] allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param pulumi.Input[_builtins.str] max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @_builtins.property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request’s credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_credentials", value)

    @_builtins.property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_headers", value)

    @_builtins.property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allow_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgs']]:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgs']]):
        pulumi.set(self, "allow_origins", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AppSpecStaticSiteCorsAllowOriginsArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        Exact string match.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prefix-based match.
        """
        regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        RE2 style regex-based match.
        """
elif False:
    AppSpecStaticSiteCorsAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteCorsAllowOriginsArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] exact: Exact string match.
        :param pulumi.Input[_builtins.str] prefix: Prefix-based match.
        :param pulumi.Input[_builtins.str] regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            warnings.warn("""Prefix-based matching has been deprecated in favor of regex-based matching.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Prefix-based matching has been deprecated in favor of regex-based matching.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AppSpecStaticSiteEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecStaticSiteEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the environment variable.
        :param pulumi.Input[_builtins.str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[_builtins.str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[_builtins.str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecStaticSiteGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecStaticSiteGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 repo_clone_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecStaticSiteGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecStaticSiteGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecStaticSiteGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecStaticSiteGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecStaticSiteRouteArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Paths must start with `/` and must be unique within the app.
        """
        preserve_path_prefix: NotRequired[pulumi.Input[_builtins.bool]]
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
elif False:
    AppSpecStaticSiteRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteRouteArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 preserve_path_prefix: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] path: Paths must start with `/` and must be unique within the app.
        :param pulumi.Input[_builtins.bool] preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @preserve_path_prefix.setter
    def preserve_path_prefix(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preserve_path_prefix", value)


if not MYPY:
    class AppSpecVpcArgsDict(TypedDict):
        id: pulumi.Input[_builtins.str]
        """
        The ID of the VPC.
        """
elif False:
    AppSpecVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecVpcArgs:
    def __init__(__self__, *,
                 id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] id: The ID of the VPC.
        """
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the VPC.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)


if not MYPY:
    class AppSpecWorkerArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        autoscaling: NotRequired[pulumi.Input['AppSpecWorkerAutoscalingArgsDict']]
        """
        Configuration for automatically scaling this component based on metrics.
        """
        bitbucket: NotRequired[pulumi.Input['AppSpecWorkerBitbucketArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        build_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional build command to run while building this component from source.
        """
        dockerfile_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        environment_slug: NotRequired[pulumi.Input[_builtins.str]]
        """
        An environment slug describing the type of this app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        git: NotRequired[pulumi.Input['AppSpecWorkerGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecWorkerGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecWorkerGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        image: NotRequired[pulumi.Input['AppSpecWorkerImageArgsDict']]
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        instance_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The amount of instances that this component should be scaled to.
        """
        instance_size_slug: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        log_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgsDict']]]]
        """
        Describes a log forwarding destination.
        """
        run_command: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional run command to override the component's default.
        """
        source_dir: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional path to the working directory to use for the build.
        """
        termination: NotRequired[pulumi.Input['AppSpecWorkerTerminationArgsDict']]
        """
        Contains a component's termination parameters.
        """
elif False:
    AppSpecWorkerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgs']]]] = None,
                 autoscaling: Optional[pulumi.Input['AppSpecWorkerAutoscalingArgs']] = None,
                 bitbucket: Optional[pulumi.Input['AppSpecWorkerBitbucketArgs']] = None,
                 build_command: Optional[pulumi.Input[_builtins.str]] = None,
                 dockerfile_path: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_slug: Optional[pulumi.Input[_builtins.str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgs']]]] = None,
                 git: Optional[pulumi.Input['AppSpecWorkerGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecWorkerGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecWorkerGitlabArgs']] = None,
                 image: Optional[pulumi.Input['AppSpecWorkerImageArgs']] = None,
                 instance_count: Optional[pulumi.Input[_builtins.int]] = None,
                 instance_size_slug: Optional[pulumi.Input[_builtins.str]] = None,
                 log_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgs']]]] = None,
                 run_command: Optional[pulumi.Input[_builtins.str]] = None,
                 source_dir: Optional[pulumi.Input[_builtins.str]] = None,
                 termination: Optional[pulumi.Input['AppSpecWorkerTerminationArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input['AppSpecWorkerAutoscalingArgs'] autoscaling: Configuration for automatically scaling this component based on metrics.
        :param pulumi.Input['AppSpecWorkerBitbucketArgs'] bitbucket: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        :param pulumi.Input[_builtins.str] build_command: An optional build command to run while building this component from source.
        :param pulumi.Input[_builtins.str] dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param pulumi.Input[_builtins.str] environment_slug: An environment slug describing the type of this app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input['AppSpecWorkerGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecWorkerGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecWorkerGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecWorkerImageArgs'] image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[_builtins.int] instance_count: The amount of instances that this component should be scaled to.
        :param pulumi.Input[_builtins.str] instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgs']]] log_destinations: Describes a log forwarding destination.
        :param pulumi.Input[_builtins.str] run_command: An optional run command to override the component's default.
        :param pulumi.Input[_builtins.str] source_dir: An optional path to the working directory to use for the build.
        :param pulumi.Input['AppSpecWorkerTerminationArgs'] termination: Contains a component's termination parameters.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if bitbucket is not None:
            pulumi.set(__self__, "bitbucket", bitbucket)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)
        if termination is not None:
            pulumi.set(__self__, "termination", termination)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @_builtins.property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['AppSpecWorkerAutoscalingArgs']]:
        """
        Configuration for automatically scaling this component based on metrics.
        """
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['AppSpecWorkerAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @_builtins.property
    @pulumi.getter
    def bitbucket(self) -> Optional[pulumi.Input['AppSpecWorkerBitbucketArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/bitbucket/install). Only one of `git`, `github`, `bitbucket`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "bitbucket")

    @bitbucket.setter
    def bitbucket(self, value: Optional[pulumi.Input['AppSpecWorkerBitbucketArgs']]):
        pulumi.set(self, "bitbucket", value)

    @_builtins.property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "build_command", value)

    @_builtins.property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dockerfile_path", value)

    @_builtins.property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @environment_slug.setter
    def environment_slug(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_slug", value)

    @_builtins.property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @_builtins.property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecWorkerGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecWorkerGitArgs']]):
        pulumi.set(self, "git", value)

    @_builtins.property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecWorkerGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecWorkerGithubArgs']]):
        pulumi.set(self, "github", value)

    @_builtins.property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecWorkerGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecWorkerGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['AppSpecWorkerImageArgs']]:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['AppSpecWorkerImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "instance_count", value)

    @_builtins.property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/digitalocean/#tag/Apps/operation/apps_list_instanceSizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @instance_size_slug.setter
    def instance_size_slug(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instance_size_slug", value)

    @_builtins.property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgs']]]]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @log_destinations.setter
    def log_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgs']]]]):
        pulumi.set(self, "log_destinations", value)

    @_builtins.property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @run_command.setter
    def run_command(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "run_command", value)

    @_builtins.property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_dir", value)

    @_builtins.property
    @pulumi.getter
    def termination(self) -> Optional[pulumi.Input['AppSpecWorkerTerminationArgs']]:
        """
        Contains a component's termination parameters.
        """
        return pulumi.get(self, "termination")

    @termination.setter
    def termination(self, value: Optional[pulumi.Input['AppSpecWorkerTerminationArgs']]):
        pulumi.set(self, "termination", value)


if not MYPY:
    class AppSpecWorkerAlertArgsDict(TypedDict):
        operator: pulumi.Input[_builtins.str]
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        rule: pulumi.Input[_builtins.str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        value: pulumi.Input[_builtins.float]
        """
        The threshold for the type of the warning.
        """
        window: pulumi.Input[_builtins.str]
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        destinations: NotRequired[pulumi.Input['AppSpecWorkerAlertDestinationsArgsDict']]
        """
        Specification for alert destination.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecWorkerAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerAlertArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[_builtins.str],
                 rule: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.float],
                 window: pulumi.Input[_builtins.str],
                 destinations: Optional[pulumi.Input['AppSpecWorkerAlertDestinationsArgs']] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param pulumi.Input[_builtins.str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[_builtins.float] value: The threshold for the type of the warning.
        :param pulumi.Input[_builtins.str] window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param pulumi.Input['AppSpecWorkerAlertDestinationsArgs'] destinations: Specification for alert destination.
        :param pulumi.Input[_builtins.bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def operator(self) -> pulumi.Input[_builtins.str]:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operator", value)

    @_builtins.property
    @pulumi.getter
    def rule(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "rule", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.float]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.float]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter
    def window(self) -> pulumi.Input[_builtins.str]:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "window", value)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input['AppSpecWorkerAlertDestinationsArgs']]:
        """
        Specification for alert destination.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input['AppSpecWorkerAlertDestinationsArgs']]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecWorkerAlertDestinationsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        slack_webhooks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertDestinationsSlackWebhookArgsDict']]]]
        """
        Determines which slack channels or users receive alerts.
        """
elif False:
    AppSpecWorkerAlertDestinationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerAlertDestinationsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slack_webhooks: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertDestinationsSlackWebhookArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertDestinationsSlackWebhookArgs']]] slack_webhooks: Determines which slack channels or users receive alerts.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slack_webhooks is not None:
            pulumi.set(__self__, "slack_webhooks", slack_webhooks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Determines which emails receive alerts. The emails must be team members. If not set, the team's email is used by default.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter(name="slackWebhooks")
    def slack_webhooks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertDestinationsSlackWebhookArgs']]]]:
        """
        Determines which slack channels or users receive alerts.
        """
        return pulumi.get(self, "slack_webhooks")

    @slack_webhooks.setter
    def slack_webhooks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertDestinationsSlackWebhookArgs']]]]):
        pulumi.set(self, "slack_webhooks", value)


if not MYPY:
    class AppSpecWorkerAlertDestinationsSlackWebhookArgsDict(TypedDict):
        channel: pulumi.Input[_builtins.str]
        """
        The Slack channel to send notifications to.
        """
        url: pulumi.Input[_builtins.str]
        """
        The Slack webhook URL.
        """
elif False:
    AppSpecWorkerAlertDestinationsSlackWebhookArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerAlertDestinationsSlackWebhookArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] channel: The Slack channel to send notifications to.
        :param pulumi.Input[_builtins.str] url: The Slack webhook URL.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack channel to send notifications to.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack webhook URL.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AppSpecWorkerAutoscalingArgsDict(TypedDict):
        max_instance_count: pulumi.Input[_builtins.int]
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        metrics: pulumi.Input['AppSpecWorkerAutoscalingMetricsArgsDict']
        """
        The metrics that the component is scaled on.
        """
        min_instance_count: pulumi.Input[_builtins.int]
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
elif False:
    AppSpecWorkerAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerAutoscalingArgs:
    def __init__(__self__, *,
                 max_instance_count: pulumi.Input[_builtins.int],
                 metrics: pulumi.Input['AppSpecWorkerAutoscalingMetricsArgs'],
                 min_instance_count: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count.
        :param pulumi.Input['AppSpecWorkerAutoscalingMetricsArgs'] metrics: The metrics that the component is scaled on.
        :param pulumi.Input[_builtins.int] min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_instance_count", min_instance_count)

    @_builtins.property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "max_instance_count", value)

    @_builtins.property
    @pulumi.getter
    def metrics(self) -> pulumi.Input['AppSpecWorkerAutoscalingMetricsArgs']:
        """
        The metrics that the component is scaled on.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input['AppSpecWorkerAutoscalingMetricsArgs']):
        pulumi.set(self, "metrics", value)

    @_builtins.property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> pulumi.Input[_builtins.int]:
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "min_instance_count", value)


if not MYPY:
    class AppSpecWorkerAutoscalingMetricsArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input['AppSpecWorkerAutoscalingMetricsCpuArgsDict']]
        """
        Settings for scaling the component based on CPU utilization.
        """
elif False:
    AppSpecWorkerAutoscalingMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerAutoscalingMetricsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['AppSpecWorkerAutoscalingMetricsCpuArgs']] = None):
        """
        :param pulumi.Input['AppSpecWorkerAutoscalingMetricsCpuArgs'] cpu: Settings for scaling the component based on CPU utilization.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['AppSpecWorkerAutoscalingMetricsCpuArgs']]:
        """
        Settings for scaling the component based on CPU utilization.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['AppSpecWorkerAutoscalingMetricsCpuArgs']]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class AppSpecWorkerAutoscalingMetricsCpuArgsDict(TypedDict):
        percent: pulumi.Input[_builtins.int]
        """
        The average target CPU utilization for the component.
        """
elif False:
    AppSpecWorkerAutoscalingMetricsCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerAutoscalingMetricsCpuArgs:
    def __init__(__self__, *,
                 percent: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] percent: The average target CPU utilization for the component.
        """
        pulumi.set(__self__, "percent", percent)

    @_builtins.property
    @pulumi.getter
    def percent(self) -> pulumi.Input[_builtins.int]:
        """
        The average target CPU utilization for the component.
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class AppSpecWorkerBitbucketArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecWorkerBitbucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerBitbucketArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecWorkerEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecWorkerEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 scope: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: The name of the environment variable.
        :param pulumi.Input[_builtins.str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[_builtins.str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[_builtins.str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scope", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecWorkerGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecWorkerGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 repo_clone_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecWorkerGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecWorkerGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecWorkerGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecWorkerGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[_builtins.str]] = None,
                 deploy_on_push: Optional[pulumi.Input[_builtins.bool]] = None,
                 repo: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] branch: The name of the branch to use.
        :param pulumi.Input[_builtins.bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[_builtins.str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @_builtins.property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "branch", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @_builtins.property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecWorkerImageArgsDict(TypedDict):
        registry_type: pulumi.Input[_builtins.str]
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        repository: pulumi.Input[_builtins.str]
        """
        The repository name.
        """
        deploy_on_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgsDict']]]]
        """
        Configures automatically deploying images pushed to DOCR.
        """
        digest: NotRequired[pulumi.Input[_builtins.str]]
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        registry: NotRequired[pulumi.Input[_builtins.str]]
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        registry_credentials: NotRequired[pulumi.Input[_builtins.str]]
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The repository tag. Defaults to `latest` if not provided.
        """
elif False:
    AppSpecWorkerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerImageArgs:
    def __init__(__self__, *,
                 registry_type: pulumi.Input[_builtins.str],
                 repository: pulumi.Input[_builtins.str],
                 deploy_on_pushes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgs']]]] = None,
                 digest: Optional[pulumi.Input[_builtins.str]] = None,
                 registry: Optional[pulumi.Input[_builtins.str]] = None,
                 registry_credentials: Optional[pulumi.Input[_builtins.str]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param pulumi.Input[_builtins.str] repository: The repository name.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgs']]] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param pulumi.Input[_builtins.str] digest: The image digest. Cannot be specified if `tag` is provided.
        :param pulumi.Input[_builtins.str] registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param pulumi.Input[_builtins.str] registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param pulumi.Input[_builtins.str] tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if digest is not None:
            pulumi.set(__self__, "digest", digest)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @_builtins.property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> pulumi.Input[_builtins.str]:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @registry_type.setter
    def registry_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "registry_type", value)

    @_builtins.property
    @pulumi.getter
    def repository(self) -> pulumi.Input[_builtins.str]:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "repository", value)

    @_builtins.property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgs']]]]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @deploy_on_pushes.setter
    def deploy_on_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgs']]]]):
        pulumi.set(self, "deploy_on_pushes", value)

    @_builtins.property
    @pulumi.getter
    def digest(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The image digest. Cannot be specified if `tag` is provided.
        """
        return pulumi.get(self, "digest")

    @digest.setter
    def digest(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digest", value)

    @_builtins.property
    @pulumi.getter
    def registry(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry", value)

    @_builtins.property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @registry_credentials.setter
    def registry_credentials(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "registry_credentials", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class AppSpecWorkerImageDeployOnPushArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to automatically deploy images pushed to DOCR.
        """
elif False:
    AppSpecWorkerImageDeployOnPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerImageDeployOnPushArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AppSpecWorkerLogDestinationArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        datadog: NotRequired[pulumi.Input['AppSpecWorkerLogDestinationDatadogArgsDict']]
        """
        Datadog configuration.
        """
        logtail: NotRequired[pulumi.Input['AppSpecWorkerLogDestinationLogtailArgsDict']]
        """
        Logtail configuration.
        """
        open_search: NotRequired[pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgsDict']]
        """
        OpenSearch configuration.
        """
        papertrail: NotRequired[pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgsDict']]
        """
        Papertrail configuration.
        """
elif False:
    AppSpecWorkerLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 datadog: Optional[pulumi.Input['AppSpecWorkerLogDestinationDatadogArgs']] = None,
                 logtail: Optional[pulumi.Input['AppSpecWorkerLogDestinationLogtailArgs']] = None,
                 open_search: Optional[pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgs']] = None,
                 papertrail: Optional[pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param pulumi.Input['AppSpecWorkerLogDestinationDatadogArgs'] datadog: Datadog configuration.
        :param pulumi.Input['AppSpecWorkerLogDestinationLogtailArgs'] logtail: Logtail configuration.
        :param pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgs'] open_search: OpenSearch configuration.
        :param pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgs'] papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def datadog(self) -> Optional[pulumi.Input['AppSpecWorkerLogDestinationDatadogArgs']]:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @datadog.setter
    def datadog(self, value: Optional[pulumi.Input['AppSpecWorkerLogDestinationDatadogArgs']]):
        pulumi.set(self, "datadog", value)

    @_builtins.property
    @pulumi.getter
    def logtail(self) -> Optional[pulumi.Input['AppSpecWorkerLogDestinationLogtailArgs']]:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @logtail.setter
    def logtail(self, value: Optional[pulumi.Input['AppSpecWorkerLogDestinationLogtailArgs']]):
        pulumi.set(self, "logtail", value)

    @_builtins.property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgs']]:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgs']]):
        pulumi.set(self, "open_search", value)

    @_builtins.property
    @pulumi.getter
    def papertrail(self) -> Optional[pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgs']]:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")

    @papertrail.setter
    def papertrail(self, value: Optional[pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgs']]):
        pulumi.set(self, "papertrail", value)


if not MYPY:
    class AppSpecWorkerLogDestinationDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[_builtins.str]
        """
        Datadog API key.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        Datadog HTTP log intake endpoint.
        """
elif False:
    AppSpecWorkerLogDestinationDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[_builtins.str],
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: Datadog API key.
        :param pulumi.Input[_builtins.str] endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[_builtins.str]:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecWorkerLogDestinationLogtailArgsDict(TypedDict):
        token: pulumi.Input[_builtins.str]
        """
        Logtail token.
        """
elif False:
    AppSpecWorkerLogDestinationLogtailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationLogtailArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> pulumi.Input[_builtins.str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppSpecWorkerLogDestinationOpenSearchArgsDict(TypedDict):
        basic_auth: pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgsDict']
        """
        Basic authentication details.
        """
        cluster_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenSearch endpoint.
        """
        index_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        OpenSearch index name.
        """
elif False:
    AppSpecWorkerLogDestinationOpenSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationOpenSearchArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs'],
                 cluster_name: Optional[pulumi.Input[_builtins.str]] = None,
                 endpoint: Optional[pulumi.Input[_builtins.str]] = None,
                 index_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs'] basic_auth: Basic authentication details.
        :param pulumi.Input[_builtins.str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[_builtins.str] endpoint: OpenSearch endpoint.
        :param pulumi.Input[_builtins.str] index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @_builtins.property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs']:
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @_builtins.property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class AppSpecWorkerLogDestinationOpenSearchBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        Password for basic authentication.
        """
        user: NotRequired[pulumi.Input[_builtins.str]]
        """
        user for basic authentication.
        """
elif False:
    AppSpecWorkerLogDestinationOpenSearchBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 user: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] password: Password for basic authentication.
        :param pulumi.Input[_builtins.str] user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AppSpecWorkerLogDestinationPapertrailArgsDict(TypedDict):
        endpoint: pulumi.Input[_builtins.str]
        """
        Papertrail syslog endpoint.
        """
elif False:
    AppSpecWorkerLogDestinationPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationPapertrailArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecWorkerTerminationArgsDict(TypedDict):
        grace_period_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
elif False:
    AppSpecWorkerTerminationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerTerminationArgs:
    def __init__(__self__, *,
                 grace_period_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] grace_period_seconds: The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.
               
               A `function` component can contain:
        """
        if grace_period_seconds is not None:
            pulumi.set(__self__, "grace_period_seconds", grace_period_seconds)

    @_builtins.property
    @pulumi.getter(name="gracePeriodSeconds")
    def grace_period_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds to wait between sending a TERM signal to a container and issuing a KILL which causes immediate shutdown. Default: 120, Minimum 1, Maximum 600.

        A `function` component can contain:
        """
        return pulumi.get(self, "grace_period_seconds")

    @grace_period_seconds.setter
    def grace_period_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "grace_period_seconds", value)


if not MYPY:
    class DatabaseClusterBackupRestoreArgsDict(TypedDict):
        database_name: pulumi.Input[_builtins.str]
        """
        The name of an existing database cluster from which the backup will be restored.
        """
        backup_created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
elif False:
    DatabaseClusterBackupRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseClusterBackupRestoreArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[_builtins.str],
                 backup_created_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] database_name: The name of an existing database cluster from which the backup will be restored.
        :param pulumi.Input[_builtins.str] backup_created_at: The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.
               
               This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        pulumi.set(__self__, "database_name", database_name)
        if backup_created_at is not None:
            pulumi.set(__self__, "backup_created_at", backup_created_at)

    @_builtins.property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of an existing database cluster from which the backup will be restored.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "database_name", value)

    @_builtins.property
    @pulumi.getter(name="backupCreatedAt")
    def backup_created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        return pulumi.get(self, "backup_created_at")

    @backup_created_at.setter
    def backup_created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "backup_created_at", value)


if not MYPY:
    class DatabaseClusterMaintenanceWindowArgsDict(TypedDict):
        day: pulumi.Input[_builtins.str]
        """
        The day of the week on which to apply maintenance updates. May be one of `monday` through `sunday`.
        """
        hour: pulumi.Input[_builtins.str]
        """
        The hour in UTC at which maintenance updates will be applied as a string in 24 hour format, e.g. `13:00`.
        """
elif False:
    DatabaseClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[_builtins.str],
                 hour: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] day: The day of the week on which to apply maintenance updates. May be one of `monday` through `sunday`.
        :param pulumi.Input[_builtins.str] hour: The hour in UTC at which maintenance updates will be applied as a string in 24 hour format, e.g. `13:00`.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input[_builtins.str]:
        """
        The day of the week on which to apply maintenance updates. May be one of `monday` through `sunday`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> pulumi.Input[_builtins.str]:
        """
        The hour in UTC at which maintenance updates will be applied as a string in 24 hour format, e.g. `13:00`.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class DatabaseFirewallRuleArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, `tag`, or `app`.
        """
        value: pulumi.Input[_builtins.str]
        """
        The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time when the firewall rule was created.
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique identifier for the firewall rule.
        """
elif False:
    DatabaseFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseFirewallRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, `tag`, or `app`.
        :param pulumi.Input[_builtins.str] value: The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        :param pulumi.Input[_builtins.str] created_at: The date and time when the firewall rule was created.
        :param pulumi.Input[_builtins.str] uuid: A unique identifier for the firewall rule.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, `tag`, or `app`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time when the firewall rule was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique identifier for the firewall rule.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class DatabaseKafkaTopicConfigArgsDict(TypedDict):
        cleanup_policy: NotRequired[pulumi.Input[_builtins.str]]
        """
        The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
        This may be one of "delete", "compact", or "compact_delete".
        """
        compression_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The topic compression codecs used for a given topic.
        This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        """
        delete_retention_ms: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time, in ms, that deleted records are retained.
        """
        file_delete_delay_ms: NotRequired[pulumi.Input[_builtins.str]]
        """
        The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        """
        flush_messages: NotRequired[pulumi.Input[_builtins.str]]
        """
        The number of messages accumulated on a topic partition before they are flushed to disk.
        """
        flush_ms: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        """
        index_interval_bytes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The interval, in bytes, in which entries are added to the offset index.
        """
        max_compaction_lag_ms: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        """
        max_message_bytes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum size, in bytes, of a message.
        """
        message_down_conversion_enable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether down-conversion of message formats for consumers is enabled.
        """
        message_format_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        """
        message_timestamp_difference_max_ms: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        """
        message_timestamp_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        """
        min_cleanable_dirty_ratio: NotRequired[pulumi.Input[_builtins.float]]
        """
        A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        """
        min_compaction_lag_ms: NotRequired[pulumi.Input[_builtins.str]]
        min_insync_replicas: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
        """
        preallocate: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        """
        retention_bytes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        """
        retention_ms: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        """
        segment_bytes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum size, in bytes, of a single topic log file.
        """
        segment_index_bytes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum size, in bytes, of the offset index.
        """
        segment_jitter_ms: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        """
        segment_ms: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum time, in ms, before the topic log will flush to disk.
        """
elif False:
    DatabaseKafkaTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseKafkaTopicConfigArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[pulumi.Input[_builtins.str]] = None,
                 compression_type: Optional[pulumi.Input[_builtins.str]] = None,
                 delete_retention_ms: Optional[pulumi.Input[_builtins.str]] = None,
                 file_delete_delay_ms: Optional[pulumi.Input[_builtins.str]] = None,
                 flush_messages: Optional[pulumi.Input[_builtins.str]] = None,
                 flush_ms: Optional[pulumi.Input[_builtins.str]] = None,
                 index_interval_bytes: Optional[pulumi.Input[_builtins.str]] = None,
                 max_compaction_lag_ms: Optional[pulumi.Input[_builtins.str]] = None,
                 max_message_bytes: Optional[pulumi.Input[_builtins.str]] = None,
                 message_down_conversion_enable: Optional[pulumi.Input[_builtins.bool]] = None,
                 message_format_version: Optional[pulumi.Input[_builtins.str]] = None,
                 message_timestamp_difference_max_ms: Optional[pulumi.Input[_builtins.str]] = None,
                 message_timestamp_type: Optional[pulumi.Input[_builtins.str]] = None,
                 min_cleanable_dirty_ratio: Optional[pulumi.Input[_builtins.float]] = None,
                 min_compaction_lag_ms: Optional[pulumi.Input[_builtins.str]] = None,
                 min_insync_replicas: Optional[pulumi.Input[_builtins.int]] = None,
                 preallocate: Optional[pulumi.Input[_builtins.bool]] = None,
                 retention_bytes: Optional[pulumi.Input[_builtins.str]] = None,
                 retention_ms: Optional[pulumi.Input[_builtins.str]] = None,
                 segment_bytes: Optional[pulumi.Input[_builtins.str]] = None,
                 segment_index_bytes: Optional[pulumi.Input[_builtins.str]] = None,
                 segment_jitter_ms: Optional[pulumi.Input[_builtins.str]] = None,
                 segment_ms: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cleanup_policy: The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
               This may be one of "delete", "compact", or "compact_delete".
        :param pulumi.Input[_builtins.str] compression_type: The topic compression codecs used for a given topic.
               This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        :param pulumi.Input[_builtins.str] delete_retention_ms: The amount of time, in ms, that deleted records are retained.
        :param pulumi.Input[_builtins.str] file_delete_delay_ms: The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        :param pulumi.Input[_builtins.str] flush_messages: The number of messages accumulated on a topic partition before they are flushed to disk.
        :param pulumi.Input[_builtins.str] flush_ms: The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        :param pulumi.Input[_builtins.str] index_interval_bytes: The interval, in bytes, in which entries are added to the offset index.
        :param pulumi.Input[_builtins.str] max_compaction_lag_ms: The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        :param pulumi.Input[_builtins.str] max_message_bytes: The maximum size, in bytes, of a message.
        :param pulumi.Input[_builtins.bool] message_down_conversion_enable: Determines whether down-conversion of message formats for consumers is enabled.
        :param pulumi.Input[_builtins.str] message_format_version: The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        :param pulumi.Input[_builtins.str] message_timestamp_difference_max_ms: The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        :param pulumi.Input[_builtins.str] message_timestamp_type: Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        :param pulumi.Input[_builtins.float] min_cleanable_dirty_ratio: A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        :param pulumi.Input[_builtins.int] min_insync_replicas: The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
        :param pulumi.Input[_builtins.bool] preallocate: Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        :param pulumi.Input[_builtins.str] retention_bytes: The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        :param pulumi.Input[_builtins.str] retention_ms: The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        :param pulumi.Input[_builtins.str] segment_bytes: The maximum size, in bytes, of a single topic log file.
        :param pulumi.Input[_builtins.str] segment_index_bytes: The maximum size, in bytes, of the offset index.
        :param pulumi.Input[_builtins.str] segment_jitter_ms: The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        :param pulumi.Input[_builtins.str] segment_ms: The maximum time, in ms, before the topic log will flush to disk.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if index_interval_bytes is not None:
            pulumi.set(__self__, "index_interval_bytes", index_interval_bytes)
        if max_compaction_lag_ms is not None:
            pulumi.set(__self__, "max_compaction_lag_ms", max_compaction_lag_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if message_down_conversion_enable is not None:
            pulumi.set(__self__, "message_down_conversion_enable", message_down_conversion_enable)
        if message_format_version is not None:
            pulumi.set(__self__, "message_format_version", message_format_version)
        if message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "message_timestamp_difference_max_ms", message_timestamp_difference_max_ms)
        if message_timestamp_type is not None:
            pulumi.set(__self__, "message_timestamp_type", message_timestamp_type)
        if min_cleanable_dirty_ratio is not None:
            pulumi.set(__self__, "min_cleanable_dirty_ratio", min_cleanable_dirty_ratio)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)
        if segment_index_bytes is not None:
            pulumi.set(__self__, "segment_index_bytes", segment_index_bytes)
        if segment_jitter_ms is not None:
            pulumi.set(__self__, "segment_jitter_ms", segment_jitter_ms)
        if segment_ms is not None:
            pulumi.set(__self__, "segment_ms", segment_ms)

    @_builtins.property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
        This may be one of "delete", "compact", or "compact_delete".
        """
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cleanup_policy", value)

    @_builtins.property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The topic compression codecs used for a given topic.
        This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "compression_type", value)

    @_builtins.property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time, in ms, that deleted records are retained.
        """
        return pulumi.get(self, "delete_retention_ms")

    @delete_retention_ms.setter
    def delete_retention_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete_retention_ms", value)

    @_builtins.property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        """
        return pulumi.get(self, "file_delete_delay_ms")

    @file_delete_delay_ms.setter
    def file_delete_delay_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "file_delete_delay_ms", value)

    @_builtins.property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The number of messages accumulated on a topic partition before they are flushed to disk.
        """
        return pulumi.get(self, "flush_messages")

    @flush_messages.setter
    def flush_messages(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flush_messages", value)

    @_builtins.property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        """
        return pulumi.get(self, "flush_ms")

    @flush_ms.setter
    def flush_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flush_ms", value)

    @_builtins.property
    @pulumi.getter(name="indexIntervalBytes")
    def index_interval_bytes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The interval, in bytes, in which entries are added to the offset index.
        """
        return pulumi.get(self, "index_interval_bytes")

    @index_interval_bytes.setter
    def index_interval_bytes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "index_interval_bytes", value)

    @_builtins.property
    @pulumi.getter(name="maxCompactionLagMs")
    def max_compaction_lag_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        """
        return pulumi.get(self, "max_compaction_lag_ms")

    @max_compaction_lag_ms.setter
    def max_compaction_lag_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_compaction_lag_ms", value)

    @_builtins.property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum size, in bytes, of a message.
        """
        return pulumi.get(self, "max_message_bytes")

    @max_message_bytes.setter
    def max_message_bytes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_message_bytes", value)

    @_builtins.property
    @pulumi.getter(name="messageDownConversionEnable")
    def message_down_conversion_enable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether down-conversion of message formats for consumers is enabled.
        """
        return pulumi.get(self, "message_down_conversion_enable")

    @message_down_conversion_enable.setter
    def message_down_conversion_enable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "message_down_conversion_enable", value)

    @_builtins.property
    @pulumi.getter(name="messageFormatVersion")
    def message_format_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        """
        return pulumi.get(self, "message_format_version")

    @message_format_version.setter
    def message_format_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_format_version", value)

    @_builtins.property
    @pulumi.getter(name="messageTimestampDifferenceMaxMs")
    def message_timestamp_difference_max_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        """
        return pulumi.get(self, "message_timestamp_difference_max_ms")

    @message_timestamp_difference_max_ms.setter
    def message_timestamp_difference_max_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_timestamp_difference_max_ms", value)

    @_builtins.property
    @pulumi.getter(name="messageTimestampType")
    def message_timestamp_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        """
        return pulumi.get(self, "message_timestamp_type")

    @message_timestamp_type.setter
    def message_timestamp_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_timestamp_type", value)

    @_builtins.property
    @pulumi.getter(name="minCleanableDirtyRatio")
    def min_cleanable_dirty_ratio(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        """
        return pulumi.get(self, "min_cleanable_dirty_ratio")

    @min_cleanable_dirty_ratio.setter
    def min_cleanable_dirty_ratio(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "min_cleanable_dirty_ratio", value)

    @_builtins.property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @min_compaction_lag_ms.setter
    def min_compaction_lag_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_compaction_lag_ms", value)

    @_builtins.property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
        """
        return pulumi.get(self, "min_insync_replicas")

    @min_insync_replicas.setter
    def min_insync_replicas(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_insync_replicas", value)

    @_builtins.property
    @pulumi.getter
    def preallocate(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        """
        return pulumi.get(self, "preallocate")

    @preallocate.setter
    def preallocate(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "preallocate", value)

    @_builtins.property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        """
        return pulumi.get(self, "retention_bytes")

    @retention_bytes.setter
    def retention_bytes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retention_bytes", value)

    @_builtins.property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        """
        return pulumi.get(self, "retention_ms")

    @retention_ms.setter
    def retention_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "retention_ms", value)

    @_builtins.property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum size, in bytes, of a single topic log file.
        """
        return pulumi.get(self, "segment_bytes")

    @segment_bytes.setter
    def segment_bytes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "segment_bytes", value)

    @_builtins.property
    @pulumi.getter(name="segmentIndexBytes")
    def segment_index_bytes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum size, in bytes, of the offset index.
        """
        return pulumi.get(self, "segment_index_bytes")

    @segment_index_bytes.setter
    def segment_index_bytes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "segment_index_bytes", value)

    @_builtins.property
    @pulumi.getter(name="segmentJitterMs")
    def segment_jitter_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        """
        return pulumi.get(self, "segment_jitter_ms")

    @segment_jitter_ms.setter
    def segment_jitter_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "segment_jitter_ms", value)

    @_builtins.property
    @pulumi.getter(name="segmentMs")
    def segment_ms(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum time, in ms, before the topic log will flush to disk.
        """
        return pulumi.get(self, "segment_ms")

    @segment_ms.setter
    def segment_ms(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "segment_ms", value)


if not MYPY:
    class DatabaseOnlineMigrationSourceArgsDict(TypedDict):
        db_name: pulumi.Input[_builtins.str]
        """
        The name of the default database
        """
        host: pulumi.Input[_builtins.str]
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        password: pulumi.Input[_builtins.str]
        """
        A randomly generated password for the default user.
        """
        port: pulumi.Input[_builtins.int]
        """
        The port on which the database cluster is listening.
        """
        username: pulumi.Input[_builtins.str]
        """
        The default user for the database.
        """
elif False:
    DatabaseOnlineMigrationSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseOnlineMigrationSourceArgs:
    def __init__(__self__, *,
                 db_name: pulumi.Input[_builtins.str],
                 host: pulumi.Input[_builtins.str],
                 password: pulumi.Input[_builtins.str],
                 port: pulumi.Input[_builtins.int],
                 username: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] db_name: The name of the default database
        :param pulumi.Input[_builtins.str] host: The FQDN pointing to the database cluster's current primary node.
        :param pulumi.Input[_builtins.str] password: A randomly generated password for the default user.
        :param pulumi.Input[_builtins.int] port: The port on which the database cluster is listening.
        :param pulumi.Input[_builtins.str] username: The default user for the database.
        """
        pulumi.set(__self__, "db_name", db_name)
        pulumi.set(__self__, "host", host)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter(name="dbName")
    def db_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the default database
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "db_name", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> pulumi.Input[_builtins.str]:
        """
        The FQDN pointing to the database cluster's current primary node.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> pulumi.Input[_builtins.str]:
        """
        A randomly generated password for the default user.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        The port on which the database cluster is listening.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> pulumi.Input[_builtins.str]:
        """
        The default user for the database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class DatabasePostgresqlConfigPgbouncerArgsDict(TypedDict):
        autodb_idle_timeout: NotRequired[pulumi.Input[_builtins.int]]
        autodb_max_db_connections: NotRequired[pulumi.Input[_builtins.int]]
        autodb_pool_mode: NotRequired[pulumi.Input[_builtins.str]]
        autodb_pool_size: NotRequired[pulumi.Input[_builtins.int]]
        ignore_startup_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        min_pool_size: NotRequired[pulumi.Input[_builtins.int]]
        server_idle_timeout: NotRequired[pulumi.Input[_builtins.int]]
        server_lifetime: NotRequired[pulumi.Input[_builtins.int]]
        server_reset_query_always: NotRequired[pulumi.Input[_builtins.bool]]
elif False:
    DatabasePostgresqlConfigPgbouncerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabasePostgresqlConfigPgbouncerArgs:
    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 autodb_max_db_connections: Optional[pulumi.Input[_builtins.int]] = None,
                 autodb_pool_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 autodb_pool_size: Optional[pulumi.Input[_builtins.int]] = None,
                 ignore_startup_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 min_pool_size: Optional[pulumi.Input[_builtins.int]] = None,
                 server_idle_timeout: Optional[pulumi.Input[_builtins.int]] = None,
                 server_lifetime: Optional[pulumi.Input[_builtins.int]] = None,
                 server_reset_query_always: Optional[pulumi.Input[_builtins.bool]] = None):
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @_builtins.property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "autodb_idle_timeout")

    @autodb_idle_timeout.setter
    def autodb_idle_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "autodb_idle_timeout", value)

    @_builtins.property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "autodb_max_db_connections")

    @autodb_max_db_connections.setter
    def autodb_max_db_connections(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "autodb_max_db_connections", value)

    @_builtins.property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "autodb_pool_mode")

    @autodb_pool_mode.setter
    def autodb_pool_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "autodb_pool_mode", value)

    @_builtins.property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "autodb_pool_size")

    @autodb_pool_size.setter
    def autodb_pool_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "autodb_pool_size", value)

    @_builtins.property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "ignore_startup_parameters")

    @ignore_startup_parameters.setter
    def ignore_startup_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ignore_startup_parameters", value)

    @_builtins.property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "min_pool_size")

    @min_pool_size.setter
    def min_pool_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_pool_size", value)

    @_builtins.property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "server_idle_timeout")

    @server_idle_timeout.setter
    def server_idle_timeout(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "server_idle_timeout", value)

    @_builtins.property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "server_lifetime")

    @server_lifetime.setter
    def server_lifetime(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "server_lifetime", value)

    @_builtins.property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "server_reset_query_always")

    @server_reset_query_always.setter
    def server_reset_query_always(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "server_reset_query_always", value)


if not MYPY:
    class DatabasePostgresqlConfigTimescaledbArgsDict(TypedDict):
        max_background_workers: NotRequired[pulumi.Input[_builtins.int]]
elif False:
    DatabasePostgresqlConfigTimescaledbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabasePostgresqlConfigTimescaledbArgs:
    def __init__(__self__, *,
                 max_background_workers: Optional[pulumi.Input[_builtins.int]] = None):
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @_builtins.property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "max_background_workers")

    @max_background_workers.setter
    def max_background_workers(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_background_workers", value)


if not MYPY:
    class DatabaseUserSettingArgsDict(TypedDict):
        acls: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgsDict']]]]
        """
        A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:

        An individual ACL includes the following:
        """
        opensearch_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingOpensearchAclArgsDict']]]]
elif False:
    DatabaseUserSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserSettingArgs:
    def __init__(__self__, *,
                 acls: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgs']]]] = None,
                 opensearch_acls: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingOpensearchAclArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgs']]] acls: A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:
               
               An individual ACL includes the following:
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if opensearch_acls is not None:
            pulumi.set(__self__, "opensearch_acls", opensearch_acls)

    @_builtins.property
    @pulumi.getter
    def acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgs']]]]:
        """
        A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:

        An individual ACL includes the following:
        """
        return pulumi.get(self, "acls")

    @acls.setter
    def acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgs']]]]):
        pulumi.set(self, "acls", value)

    @_builtins.property
    @pulumi.getter(name="opensearchAcls")
    def opensearch_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingOpensearchAclArgs']]]]:
        return pulumi.get(self, "opensearch_acls")

    @opensearch_acls.setter
    def opensearch_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingOpensearchAclArgs']]]]):
        pulumi.set(self, "opensearch_acls", value)


if not MYPY:
    class DatabaseUserSettingAclArgsDict(TypedDict):
        permission: pulumi.Input[_builtins.str]
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        topic: pulumi.Input[_builtins.str]
        """
        A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "*", "<prefix>*", or "<literal>". "*" is a special value indicating a wildcard that matches on all topics. "<prefix>*" defines a regex that matches all topics with the prefix. "<literal>" performs an exact match on a topic name and only applies to that topic.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        An identifier for the ACL, this will be automatically assigned when you create an ACL entry
        """
elif False:
    DatabaseUserSettingAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserSettingAclArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[_builtins.str],
                 topic: pulumi.Input[_builtins.str],
                 id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] permission: The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        :param pulumi.Input[_builtins.str] topic: A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "*", "<prefix>*", or "<literal>". "*" is a special value indicating a wildcard that matches on all topics. "<prefix>*" defines a regex that matches all topics with the prefix. "<literal>" performs an exact match on a topic name and only applies to that topic.
        :param pulumi.Input[_builtins.str] id: An identifier for the ACL, this will be automatically assigned when you create an ACL entry
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "topic", topic)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> pulumi.Input[_builtins.str]:
        """
        A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "*", "<prefix>*", or "<literal>". "*" is a special value indicating a wildcard that matches on all topics. "<prefix>*" defines a regex that matches all topics with the prefix. "<literal>" performs an exact match on a topic name and only applies to that topic.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "topic", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An identifier for the ACL, this will be automatically assigned when you create an ACL entry
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DatabaseUserSettingOpensearchAclArgsDict(TypedDict):
        index: pulumi.Input[_builtins.str]
        permission: pulumi.Input[_builtins.str]
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
elif False:
    DatabaseUserSettingOpensearchAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserSettingOpensearchAclArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[_builtins.str],
                 permission: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] permission: The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def index(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "index", value)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class DropletAutoscaleConfigArgsDict(TypedDict):
        cooldown_minutes: NotRequired[pulumi.Input[_builtins.int]]
        """
        The cooldown duration between scaling events for the Droplet Autoscale pool.
        """
        max_instances: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of instances to maintain in the Droplet Autoscale pool.
        """
        min_instances: NotRequired[pulumi.Input[_builtins.int]]
        """
        The minimum number of instances to maintain in the Droplet Autoscale pool.
        """
        target_cpu_utilization: NotRequired[pulumi.Input[_builtins.float]]
        """
        The target average CPU load (in range `[0, 1]`) to maintain in the Droplet Autoscale pool.
        """
        target_memory_utilization: NotRequired[pulumi.Input[_builtins.float]]
        """
        The target average Memory load (in range `[0, 1]`) to maintain in the Droplet Autoscale 
        pool.
        """
        target_number_instances: NotRequired[pulumi.Input[_builtins.int]]
        """
        The static number of instances to maintain in the pool Droplet Autoscale pool. This
        argument cannot be used with any other config options.
        """
elif False:
    DropletAutoscaleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DropletAutoscaleConfigArgs:
    def __init__(__self__, *,
                 cooldown_minutes: Optional[pulumi.Input[_builtins.int]] = None,
                 max_instances: Optional[pulumi.Input[_builtins.int]] = None,
                 min_instances: Optional[pulumi.Input[_builtins.int]] = None,
                 target_cpu_utilization: Optional[pulumi.Input[_builtins.float]] = None,
                 target_memory_utilization: Optional[pulumi.Input[_builtins.float]] = None,
                 target_number_instances: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] cooldown_minutes: The cooldown duration between scaling events for the Droplet Autoscale pool.
        :param pulumi.Input[_builtins.int] max_instances: The maximum number of instances to maintain in the Droplet Autoscale pool.
        :param pulumi.Input[_builtins.int] min_instances: The minimum number of instances to maintain in the Droplet Autoscale pool.
        :param pulumi.Input[_builtins.float] target_cpu_utilization: The target average CPU load (in range `[0, 1]`) to maintain in the Droplet Autoscale pool.
        :param pulumi.Input[_builtins.float] target_memory_utilization: The target average Memory load (in range `[0, 1]`) to maintain in the Droplet Autoscale 
               pool.
        :param pulumi.Input[_builtins.int] target_number_instances: The static number of instances to maintain in the pool Droplet Autoscale pool. This
               argument cannot be used with any other config options.
        """
        if cooldown_minutes is not None:
            pulumi.set(__self__, "cooldown_minutes", cooldown_minutes)
        if max_instances is not None:
            pulumi.set(__self__, "max_instances", max_instances)
        if min_instances is not None:
            pulumi.set(__self__, "min_instances", min_instances)
        if target_cpu_utilization is not None:
            pulumi.set(__self__, "target_cpu_utilization", target_cpu_utilization)
        if target_memory_utilization is not None:
            pulumi.set(__self__, "target_memory_utilization", target_memory_utilization)
        if target_number_instances is not None:
            pulumi.set(__self__, "target_number_instances", target_number_instances)

    @_builtins.property
    @pulumi.getter(name="cooldownMinutes")
    def cooldown_minutes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The cooldown duration between scaling events for the Droplet Autoscale pool.
        """
        return pulumi.get(self, "cooldown_minutes")

    @cooldown_minutes.setter
    def cooldown_minutes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cooldown_minutes", value)

    @_builtins.property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of instances to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "max_instances")

    @max_instances.setter
    def max_instances(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_instances", value)

    @_builtins.property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The minimum number of instances to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "min_instances")

    @min_instances.setter
    def min_instances(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_instances", value)

    @_builtins.property
    @pulumi.getter(name="targetCpuUtilization")
    def target_cpu_utilization(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The target average CPU load (in range `[0, 1]`) to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "target_cpu_utilization")

    @target_cpu_utilization.setter
    def target_cpu_utilization(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "target_cpu_utilization", value)

    @_builtins.property
    @pulumi.getter(name="targetMemoryUtilization")
    def target_memory_utilization(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The target average Memory load (in range `[0, 1]`) to maintain in the Droplet Autoscale 
        pool.
        """
        return pulumi.get(self, "target_memory_utilization")

    @target_memory_utilization.setter
    def target_memory_utilization(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "target_memory_utilization", value)

    @_builtins.property
    @pulumi.getter(name="targetNumberInstances")
    def target_number_instances(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The static number of instances to maintain in the pool Droplet Autoscale pool. This
        argument cannot be used with any other config options.
        """
        return pulumi.get(self, "target_number_instances")

    @target_number_instances.setter
    def target_number_instances(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "target_number_instances", value)


if not MYPY:
    class DropletAutoscaleCurrentUtilizationArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[_builtins.float]]
        """
        Average CPU utilization
        """
        memory: NotRequired[pulumi.Input[_builtins.float]]
        """
        Average Memory utilization
        """
elif False:
    DropletAutoscaleCurrentUtilizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DropletAutoscaleCurrentUtilizationArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[_builtins.float]] = None,
                 memory: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] cpu: Average CPU utilization
        :param pulumi.Input[_builtins.float] memory: Average Memory utilization
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @_builtins.property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Average CPU utilization
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "cpu", value)

    @_builtins.property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Average Memory utilization
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class DropletAutoscaleDropletTemplateArgsDict(TypedDict):
        image: pulumi.Input[_builtins.str]
        """
        Image slug of the Droplet Autoscale pool underlying resource(s).
        """
        region: pulumi.Input[_builtins.str]
        """
        Region slug of the Droplet Autoscale pool underlying resource(s).
        """
        size: pulumi.Input[_builtins.str]
        """
        Size slug of the Droplet Autoscale pool underlying resource(s).
        """
        ssh_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        SSH fingerprints to add to the Droplet Autoscale pool underlying resource(s).
        """
        ipv6: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean flag to enable IPv6 networking on the Droplet Autoscale pool underlying resource(s).
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project UUID to create the Droplet Autoscale pool underlying resource(s).
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tags to add to the Droplet Autoscale pool underlying resource(s).
        """
        user_data: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom user data that can be added to the Droplet Autoscale pool underlying resource(s). This can be a 
        cloud init script that user may configure to setup their application workload.
        """
        vpc_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        VPC UUID to create the Droplet Autoscale pool underlying resource(s). If not provided, this is inferred
        from the specified `region` (default VPC).
        """
        with_droplet_agent: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean flag to enable metric agent on the Droplet Autoscale pool underlying resource(s). The
        metric agent enables collecting resource utilization metrics, which allows making resource based scaling decisions.
        """
elif False:
    DropletAutoscaleDropletTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DropletAutoscaleDropletTemplateArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.str],
                 ssh_keys: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ipv6: Optional[pulumi.Input[_builtins.bool]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 user_data: Optional[pulumi.Input[_builtins.str]] = None,
                 vpc_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 with_droplet_agent: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] image: Image slug of the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[_builtins.str] region: Region slug of the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[_builtins.str] size: Size slug of the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ssh_keys: SSH fingerprints to add to the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[_builtins.bool] ipv6: Boolean flag to enable IPv6 networking on the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[_builtins.str] project_id: Project UUID to create the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: List of tags to add to the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[_builtins.str] user_data: Custom user data that can be added to the Droplet Autoscale pool underlying resource(s). This can be a 
               cloud init script that user may configure to setup their application workload.
        :param pulumi.Input[_builtins.str] vpc_uuid: VPC UUID to create the Droplet Autoscale pool underlying resource(s). If not provided, this is inferred
               from the specified `region` (default VPC).
        :param pulumi.Input[_builtins.bool] with_droplet_agent: Boolean flag to enable metric agent on the Droplet Autoscale pool underlying resource(s). The
               metric agent enables collecting resource utilization metrics, which allows making resource based scaling decisions.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vpc_uuid is not None:
            pulumi.set(__self__, "vpc_uuid", vpc_uuid)
        if with_droplet_agent is not None:
            pulumi.set(__self__, "with_droplet_agent", with_droplet_agent)

    @_builtins.property
    @pulumi.getter
    def image(self) -> pulumi.Input[_builtins.str]:
        """
        Image slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        """
        Size slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        SSH fingerprints to add to the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "ssh_keys", value)

    @_builtins.property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean flag to enable IPv6 networking on the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ipv6", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project UUID to create the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tags to add to the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom user data that can be added to the Droplet Autoscale pool underlying resource(s). This can be a 
        cloud init script that user may configure to setup their application workload.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_data", value)

    @_builtins.property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        VPC UUID to create the Droplet Autoscale pool underlying resource(s). If not provided, this is inferred
        from the specified `region` (default VPC).
        """
        return pulumi.get(self, "vpc_uuid")

    @vpc_uuid.setter
    def vpc_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "vpc_uuid", value)

    @_builtins.property
    @pulumi.getter(name="withDropletAgent")
    def with_droplet_agent(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean flag to enable metric agent on the Droplet Autoscale pool underlying resource(s). The
        metric agent enables collecting resource utilization metrics, which allows making resource based scaling decisions.
        """
        return pulumi.get(self, "with_droplet_agent")

    @with_droplet_agent.setter
    def with_droplet_agent(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "with_droplet_agent", value)


if not MYPY:
    class DropletBackupPolicyArgsDict(TypedDict):
        hour: NotRequired[pulumi.Input[_builtins.int]]
        """
        The hour of the day that the backup window will start (`0`, `4`, `8`, `12`, `16`, `20`).
        """
        plan: NotRequired[pulumi.Input[_builtins.str]]
        """
        The backup plan used for the Droplet. The plan can be either `daily` or `weekly`.
        """
        weekday: NotRequired[pulumi.Input[_builtins.str]]
        """
        The day of the week on which the backup will occur (`SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`).
        """
elif False:
    DropletBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DropletBackupPolicyArgs:
    def __init__(__self__, *,
                 hour: Optional[pulumi.Input[_builtins.int]] = None,
                 plan: Optional[pulumi.Input[_builtins.str]] = None,
                 weekday: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] hour: The hour of the day that the backup window will start (`0`, `4`, `8`, `12`, `16`, `20`).
        :param pulumi.Input[_builtins.str] plan: The backup plan used for the Droplet. The plan can be either `daily` or `weekly`.
        :param pulumi.Input[_builtins.str] weekday: The day of the week on which the backup will occur (`SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`).
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if weekday is not None:
            pulumi.set(__self__, "weekday", weekday)

    @_builtins.property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The hour of the day that the backup window will start (`0`, `4`, `8`, `12`, `16`, `20`).
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "hour", value)

    @_builtins.property
    @pulumi.getter
    def plan(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The backup plan used for the Droplet. The plan can be either `daily` or `weekly`.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "plan", value)

    @_builtins.property
    @pulumi.getter
    def weekday(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The day of the week on which the backup will occur (`SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`).
        """
        return pulumi.get(self, "weekday")

    @weekday.setter
    def weekday(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "weekday", value)


if not MYPY:
    class FirewallInboundRuleArgsDict(TypedDict):
        protocol: pulumi.Input[_builtins.str]
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        port_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        source_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        source_droplet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        source_kubernetes_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array containing the IDs of
        the Kubernetes clusters from which the inbound traffic will be accepted.
        """
        source_load_balancer_uids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        source_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array containing the names of Tags
        corresponding to groups of Droplets from which the inbound traffic
        will be accepted.
        """
elif False:
    FirewallInboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallInboundRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[_builtins.str],
                 port_range: Optional[pulumi.Input[_builtins.str]] = None,
                 source_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 source_droplet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 source_kubernetes_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 source_load_balancer_uids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 source_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param pulumi.Input[_builtins.str] port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
               inbound traffic will be accepted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] source_droplet_ids: An array containing the IDs of
               the Droplets from which the inbound traffic will be accepted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_kubernetes_ids: An array containing the IDs of
               the Kubernetes clusters from which the inbound traffic will be accepted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_load_balancer_uids: An array containing the IDs
               of the Load Balancers from which the inbound traffic will be accepted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] source_tags: An array containing the names of Tags
               corresponding to groups of Droplets from which the inbound traffic
               will be accepted.
        """
        pulumi.set(__self__, "protocol", protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_droplet_ids is not None:
            pulumi.set(__self__, "source_droplet_ids", source_droplet_ids)
        if source_kubernetes_ids is not None:
            pulumi.set(__self__, "source_kubernetes_ids", source_kubernetes_ids)
        if source_load_balancer_uids is not None:
            pulumi.set(__self__, "source_load_balancer_uids", source_load_balancer_uids)
        if source_tags is not None:
            pulumi.set(__self__, "source_tags", source_tags)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_addresses", value)

    @_builtins.property
    @pulumi.getter(name="sourceDropletIds")
    def source_droplet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_droplet_ids")

    @source_droplet_ids.setter
    def source_droplet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "source_droplet_ids", value)

    @_builtins.property
    @pulumi.getter(name="sourceKubernetesIds")
    def source_kubernetes_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array containing the IDs of
        the Kubernetes clusters from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_kubernetes_ids")

    @source_kubernetes_ids.setter
    def source_kubernetes_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_kubernetes_ids", value)

    @_builtins.property
    @pulumi.getter(name="sourceLoadBalancerUids")
    def source_load_balancer_uids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_load_balancer_uids")

    @source_load_balancer_uids.setter
    def source_load_balancer_uids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_load_balancer_uids", value)

    @_builtins.property
    @pulumi.getter(name="sourceTags")
    def source_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets from which the inbound traffic
        will be accepted.
        """
        return pulumi.get(self, "source_tags")

    @source_tags.setter
    def source_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "source_tags", value)


if not MYPY:
    class FirewallOutboundRuleArgsDict(TypedDict):
        protocol: pulumi.Input[_builtins.str]
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        destination_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        destination_droplet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        destination_kubernetes_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array containing the IDs of
        the Kubernetes clusters to which the outbound traffic will be allowed.
        """
        destination_load_balancer_uids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        destination_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        """
        port_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
elif False:
    FirewallOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallOutboundRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[_builtins.str],
                 destination_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 destination_droplet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]] = None,
                 destination_kubernetes_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 destination_load_balancer_uids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 destination_tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 port_range: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
               outbound traffic will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] destination_droplet_ids: An array containing the IDs of
               the Droplets to which the outbound traffic will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_kubernetes_ids: An array containing the IDs of
               the Kubernetes clusters to which the outbound traffic will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_load_balancer_uids: An array containing the IDs
               of the Load Balancers to which the outbound traffic will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] destination_tags: An array containing the names of Tags
               corresponding to groups of Droplets to which the outbound traffic will
               be allowed.
        :param pulumi.Input[_builtins.str] port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        """
        pulumi.set(__self__, "protocol", protocol)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_droplet_ids is not None:
            pulumi.set(__self__, "destination_droplet_ids", destination_droplet_ids)
        if destination_kubernetes_ids is not None:
            pulumi.set(__self__, "destination_kubernetes_ids", destination_kubernetes_ids)
        if destination_load_balancer_uids is not None:
            pulumi.set(__self__, "destination_load_balancer_uids", destination_load_balancer_uids)
        if destination_tags is not None:
            pulumi.set(__self__, "destination_tags", destination_tags)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_addresses", value)

    @_builtins.property
    @pulumi.getter(name="destinationDropletIds")
    def destination_droplet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]:
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_droplet_ids")

    @destination_droplet_ids.setter
    def destination_droplet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "destination_droplet_ids", value)

    @_builtins.property
    @pulumi.getter(name="destinationKubernetesIds")
    def destination_kubernetes_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array containing the IDs of
        the Kubernetes clusters to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_kubernetes_ids")

    @destination_kubernetes_ids.setter
    def destination_kubernetes_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_kubernetes_ids", value)

    @_builtins.property
    @pulumi.getter(name="destinationLoadBalancerUids")
    def destination_load_balancer_uids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_load_balancer_uids")

    @destination_load_balancer_uids.setter
    def destination_load_balancer_uids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_load_balancer_uids", value)

    @_builtins.property
    @pulumi.getter(name="destinationTags")
    def destination_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        """
        return pulumi.get(self, "destination_tags")

    @destination_tags.setter
    def destination_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "destination_tags", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "port_range", value)


if not MYPY:
    class FirewallPendingChangeArgsDict(TypedDict):
        droplet_id: NotRequired[pulumi.Input[_builtins.int]]
        removing: NotRequired[pulumi.Input[_builtins.bool]]
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        A status string indicating the current state of the Firewall.
        This can be "waiting", "succeeded", or "failed".
        """
elif False:
    FirewallPendingChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPendingChangeArgs:
    def __init__(__self__, *,
                 droplet_id: Optional[pulumi.Input[_builtins.int]] = None,
                 removing: Optional[pulumi.Input[_builtins.bool]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] status: A status string indicating the current state of the Firewall.
               This can be "waiting", "succeeded", or "failed".
        """
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if removing is not None:
            pulumi.set(__self__, "removing", removing)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "droplet_id", value)

    @_builtins.property
    @pulumi.getter
    def removing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        return pulumi.get(self, "removing")

    @removing.setter
    def removing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "removing", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A status string indicating the current state of the Firewall.
        This can be "waiting", "succeeded", or "failed".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class GenaiAgentAgentGuardrailArgsDict(TypedDict):
        agent_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent UUID for the Guardrail
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Guardrail
        """
        default_response: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default response for the Guardrail
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Guardrail
        """
        guardrail_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Guardrail UUID
        """
        is_attached: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Guardrail is attached
        """
        is_default: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Guardrail is default
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of Guardrail
        """
        priority: NotRequired[pulumi.Input[_builtins.int]]
        """
        Priority of the Guardrail
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the Guardrail
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the Guardrail
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Guardrail UUID
        """
elif False:
    GenaiAgentAgentGuardrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentAgentGuardrailArgs:
    def __init__(__self__, *,
                 agent_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 default_response: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 guardrail_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 is_attached: Optional[pulumi.Input[_builtins.bool]] = None,
                 is_default: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 priority: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agent_uuid: Agent UUID for the Guardrail
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Guardrail
        :param pulumi.Input[_builtins.str] default_response: Default response for the Guardrail
        :param pulumi.Input[_builtins.str] description: Description of the Guardrail
        :param pulumi.Input[_builtins.str] guardrail_uuid: Guardrail UUID
        :param pulumi.Input[_builtins.bool] is_attached: Indicates if the Guardrail is attached
        :param pulumi.Input[_builtins.bool] is_default: Indicates if the Guardrail is default
        :param pulumi.Input[_builtins.str] name: Name of Guardrail
        :param pulumi.Input[_builtins.int] priority: Priority of the Guardrail
        :param pulumi.Input[_builtins.str] type: Type of the Guardrail
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the Guardrail
        :param pulumi.Input[_builtins.str] uuid: Guardrail UUID
        """
        if agent_uuid is not None:
            pulumi.set(__self__, "agent_uuid", agent_uuid)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if default_response is not None:
            pulumi.set(__self__, "default_response", default_response)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if is_attached is not None:
            pulumi.set(__self__, "is_attached", is_attached)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="agentUuid")
    def agent_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent UUID for the Guardrail
        """
        return pulumi.get(self, "agent_uuid")

    @agent_uuid.setter
    def agent_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_uuid", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Guardrail
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="defaultResponse")
    def default_response(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default response for the Guardrail
        """
        return pulumi.get(self, "default_response")

    @default_response.setter
    def default_response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_response", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Guardrail
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "guardrail_uuid")

    @guardrail_uuid.setter
    def guardrail_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "guardrail_uuid", value)

    @_builtins.property
    @pulumi.getter(name="isAttached")
    def is_attached(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Guardrail is attached
        """
        return pulumi.get(self, "is_attached")

    @is_attached.setter
    def is_attached(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_attached", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Guardrail is default
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of Guardrail
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Priority of the Guardrail
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the Guardrail
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the Guardrail
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentAnthropicApiKeyArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the API Key was created
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created By user ID for the API Key
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted At timestamp for the API Key
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the API Key
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentAnthropicApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentAnthropicApiKeyArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Timestamp when the API Key was created
        :param pulumi.Input[_builtins.str] created_by: Created By user ID for the API Key
        :param pulumi.Input[_builtins.str] deleted_at: Deleted At timestamp for the API Key
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the API Key
        :param pulumi.Input[_builtins.str] uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentApiKeyArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentApiKeyArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)


if not MYPY:
    class GenaiAgentApiKeyInfoArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created By user ID for the API Key
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted At timestamp for the API Key
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the API Key
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentApiKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentApiKeyInfoArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: API Key value
        :param pulumi.Input[_builtins.str] created_by: Created By user ID for the API Key
        :param pulumi.Input[_builtins.str] deleted_at: Deleted At timestamp for the API Key
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] secret_key: Updated At timestamp for the API Key
        :param pulumi.Input[_builtins.str] uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentChatbotArgsDict(TypedDict):
        button_background_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Background color for the chatbot button
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        Logo for the chatbot
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the chatbot
        """
        primary_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary color for the chatbot
        """
        secondary_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary color for the chatbot
        """
        starting_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Starting message for the chatbot
        """
elif False:
    GenaiAgentChatbotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChatbotArgs:
    def __init__(__self__, *,
                 button_background_color: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_color: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary_color: Optional[pulumi.Input[_builtins.str]] = None,
                 starting_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] button_background_color: Background color for the chatbot button
        :param pulumi.Input[_builtins.str] logo: Logo for the chatbot
        :param pulumi.Input[_builtins.str] name: Name of the chatbot
        :param pulumi.Input[_builtins.str] primary_color: Primary color for the chatbot
        :param pulumi.Input[_builtins.str] secondary_color: Secondary color for the chatbot
        :param pulumi.Input[_builtins.str] starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @button_background_color.setter
    def button_background_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "button_background_color", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @primary_color.setter
    def primary_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_color", value)

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @secondary_color.setter
    def secondary_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_color", value)

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")

    @starting_message.setter
    def starting_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "starting_message", value)


if not MYPY:
    class GenaiAgentChatbotIdentifierArgsDict(TypedDict):
        chatbot_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GenaiAgentChatbotIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChatbotIdentifierArgs:
    def __init__(__self__, *,
                 chatbot_id: Optional[pulumi.Input[_builtins.str]] = None):
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "chatbot_id")

    @chatbot_id.setter
    def chatbot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "chatbot_id", value)


if not MYPY:
    class GenaiAgentChildAgentArgsDict(TypedDict):
        instruction: pulumi.Input[_builtins.str]
        """
        Instruction for the Agent
        """
        model_uuid: pulumi.Input[_builtins.str]
        """
        Model UUID of the Agent
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the Agent
        """
        project_id: pulumi.Input[_builtins.str]
        """
        Project ID of the Agent
        """
        region: pulumi.Input[_builtins.str]
        """
        Region where the Agent is deployed
        """
        agent_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the child agent
        """
        anthropic_api_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentAnthropicApiKeyArgsDict']]]]
        """
        Anthropic API Key information
        """
        api_key_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyInfoArgsDict']]]]
        """
        List of API Key Infos
        """
        api_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyArgsDict']]]]
        """
        List of API Keys
        """
        chatbot_identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotIdentifierArgsDict']]]]
        """
        List of Chatbot Identifiers
        """
        chatbots: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotArgsDict']]]]
        """
        ChatBot configuration
        """
        deployments: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentDeploymentArgsDict']]]]
        """
        List of API Key Infos
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description for the Agent
        """
elif False:
    GenaiAgentChildAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChildAgentArgs:
    def __init__(__self__, *,
                 instruction: pulumi.Input[_builtins.str],
                 model_uuid: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 agent_id: Optional[pulumi.Input[_builtins.str]] = None,
                 anthropic_api_keys: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentAnthropicApiKeyArgs']]]] = None,
                 api_key_infos: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyInfoArgs']]]] = None,
                 api_keys: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyArgs']]]] = None,
                 chatbot_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotIdentifierArgs']]]] = None,
                 chatbots: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotArgs']]]] = None,
                 deployments: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentDeploymentArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instruction: Instruction for the Agent
        :param pulumi.Input[_builtins.str] model_uuid: Model UUID of the Agent
        :param pulumi.Input[_builtins.str] name: Name of the Agent
        :param pulumi.Input[_builtins.str] project_id: Project ID of the Agent
        :param pulumi.Input[_builtins.str] region: Region where the Agent is deployed
        :param pulumi.Input[_builtins.str] agent_id: ID of the child agent
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentAnthropicApiKeyArgs']]] anthropic_api_keys: Anthropic API Key information
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyInfoArgs']]] api_key_infos: List of API Key Infos
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyArgs']]] api_keys: List of API Keys
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotIdentifierArgs']]] chatbot_identifiers: List of Chatbot Identifiers
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotArgs']]] chatbots: ChatBot configuration
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentDeploymentArgs']]] deployments: List of API Key Infos
        :param pulumi.Input[_builtins.str] description: Description for the Agent
        """
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> pulumi.Input[_builtins.str]:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @instruction.setter
    def instruction(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instruction", value)

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @model_uuid.setter
    def model_uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_uuid", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @agent_id.setter
    def agent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_id", value)

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentAnthropicApiKeyArgs']]]]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @anthropic_api_keys.setter
    def anthropic_api_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentAnthropicApiKeyArgs']]]]):
        pulumi.set(self, "anthropic_api_keys", value)

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyInfoArgs']]]]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @api_key_infos.setter
    def api_key_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyInfoArgs']]]]):
        pulumi.set(self, "api_key_infos", value)

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyArgs']]]]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @api_keys.setter
    def api_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentApiKeyArgs']]]]):
        pulumi.set(self, "api_keys", value)

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotIdentifierArgs']]]]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @chatbot_identifiers.setter
    def chatbot_identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotIdentifierArgs']]]]):
        pulumi.set(self, "chatbot_identifiers", value)

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotArgs']]]]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @chatbots.setter
    def chatbots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentChatbotArgs']]]]):
        pulumi.set(self, "chatbots", value)

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentDeploymentArgs']]]]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @deployments.setter
    def deployments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentChildAgentDeploymentArgs']]]]):
        pulumi.set(self, "deployments", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GenaiAgentChildAgentAnthropicApiKeyArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the API Key was created
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created By user ID for the API Key
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted At timestamp for the API Key
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the API Key
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentChildAgentAnthropicApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChildAgentAnthropicApiKeyArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Timestamp when the API Key was created
        :param pulumi.Input[_builtins.str] created_by: Created By user ID for the API Key
        :param pulumi.Input[_builtins.str] deleted_at: Deleted At timestamp for the API Key
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the API Key
        :param pulumi.Input[_builtins.str] uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentChildAgentApiKeyArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentChildAgentApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChildAgentApiKeyArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)


if not MYPY:
    class GenaiAgentChildAgentApiKeyInfoArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created By user ID for the API Key
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted At timestamp for the API Key
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the API Key
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentChildAgentApiKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChildAgentApiKeyInfoArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: API Key value
        :param pulumi.Input[_builtins.str] created_by: Created By user ID for the API Key
        :param pulumi.Input[_builtins.str] deleted_at: Deleted At timestamp for the API Key
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] secret_key: Updated At timestamp for the API Key
        :param pulumi.Input[_builtins.str] uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentChildAgentChatbotArgsDict(TypedDict):
        button_background_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Background color for the chatbot button
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        Logo for the chatbot
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the chatbot
        """
        primary_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary color for the chatbot
        """
        secondary_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary color for the chatbot
        """
        starting_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Starting message for the chatbot
        """
elif False:
    GenaiAgentChildAgentChatbotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChildAgentChatbotArgs:
    def __init__(__self__, *,
                 button_background_color: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_color: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary_color: Optional[pulumi.Input[_builtins.str]] = None,
                 starting_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] button_background_color: Background color for the chatbot button
        :param pulumi.Input[_builtins.str] logo: Logo for the chatbot
        :param pulumi.Input[_builtins.str] name: Name of the chatbot
        :param pulumi.Input[_builtins.str] primary_color: Primary color for the chatbot
        :param pulumi.Input[_builtins.str] secondary_color: Secondary color for the chatbot
        :param pulumi.Input[_builtins.str] starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @button_background_color.setter
    def button_background_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "button_background_color", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @primary_color.setter
    def primary_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_color", value)

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @secondary_color.setter
    def secondary_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_color", value)

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")

    @starting_message.setter
    def starting_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "starting_message", value)


if not MYPY:
    class GenaiAgentChildAgentChatbotIdentifierArgsDict(TypedDict):
        chatbot_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GenaiAgentChildAgentChatbotIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChildAgentChatbotIdentifierArgs:
    def __init__(__self__, *,
                 chatbot_id: Optional[pulumi.Input[_builtins.str]] = None):
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "chatbot_id")

    @chatbot_id.setter
    def chatbot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "chatbot_id", value)


if not MYPY:
    class GenaiAgentChildAgentDeploymentArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the Deployment
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the Agent
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Url of the Deployment
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        visibility: NotRequired[pulumi.Input[_builtins.str]]
        """
        Visibility of the Deployment
        """
elif False:
    GenaiAgentChildAgentDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentChildAgentDeploymentArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 visibility: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: API Key value
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] status: Status of the Deployment
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the Agent
        :param pulumi.Input[_builtins.str] url: Url of the Deployment
        :param pulumi.Input[_builtins.str] uuid: API Key value
        :param pulumi.Input[_builtins.str] visibility: Visibility of the Deployment
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")

    @visibility.setter
    def visibility(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "visibility", value)


if not MYPY:
    class GenaiAgentDeploymentArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the Deployment
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the Agent
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Url of the Deployment
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        visibility: NotRequired[pulumi.Input[_builtins.str]]
        """
        Visibility of the Deployment
        """
elif False:
    GenaiAgentDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentDeploymentArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 visibility: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: API Key value
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] status: Status of the Deployment
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the Agent
        :param pulumi.Input[_builtins.str] url: Url of the Deployment
        :param pulumi.Input[_builtins.str] uuid: API Key value
        :param pulumi.Input[_builtins.str] visibility: Visibility of the Deployment
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")

    @visibility.setter
    def visibility(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "visibility", value)


if not MYPY:
    class GenaiAgentFunctionArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Function
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Function
        """
        faasname: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of function
        """
        faasnamespace: NotRequired[pulumi.Input[_builtins.str]]
        """
        Namespace of function
        """
        guardrail_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Guardrail UUID for the Function
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of function
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the Agent
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Url of the Deployment
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentFunctionArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 faasname: Optional[pulumi.Input[_builtins.str]] = None,
                 faasnamespace: Optional[pulumi.Input[_builtins.str]] = None,
                 guardrail_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: API Key value
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Function
        :param pulumi.Input[_builtins.str] description: Description of the Function
        :param pulumi.Input[_builtins.str] faasname: Name of function
        :param pulumi.Input[_builtins.str] faasnamespace: Namespace of function
        :param pulumi.Input[_builtins.str] guardrail_uuid: Guardrail UUID for the Function
        :param pulumi.Input[_builtins.str] name: Name of function
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the Agent
        :param pulumi.Input[_builtins.str] url: Url of the Deployment
        :param pulumi.Input[_builtins.str] uuid: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if faasname is not None:
            pulumi.set(__self__, "faasname", faasname)
        if faasnamespace is not None:
            pulumi.set(__self__, "faasnamespace", faasnamespace)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Function
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Function
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def faasname(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of function
        """
        return pulumi.get(self, "faasname")

    @faasname.setter
    def faasname(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "faasname", value)

    @_builtins.property
    @pulumi.getter
    def faasnamespace(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Namespace of function
        """
        return pulumi.get(self, "faasnamespace")

    @faasnamespace.setter
    def faasnamespace(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "faasnamespace", value)

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Guardrail UUID for the Function
        """
        return pulumi.get(self, "guardrail_uuid")

    @guardrail_uuid.setter
    def guardrail_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "guardrail_uuid", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of function
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentKnowledgeBaseArgsDict(TypedDict):
        added_to_agent_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Knowledge Base
        """
        database_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Database ID of the Knowledge Base
        """
        embedding_model_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Embedding model UUID for the Knowledge Base
        """
        is_public: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Knowledge Base is public
        """
        last_indexing_jobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentKnowledgeBaseLastIndexingJobArgsDict']]]]
        """
        Last indexing job for the Knowledge Base
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Knowledge Base
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project ID of the Knowledge Base
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region of the Knowledge Base
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tags
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the Knowledge Base was updated
        """
        user_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        User ID of the Knowledge Base
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Knowledge Base
        """
elif False:
    GenaiAgentKnowledgeBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentKnowledgeBaseArgs:
    def __init__(__self__, *,
                 added_to_agent_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 database_id: Optional[pulumi.Input[_builtins.str]] = None,
                 embedding_model_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 is_public: Optional[pulumi.Input[_builtins.bool]] = None,
                 last_indexing_jobs: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentKnowledgeBaseLastIndexingJobArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Knowledge Base
        :param pulumi.Input[_builtins.str] database_id: Database ID of the Knowledge Base
        :param pulumi.Input[_builtins.str] embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param pulumi.Input[_builtins.bool] is_public: Indicates if the Knowledge Base is public
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentKnowledgeBaseLastIndexingJobArgs']]] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param pulumi.Input[_builtins.str] name: Name of the Knowledge Base
        :param pulumi.Input[_builtins.str] project_id: Project ID of the Knowledge Base
        :param pulumi.Input[_builtins.str] region: Region of the Knowledge Base
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: List of tags
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the Knowledge Base was updated
        :param pulumi.Input[_builtins.str] user_id: User ID of the Knowledge Base
        :param pulumi.Input[_builtins.str] uuid: UUID of the Knowledge Base
        """
        if added_to_agent_at is not None:
            pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @added_to_agent_at.setter
    def added_to_agent_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "added_to_agent_at", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_id", value)

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @embedding_model_uuid.setter
    def embedding_model_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "embedding_model_uuid", value)

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_public", value)

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentKnowledgeBaseLastIndexingJobArgs']]]]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @last_indexing_jobs.setter
    def last_indexing_jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentKnowledgeBaseLastIndexingJobArgs']]]]):
        pulumi.set(self, "last_indexing_jobs", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentKnowledgeBaseLastIndexingJobArgsDict(TypedDict):
        completed_datasources: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of completed datasources in the last indexing job
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the last indexing job
        """
        data_source_uuids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Datasource UUIDs for the last indexing job
        """
        finished_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job finished
        """
        knowledge_base_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        phase: NotRequired[pulumi.Input[_builtins.str]]
        """
        Phase of the last indexing job
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job started
        """
        tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of tokens processed in the last indexing job
        """
        total_datasources: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of datasources in the last indexing job
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job updated
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID  of the last indexing job
        """
elif False:
    GenaiAgentKnowledgeBaseLastIndexingJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentKnowledgeBaseLastIndexingJobArgs:
    def __init__(__self__, *,
                 completed_datasources: Optional[pulumi.Input[_builtins.int]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_uuids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 finished_at: Optional[pulumi.Input[_builtins.str]] = None,
                 knowledge_base_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 phase: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None,
                 tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 total_datasources: Optional[pulumi.Input[_builtins.int]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] completed_datasources: Number of completed datasources in the last indexing job
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the last indexing job
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_source_uuids: Datasource UUIDs for the last indexing job
        :param pulumi.Input[_builtins.str] finished_at: Timestamp when the last indexing job finished
        :param pulumi.Input[_builtins.str] knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param pulumi.Input[_builtins.str] phase: Phase of the last indexing job
        :param pulumi.Input[_builtins.str] started_at: Timestamp when the last indexing job started
        :param pulumi.Input[_builtins.int] tokens: Number of tokens processed in the last indexing job
        :param pulumi.Input[_builtins.int] total_datasources: Total number of datasources in the last indexing job
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the last indexing job updated
        :param pulumi.Input[_builtins.str] uuid: UUID  of the last indexing job
        """
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if knowledge_base_uuid is not None:
            pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @completed_datasources.setter
    def completed_datasources(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "completed_datasources", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @data_source_uuids.setter
    def data_source_uuids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data_source_uuids", value)

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @finished_at.setter
    def finished_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finished_at", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @knowledge_base_uuid.setter
    def knowledge_base_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "knowledge_base_uuid", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @total_datasources.setter
    def total_datasources(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_datasources", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentModelArgsDict(TypedDict):
        agreements: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelAgreementArgsDict']]]]
        """
        Agreement information for the model
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Knowledge Base
        """
        inference_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inference name of the model
        """
        inference_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Infernce version of the model
        """
        is_foundational: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Model Base is foundational
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Knowledge Base
        """
        parent_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parent UUID of the Model
        """
        provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provider of the Model
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the Knowledge Base was updated
        """
        upload_complete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Model upload is complete
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the Model
        """
        usecases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of Usecases for the Model
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelVersionArgsDict']]]]
        """
        URL of the Model
        """
elif False:
    GenaiAgentModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentModelArgs:
    def __init__(__self__, *,
                 agreements: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelAgreementArgs']]]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_name: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_version: Optional[pulumi.Input[_builtins.str]] = None,
                 is_foundational: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 provider: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 upload_complete: Optional[pulumi.Input[_builtins.bool]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 usecases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelVersionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelAgreementArgs']]] agreements: Agreement information for the model
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Knowledge Base
        :param pulumi.Input[_builtins.str] inference_name: Inference name of the model
        :param pulumi.Input[_builtins.str] inference_version: Infernce version of the model
        :param pulumi.Input[_builtins.bool] is_foundational: Indicates if the Model Base is foundational
        :param pulumi.Input[_builtins.str] name: Name of the Knowledge Base
        :param pulumi.Input[_builtins.str] parent_uuid: Parent UUID of the Model
        :param pulumi.Input[_builtins.str] provider: Provider of the Model
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the Knowledge Base was updated
        :param pulumi.Input[_builtins.bool] upload_complete: Indicates if the Model upload is complete
        :param pulumi.Input[_builtins.str] url: URL of the Model
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usecases: List of Usecases for the Model
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelVersionArgs']]] versions: URL of the Model
        """
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelAgreementArgs']]]]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @agreements.setter
    def agreements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelAgreementArgs']]]]):
        pulumi.set(self, "agreements", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @inference_name.setter
    def inference_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inference_name", value)

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @inference_version.setter
    def inference_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inference_version", value)

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @is_foundational.setter
    def is_foundational(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_foundational", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @parent_uuid.setter
    def parent_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_uuid", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @upload_complete.setter
    def upload_complete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "upload_complete", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @usecases.setter
    def usecases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "usecases", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelVersionArgs']]]]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentModelVersionArgs']]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class GenaiAgentModelAgreementArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the agreement
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the agreement
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the agreement
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the agreement
        """
elif False:
    GenaiAgentModelAgreementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentModelAgreementArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the agreement
        :param pulumi.Input[_builtins.str] name: Name of the agreement
        :param pulumi.Input[_builtins.str] url: URL of the agreement
        :param pulumi.Input[_builtins.str] uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentModelVersionArgsDict(TypedDict):
        major: NotRequired[pulumi.Input[_builtins.int]]
        """
        Major version of the model
        """
        minor: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minor version of the model
        """
        patch: NotRequired[pulumi.Input[_builtins.int]]
        """
        Patch version of the model
        """
elif False:
    GenaiAgentModelVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentModelVersionArgs:
    def __init__(__self__, *,
                 major: Optional[pulumi.Input[_builtins.int]] = None,
                 minor: Optional[pulumi.Input[_builtins.int]] = None,
                 patch: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] major: Major version of the model
        :param pulumi.Input[_builtins.int] minor: Minor version of the model
        :param pulumi.Input[_builtins.int] patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @major.setter
    def major(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "major", value)

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @minor.setter
    def minor(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minor", value)

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")

    @patch.setter
    def patch(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "patch", value)


if not MYPY:
    class GenaiAgentOpenAiApiKeyArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the API Key was created
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created By user ID for the API Key
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted At timestamp for the API Key
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the API Key
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentOpenAiApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentOpenAiApiKeyArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Timestamp when the API Key was created
        :param pulumi.Input[_builtins.str] created_by: Created By user ID for the API Key
        :param pulumi.Input[_builtins.str] deleted_at: Deleted At timestamp for the API Key
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the API Key
        :param pulumi.Input[_builtins.str] uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentParentAgentArgsDict(TypedDict):
        instruction: pulumi.Input[_builtins.str]
        """
        Instruction for the Agent
        """
        model_uuid: pulumi.Input[_builtins.str]
        """
        Model UUID of the Agent
        """
        name: pulumi.Input[_builtins.str]
        """
        Name of the Agent
        """
        project_id: pulumi.Input[_builtins.str]
        """
        Project ID of the Agent
        """
        region: pulumi.Input[_builtins.str]
        """
        Region where the Agent is deployed
        """
        agent_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of the child agent
        """
        anthropic_api_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentAnthropicApiKeyArgsDict']]]]
        """
        Anthropic API Key information
        """
        api_key_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyInfoArgsDict']]]]
        """
        List of API Key Infos
        """
        api_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyArgsDict']]]]
        """
        List of API Keys
        """
        chatbot_identifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotIdentifierArgsDict']]]]
        """
        List of Chatbot Identifiers
        """
        chatbots: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotArgsDict']]]]
        """
        ChatBot configuration
        """
        deployments: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentDeploymentArgsDict']]]]
        """
        List of API Key Infos
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description for the Agent
        """
elif False:
    GenaiAgentParentAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentParentAgentArgs:
    def __init__(__self__, *,
                 instruction: pulumi.Input[_builtins.str],
                 model_uuid: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 project_id: pulumi.Input[_builtins.str],
                 region: pulumi.Input[_builtins.str],
                 agent_id: Optional[pulumi.Input[_builtins.str]] = None,
                 anthropic_api_keys: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentAnthropicApiKeyArgs']]]] = None,
                 api_key_infos: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyInfoArgs']]]] = None,
                 api_keys: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyArgs']]]] = None,
                 chatbot_identifiers: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotIdentifierArgs']]]] = None,
                 chatbots: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotArgs']]]] = None,
                 deployments: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentDeploymentArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] instruction: Instruction for the Agent
        :param pulumi.Input[_builtins.str] model_uuid: Model UUID of the Agent
        :param pulumi.Input[_builtins.str] name: Name of the Agent
        :param pulumi.Input[_builtins.str] project_id: Project ID of the Agent
        :param pulumi.Input[_builtins.str] region: Region where the Agent is deployed
        :param pulumi.Input[_builtins.str] agent_id: ID of the child agent
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentAnthropicApiKeyArgs']]] anthropic_api_keys: Anthropic API Key information
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyInfoArgs']]] api_key_infos: List of API Key Infos
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyArgs']]] api_keys: List of API Keys
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotIdentifierArgs']]] chatbot_identifiers: List of Chatbot Identifiers
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotArgs']]] chatbots: ChatBot configuration
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentDeploymentArgs']]] deployments: List of API Key Infos
        :param pulumi.Input[_builtins.str] description: Description for the Agent
        """
        pulumi.set(__self__, "instruction", instruction)
        pulumi.set(__self__, "model_uuid", model_uuid)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "region", region)
        if agent_id is not None:
            pulumi.set(__self__, "agent_id", agent_id)
        if anthropic_api_keys is not None:
            pulumi.set(__self__, "anthropic_api_keys", anthropic_api_keys)
        if api_key_infos is not None:
            pulumi.set(__self__, "api_key_infos", api_key_infos)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if chatbot_identifiers is not None:
            pulumi.set(__self__, "chatbot_identifiers", chatbot_identifiers)
        if chatbots is not None:
            pulumi.set(__self__, "chatbots", chatbots)
        if deployments is not None:
            pulumi.set(__self__, "deployments", deployments)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> pulumi.Input[_builtins.str]:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @instruction.setter
    def instruction(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "instruction", value)

    @_builtins.property
    @pulumi.getter(name="modelUuid")
    def model_uuid(self) -> pulumi.Input[_builtins.str]:
        """
        Model UUID of the Agent
        """
        return pulumi.get(self, "model_uuid")

    @model_uuid.setter
    def model_uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "model_uuid", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the Agent
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[_builtins.str]:
        """
        Project ID of the Agent
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Region where the Agent is deployed
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="agentId")
    def agent_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of the child agent
        """
        return pulumi.get(self, "agent_id")

    @agent_id.setter
    def agent_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_id", value)

    @_builtins.property
    @pulumi.getter(name="anthropicApiKeys")
    def anthropic_api_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentAnthropicApiKeyArgs']]]]:
        """
        Anthropic API Key information
        """
        return pulumi.get(self, "anthropic_api_keys")

    @anthropic_api_keys.setter
    def anthropic_api_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentAnthropicApiKeyArgs']]]]):
        pulumi.set(self, "anthropic_api_keys", value)

    @_builtins.property
    @pulumi.getter(name="apiKeyInfos")
    def api_key_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyInfoArgs']]]]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "api_key_infos")

    @api_key_infos.setter
    def api_key_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyInfoArgs']]]]):
        pulumi.set(self, "api_key_infos", value)

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyArgs']]]]:
        """
        List of API Keys
        """
        return pulumi.get(self, "api_keys")

    @api_keys.setter
    def api_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentApiKeyArgs']]]]):
        pulumi.set(self, "api_keys", value)

    @_builtins.property
    @pulumi.getter(name="chatbotIdentifiers")
    def chatbot_identifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotIdentifierArgs']]]]:
        """
        List of Chatbot Identifiers
        """
        return pulumi.get(self, "chatbot_identifiers")

    @chatbot_identifiers.setter
    def chatbot_identifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotIdentifierArgs']]]]):
        pulumi.set(self, "chatbot_identifiers", value)

    @_builtins.property
    @pulumi.getter
    def chatbots(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotArgs']]]]:
        """
        ChatBot configuration
        """
        return pulumi.get(self, "chatbots")

    @chatbots.setter
    def chatbots(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentChatbotArgs']]]]):
        pulumi.set(self, "chatbots", value)

    @_builtins.property
    @pulumi.getter
    def deployments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentDeploymentArgs']]]]:
        """
        List of API Key Infos
        """
        return pulumi.get(self, "deployments")

    @deployments.setter
    def deployments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentParentAgentDeploymentArgs']]]]):
        pulumi.set(self, "deployments", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description for the Agent
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class GenaiAgentParentAgentAnthropicApiKeyArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the API Key was created
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created By user ID for the API Key
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted At timestamp for the API Key
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the API Key
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentParentAgentAnthropicApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentParentAgentAnthropicApiKeyArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Timestamp when the API Key was created
        :param pulumi.Input[_builtins.str] created_by: Created By user ID for the API Key
        :param pulumi.Input[_builtins.str] deleted_at: Deleted At timestamp for the API Key
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the API Key
        :param pulumi.Input[_builtins.str] uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentParentAgentApiKeyArgsDict(TypedDict):
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentParentAgentApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentParentAgentApiKeyArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)


if not MYPY:
    class GenaiAgentParentAgentApiKeyInfoArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        created_by: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created By user ID for the API Key
        """
        deleted_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Deleted At timestamp for the API Key
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        secret_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the API Key
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
elif False:
    GenaiAgentParentAgentApiKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentParentAgentApiKeyInfoArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_by: Optional[pulumi.Input[_builtins.str]] = None,
                 deleted_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_key: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: API Key value
        :param pulumi.Input[_builtins.str] created_by: Created By user ID for the API Key
        :param pulumi.Input[_builtins.str] deleted_at: Deleted At timestamp for the API Key
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] secret_key: Updated At timestamp for the API Key
        :param pulumi.Input[_builtins.str] uuid: API Key value
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if deleted_at is not None:
            pulumi.set(__self__, "deleted_at", deleted_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentParentAgentChatbotArgsDict(TypedDict):
        button_background_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Background color for the chatbot button
        """
        logo: NotRequired[pulumi.Input[_builtins.str]]
        """
        Logo for the chatbot
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the chatbot
        """
        primary_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Primary color for the chatbot
        """
        secondary_color: NotRequired[pulumi.Input[_builtins.str]]
        """
        Secondary color for the chatbot
        """
        starting_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Starting message for the chatbot
        """
elif False:
    GenaiAgentParentAgentChatbotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentParentAgentChatbotArgs:
    def __init__(__self__, *,
                 button_background_color: Optional[pulumi.Input[_builtins.str]] = None,
                 logo: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 primary_color: Optional[pulumi.Input[_builtins.str]] = None,
                 secondary_color: Optional[pulumi.Input[_builtins.str]] = None,
                 starting_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] button_background_color: Background color for the chatbot button
        :param pulumi.Input[_builtins.str] logo: Logo for the chatbot
        :param pulumi.Input[_builtins.str] name: Name of the chatbot
        :param pulumi.Input[_builtins.str] primary_color: Primary color for the chatbot
        :param pulumi.Input[_builtins.str] secondary_color: Secondary color for the chatbot
        :param pulumi.Input[_builtins.str] starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @button_background_color.setter
    def button_background_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "button_background_color", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @primary_color.setter
    def primary_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "primary_color", value)

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @secondary_color.setter
    def secondary_color(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secondary_color", value)

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")

    @starting_message.setter
    def starting_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "starting_message", value)


if not MYPY:
    class GenaiAgentParentAgentChatbotIdentifierArgsDict(TypedDict):
        chatbot_id: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    GenaiAgentParentAgentChatbotIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentParentAgentChatbotIdentifierArgs:
    def __init__(__self__, *,
                 chatbot_id: Optional[pulumi.Input[_builtins.str]] = None):
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "chatbot_id")

    @chatbot_id.setter
    def chatbot_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "chatbot_id", value)


if not MYPY:
    class GenaiAgentParentAgentDeploymentArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the API Key
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the Deployment
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the Agent
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        Url of the Deployment
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key value
        """
        visibility: NotRequired[pulumi.Input[_builtins.str]]
        """
        Visibility of the Deployment
        """
elif False:
    GenaiAgentParentAgentDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentParentAgentDeploymentArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 visibility: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: API Key value
        :param pulumi.Input[_builtins.str] name: Name of the API Key
        :param pulumi.Input[_builtins.str] status: Status of the Deployment
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the Agent
        :param pulumi.Input[_builtins.str] url: Url of the Deployment
        :param pulumi.Input[_builtins.str] uuid: API Key value
        :param pulumi.Input[_builtins.str] visibility: Visibility of the Deployment
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")

    @visibility.setter
    def visibility(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "visibility", value)


if not MYPY:
    class GenaiAgentTemplateArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Knowledge Base
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the Agent Template
        """
        instruction: NotRequired[pulumi.Input[_builtins.str]]
        """
        Instruction for the Agent
        """
        k: NotRequired[pulumi.Input[_builtins.int]]
        """
        K value for the Agent Template
        """
        knowledge_bases: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseArgsDict']]]]
        """
        List of Knowledge Bases
        """
        max_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum tokens allowed
        """
        models: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelArgsDict']]]]
        """
        Model of the Agent Template
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Agent Template
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Agent temperature setting
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Top P sampling parameter
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updated At timestamp for the Agent Template
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        uuid of the Agent Template
        """
elif False:
    GenaiAgentTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentTemplateArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 instruction: Optional[pulumi.Input[_builtins.str]] = None,
                 k: Optional[pulumi.Input[_builtins.int]] = None,
                 knowledge_bases: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseArgs']]]] = None,
                 max_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 models: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Knowledge Base
        :param pulumi.Input[_builtins.str] description: Description of the Agent Template
        :param pulumi.Input[_builtins.str] instruction: Instruction for the Agent
        :param pulumi.Input[_builtins.int] k: K value for the Agent Template
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseArgs']]] knowledge_bases: List of Knowledge Bases
        :param pulumi.Input[_builtins.int] max_tokens: Maximum tokens allowed
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelArgs']]] models: Model of the Agent Template
        :param pulumi.Input[_builtins.str] name: Name of the Agent Template
        :param pulumi.Input[_builtins.float] temperature: Agent temperature setting
        :param pulumi.Input[_builtins.float] top_p: Top P sampling parameter
        :param pulumi.Input[_builtins.str] updated_at: Updated At timestamp for the Agent Template
        :param pulumi.Input[_builtins.str] uuid: uuid of the Agent Template
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)
        if k is not None:
            pulumi.set(__self__, "k", k)
        if knowledge_bases is not None:
            pulumi.set(__self__, "knowledge_bases", knowledge_bases)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the Agent Template
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @instruction.setter
    def instruction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instruction", value)

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        K value for the Agent Template
        """
        return pulumi.get(self, "k")

    @k.setter
    def k(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "k", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseArgs']]]]:
        """
        List of Knowledge Bases
        """
        return pulumi.get(self, "knowledge_bases")

    @knowledge_bases.setter
    def knowledge_bases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseArgs']]]]):
        pulumi.set(self, "knowledge_bases", value)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum tokens allowed
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelArgs']]]]:
        """
        Model of the Agent Template
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelArgs']]]]):
        pulumi.set(self, "models", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Agent Template
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Agent temperature setting
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Top P sampling parameter
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updated At timestamp for the Agent Template
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        uuid of the Agent Template
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentTemplateKnowledgeBaseArgsDict(TypedDict):
        added_to_agent_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Knowledge Base
        """
        database_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Database ID of the Knowledge Base
        """
        embedding_model_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Embedding model UUID for the Knowledge Base
        """
        is_public: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Knowledge Base is public
        """
        last_indexing_jobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgsDict']]]]
        """
        Last indexing job for the Knowledge Base
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Knowledge Base
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project ID of the Knowledge Base
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Region of the Knowledge Base
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of tags
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the Knowledge Base was updated
        """
        user_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        User ID of the Knowledge Base
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Knowledge Base
        """
elif False:
    GenaiAgentTemplateKnowledgeBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentTemplateKnowledgeBaseArgs:
    def __init__(__self__, *,
                 added_to_agent_at: Optional[pulumi.Input[_builtins.str]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 database_id: Optional[pulumi.Input[_builtins.str]] = None,
                 embedding_model_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 is_public: Optional[pulumi.Input[_builtins.bool]] = None,
                 last_indexing_jobs: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 user_id: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Knowledge Base
        :param pulumi.Input[_builtins.str] database_id: Database ID of the Knowledge Base
        :param pulumi.Input[_builtins.str] embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param pulumi.Input[_builtins.bool] is_public: Indicates if the Knowledge Base is public
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs']]] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param pulumi.Input[_builtins.str] name: Name of the Knowledge Base
        :param pulumi.Input[_builtins.str] project_id: Project ID of the Knowledge Base
        :param pulumi.Input[_builtins.str] region: Region of the Knowledge Base
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: List of tags
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the Knowledge Base was updated
        :param pulumi.Input[_builtins.str] user_id: User ID of the Knowledge Base
        :param pulumi.Input[_builtins.str] uuid: UUID of the Knowledge Base
        """
        if added_to_agent_at is not None:
            pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @added_to_agent_at.setter
    def added_to_agent_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "added_to_agent_at", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "database_id", value)

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @embedding_model_uuid.setter
    def embedding_model_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "embedding_model_uuid", value)

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_public", value)

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs']]]]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @last_indexing_jobs.setter
    def last_indexing_jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs']]]]):
        pulumi.set(self, "last_indexing_jobs", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_id", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgsDict(TypedDict):
        completed_datasources: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of completed datasources in the last indexing job
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the last indexing job
        """
        data_source_uuids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Datasource UUIDs for the last indexing job
        """
        finished_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job finished
        """
        knowledge_base_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        phase: NotRequired[pulumi.Input[_builtins.str]]
        """
        Phase of the last indexing job
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job started
        """
        tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of tokens processed in the last indexing job
        """
        total_datasources: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of datasources in the last indexing job
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job updated
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID  of the last indexing job
        """
elif False:
    GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs:
    def __init__(__self__, *,
                 completed_datasources: Optional[pulumi.Input[_builtins.int]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_uuids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 finished_at: Optional[pulumi.Input[_builtins.str]] = None,
                 knowledge_base_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 phase: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None,
                 tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 total_datasources: Optional[pulumi.Input[_builtins.int]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] completed_datasources: Number of completed datasources in the last indexing job
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the last indexing job
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_source_uuids: Datasource UUIDs for the last indexing job
        :param pulumi.Input[_builtins.str] finished_at: Timestamp when the last indexing job finished
        :param pulumi.Input[_builtins.str] knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param pulumi.Input[_builtins.str] phase: Phase of the last indexing job
        :param pulumi.Input[_builtins.str] started_at: Timestamp when the last indexing job started
        :param pulumi.Input[_builtins.int] tokens: Number of tokens processed in the last indexing job
        :param pulumi.Input[_builtins.int] total_datasources: Total number of datasources in the last indexing job
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the last indexing job updated
        :param pulumi.Input[_builtins.str] uuid: UUID  of the last indexing job
        """
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if knowledge_base_uuid is not None:
            pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @completed_datasources.setter
    def completed_datasources(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "completed_datasources", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @data_source_uuids.setter
    def data_source_uuids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data_source_uuids", value)

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @finished_at.setter
    def finished_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finished_at", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @knowledge_base_uuid.setter
    def knowledge_base_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "knowledge_base_uuid", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @total_datasources.setter
    def total_datasources(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_datasources", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentTemplateModelArgsDict(TypedDict):
        agreements: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelAgreementArgsDict']]]]
        """
        Agreement information for the model
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Knowledge Base
        """
        inference_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inference name of the model
        """
        inference_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Infernce version of the model
        """
        is_foundational: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Model Base is foundational
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Knowledge Base
        """
        parent_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parent UUID of the Model
        """
        provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provider of the Model
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the Knowledge Base was updated
        """
        upload_complete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Model upload is complete
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the Model
        """
        usecases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of Usecases for the Model
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelVersionArgsDict']]]]
        """
        URL of the Model
        """
elif False:
    GenaiAgentTemplateModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentTemplateModelArgs:
    def __init__(__self__, *,
                 agreements: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelAgreementArgs']]]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_name: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_version: Optional[pulumi.Input[_builtins.str]] = None,
                 is_foundational: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 provider: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 upload_complete: Optional[pulumi.Input[_builtins.bool]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 usecases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelVersionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelAgreementArgs']]] agreements: Agreement information for the model
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Knowledge Base
        :param pulumi.Input[_builtins.str] inference_name: Inference name of the model
        :param pulumi.Input[_builtins.str] inference_version: Infernce version of the model
        :param pulumi.Input[_builtins.bool] is_foundational: Indicates if the Model Base is foundational
        :param pulumi.Input[_builtins.str] name: Name of the Knowledge Base
        :param pulumi.Input[_builtins.str] parent_uuid: Parent UUID of the Model
        :param pulumi.Input[_builtins.str] provider: Provider of the Model
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the Knowledge Base was updated
        :param pulumi.Input[_builtins.bool] upload_complete: Indicates if the Model upload is complete
        :param pulumi.Input[_builtins.str] url: URL of the Model
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usecases: List of Usecases for the Model
        :param pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelVersionArgs']]] versions: URL of the Model
        """
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelAgreementArgs']]]]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @agreements.setter
    def agreements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelAgreementArgs']]]]):
        pulumi.set(self, "agreements", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @inference_name.setter
    def inference_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inference_name", value)

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @inference_version.setter
    def inference_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inference_version", value)

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @is_foundational.setter
    def is_foundational(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_foundational", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @parent_uuid.setter
    def parent_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_uuid", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @upload_complete.setter
    def upload_complete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "upload_complete", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @usecases.setter
    def usecases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "usecases", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelVersionArgs']]]]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiAgentTemplateModelVersionArgs']]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class GenaiAgentTemplateModelAgreementArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the agreement
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the agreement
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the agreement
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the agreement
        """
elif False:
    GenaiAgentTemplateModelAgreementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentTemplateModelAgreementArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the agreement
        :param pulumi.Input[_builtins.str] name: Name of the agreement
        :param pulumi.Input[_builtins.str] url: URL of the agreement
        :param pulumi.Input[_builtins.str] uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiAgentTemplateModelVersionArgsDict(TypedDict):
        major: NotRequired[pulumi.Input[_builtins.int]]
        """
        Major version of the model
        """
        minor: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minor version of the model
        """
        patch: NotRequired[pulumi.Input[_builtins.int]]
        """
        Patch version of the model
        """
elif False:
    GenaiAgentTemplateModelVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiAgentTemplateModelVersionArgs:
    def __init__(__self__, *,
                 major: Optional[pulumi.Input[_builtins.int]] = None,
                 minor: Optional[pulumi.Input[_builtins.int]] = None,
                 patch: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] major: Major version of the model
        :param pulumi.Input[_builtins.int] minor: Minor version of the model
        :param pulumi.Input[_builtins.int] patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @major.setter
    def major(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "major", value)

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @minor.setter
    def minor(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minor", value)

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")

    @patch.setter
    def patch(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "patch", value)


if not MYPY:
    class GenaiKnowledgeBaseDataSourceArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Knowledge Base
        """
        file_upload_data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgsDict']]]]
        """
        File upload data source configuration
        """
        last_indexing_jobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceLastIndexingJobArgsDict']]]]
        """
        Last indexing job for the data source
        """
        spaces_data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceSpacesDataSourceArgsDict']]]]
        """
        Spaces data source configuration
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the Knowledge Base was updated
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the Knowledge Base
        """
        web_crawler_data_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgsDict']]]]
        """
        Web crawler data source configuration
        """
elif False:
    GenaiKnowledgeBaseDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiKnowledgeBaseDataSourceArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 file_upload_data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgs']]]] = None,
                 last_indexing_jobs: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceLastIndexingJobArgs']]]] = None,
                 spaces_data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceSpacesDataSourceArgs']]]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 web_crawler_data_sources: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Knowledge Base
        :param pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgs']]] file_upload_data_sources: File upload data source configuration
        :param pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceLastIndexingJobArgs']]] last_indexing_jobs: Last indexing job for the data source
        :param pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceSpacesDataSourceArgs']]] spaces_data_sources: Spaces data source configuration
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the Knowledge Base was updated
        :param pulumi.Input[_builtins.str] uuid: UUID of the Knowledge Base
        :param pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgs']]] web_crawler_data_sources: Web crawler data source configuration
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if file_upload_data_sources is not None:
            pulumi.set(__self__, "file_upload_data_sources", file_upload_data_sources)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if spaces_data_sources is not None:
            pulumi.set(__self__, "spaces_data_sources", spaces_data_sources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if web_crawler_data_sources is not None:
            pulumi.set(__self__, "web_crawler_data_sources", web_crawler_data_sources)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="fileUploadDataSources")
    def file_upload_data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgs']]]]:
        """
        File upload data source configuration
        """
        return pulumi.get(self, "file_upload_data_sources")

    @file_upload_data_sources.setter
    def file_upload_data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgs']]]]):
        pulumi.set(self, "file_upload_data_sources", value)

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceLastIndexingJobArgs']]]]:
        """
        Last indexing job for the data source
        """
        return pulumi.get(self, "last_indexing_jobs")

    @last_indexing_jobs.setter
    def last_indexing_jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceLastIndexingJobArgs']]]]):
        pulumi.set(self, "last_indexing_jobs", value)

    @_builtins.property
    @pulumi.getter(name="spacesDataSources")
    def spaces_data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceSpacesDataSourceArgs']]]]:
        """
        Spaces data source configuration
        """
        return pulumi.get(self, "spaces_data_sources")

    @spaces_data_sources.setter
    def spaces_data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceSpacesDataSourceArgs']]]]):
        pulumi.set(self, "spaces_data_sources", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="webCrawlerDataSources")
    def web_crawler_data_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgs']]]]:
        """
        Web crawler data source configuration
        """
        return pulumi.get(self, "web_crawler_data_sources")

    @web_crawler_data_sources.setter
    def web_crawler_data_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgs']]]]):
        pulumi.set(self, "web_crawler_data_sources", value)


if not MYPY:
    class GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgsDict(TypedDict):
        original_file_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The original name of the uploaded file
        """
        size_in_bytes: NotRequired[pulumi.Input[_builtins.str]]
        """
        The size of the file in bytes
        """
        stored_object_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The stored object key for the file
        """
elif False:
    GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiKnowledgeBaseDataSourceFileUploadDataSourceArgs:
    def __init__(__self__, *,
                 original_file_name: Optional[pulumi.Input[_builtins.str]] = None,
                 size_in_bytes: Optional[pulumi.Input[_builtins.str]] = None,
                 stored_object_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] original_file_name: The original name of the uploaded file
        :param pulumi.Input[_builtins.str] size_in_bytes: The size of the file in bytes
        :param pulumi.Input[_builtins.str] stored_object_key: The stored object key for the file
        """
        if original_file_name is not None:
            pulumi.set(__self__, "original_file_name", original_file_name)
        if size_in_bytes is not None:
            pulumi.set(__self__, "size_in_bytes", size_in_bytes)
        if stored_object_key is not None:
            pulumi.set(__self__, "stored_object_key", stored_object_key)

    @_builtins.property
    @pulumi.getter(name="originalFileName")
    def original_file_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The original name of the uploaded file
        """
        return pulumi.get(self, "original_file_name")

    @original_file_name.setter
    def original_file_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "original_file_name", value)

    @_builtins.property
    @pulumi.getter(name="sizeInBytes")
    def size_in_bytes(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The size of the file in bytes
        """
        return pulumi.get(self, "size_in_bytes")

    @size_in_bytes.setter
    def size_in_bytes(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "size_in_bytes", value)

    @_builtins.property
    @pulumi.getter(name="storedObjectKey")
    def stored_object_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The stored object key for the file
        """
        return pulumi.get(self, "stored_object_key")

    @stored_object_key.setter
    def stored_object_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "stored_object_key", value)


if not MYPY:
    class GenaiKnowledgeBaseDataSourceLastIndexingJobArgsDict(TypedDict):
        completed_datasources: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of completed datasources in the last indexing job
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the last indexing job
        """
        data_source_uuids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Datasource UUIDs for the last indexing job
        """
        finished_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job finished
        """
        knowledge_base_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        phase: NotRequired[pulumi.Input[_builtins.str]]
        """
        Phase of the last indexing job
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job started
        """
        tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of tokens processed in the last indexing job
        """
        total_datasources: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of datasources in the last indexing job
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job updated
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID  of the last indexing job
        """
elif False:
    GenaiKnowledgeBaseDataSourceLastIndexingJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiKnowledgeBaseDataSourceLastIndexingJobArgs:
    def __init__(__self__, *,
                 completed_datasources: Optional[pulumi.Input[_builtins.int]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_uuids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 finished_at: Optional[pulumi.Input[_builtins.str]] = None,
                 knowledge_base_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 phase: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None,
                 tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 total_datasources: Optional[pulumi.Input[_builtins.int]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] completed_datasources: Number of completed datasources in the last indexing job
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the last indexing job
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_source_uuids: Datasource UUIDs for the last indexing job
        :param pulumi.Input[_builtins.str] finished_at: Timestamp when the last indexing job finished
        :param pulumi.Input[_builtins.str] knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param pulumi.Input[_builtins.str] phase: Phase of the last indexing job
        :param pulumi.Input[_builtins.str] started_at: Timestamp when the last indexing job started
        :param pulumi.Input[_builtins.int] tokens: Number of tokens processed in the last indexing job
        :param pulumi.Input[_builtins.int] total_datasources: Total number of datasources in the last indexing job
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the last indexing job updated
        :param pulumi.Input[_builtins.str] uuid: UUID  of the last indexing job
        """
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if knowledge_base_uuid is not None:
            pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @completed_datasources.setter
    def completed_datasources(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "completed_datasources", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @data_source_uuids.setter
    def data_source_uuids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data_source_uuids", value)

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @finished_at.setter
    def finished_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finished_at", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @knowledge_base_uuid.setter
    def knowledge_base_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "knowledge_base_uuid", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @total_datasources.setter
    def total_datasources(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_datasources", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiKnowledgeBaseDataSourceSpacesDataSourceArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Spaces bucket
        """
        item_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path to the item in the bucket
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        The region of the Spaces bucket
        """
elif False:
    GenaiKnowledgeBaseDataSourceSpacesDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiKnowledgeBaseDataSourceSpacesDataSourceArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 item_path: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The name of the Spaces bucket
        :param pulumi.Input[_builtins.str] item_path: The path to the item in the bucket
        :param pulumi.Input[_builtins.str] region: The region of the Spaces bucket
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if item_path is not None:
            pulumi.set(__self__, "item_path", item_path)
        if region is not None:
            pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Spaces bucket
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="itemPath")
    def item_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path to the item in the bucket
        """
        return pulumi.get(self, "item_path")

    @item_path.setter
    def item_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "item_path", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The region of the Spaces bucket
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)


if not MYPY:
    class GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgsDict(TypedDict):
        base_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base URL to crawl
        """
        crawling_option: NotRequired[pulumi.Input[_builtins.str]]
        """
        Options for specifying how URLs found on pages should be handled. 
        - UNKNOWN: Default unknown value
        - SCOPED: Only include the base URL.
        - PATH: Crawl the base URL and linked pages within the URL path.
        - DOMAIN: Crawl the base URL and linked pages within the same domain.
        - SUBDOMAINS: Crawl the base URL and linked pages for any subdomain.
        """
        embed_media: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to embed media content
        """
elif False:
    GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiKnowledgeBaseDataSourceWebCrawlerDataSourceArgs:
    def __init__(__self__, *,
                 base_url: Optional[pulumi.Input[_builtins.str]] = None,
                 crawling_option: Optional[pulumi.Input[_builtins.str]] = None,
                 embed_media: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] base_url: The base URL to crawl
        :param pulumi.Input[_builtins.str] crawling_option: Options for specifying how URLs found on pages should be handled. 
               - UNKNOWN: Default unknown value
               - SCOPED: Only include the base URL.
               - PATH: Crawl the base URL and linked pages within the URL path.
               - DOMAIN: Crawl the base URL and linked pages within the same domain.
               - SUBDOMAINS: Crawl the base URL and linked pages for any subdomain.
        :param pulumi.Input[_builtins.bool] embed_media: Whether to embed media content
        """
        if base_url is not None:
            pulumi.set(__self__, "base_url", base_url)
        if crawling_option is not None:
            pulumi.set(__self__, "crawling_option", crawling_option)
        if embed_media is not None:
            pulumi.set(__self__, "embed_media", embed_media)

    @_builtins.property
    @pulumi.getter(name="baseUrl")
    def base_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base URL to crawl
        """
        return pulumi.get(self, "base_url")

    @base_url.setter
    def base_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "base_url", value)

    @_builtins.property
    @pulumi.getter(name="crawlingOption")
    def crawling_option(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Options for specifying how URLs found on pages should be handled. 
        - UNKNOWN: Default unknown value
        - SCOPED: Only include the base URL.
        - PATH: Crawl the base URL and linked pages within the URL path.
        - DOMAIN: Crawl the base URL and linked pages within the same domain.
        - SUBDOMAINS: Crawl the base URL and linked pages for any subdomain.
        """
        return pulumi.get(self, "crawling_option")

    @crawling_option.setter
    def crawling_option(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "crawling_option", value)

    @_builtins.property
    @pulumi.getter(name="embedMedia")
    def embed_media(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to embed media content
        """
        return pulumi.get(self, "embed_media")

    @embed_media.setter
    def embed_media(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "embed_media", value)


if not MYPY:
    class GenaiKnowledgeBaseLastIndexingJobArgsDict(TypedDict):
        completed_datasources: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of completed datasources in the last indexing job
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the last indexing job
        """
        data_source_uuids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Datasource UUIDs for the last indexing job
        """
        finished_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job finished
        """
        knowledge_base_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        phase: NotRequired[pulumi.Input[_builtins.str]]
        """
        Phase of the last indexing job
        """
        started_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job started
        """
        tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of tokens processed in the last indexing job
        """
        total_datasources: NotRequired[pulumi.Input[_builtins.int]]
        """
        Total number of datasources in the last indexing job
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the last indexing job updated
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID  of the last indexing job
        """
elif False:
    GenaiKnowledgeBaseLastIndexingJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiKnowledgeBaseLastIndexingJobArgs:
    def __init__(__self__, *,
                 completed_datasources: Optional[pulumi.Input[_builtins.int]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source_uuids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 finished_at: Optional[pulumi.Input[_builtins.str]] = None,
                 knowledge_base_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 phase: Optional[pulumi.Input[_builtins.str]] = None,
                 started_at: Optional[pulumi.Input[_builtins.str]] = None,
                 tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 total_datasources: Optional[pulumi.Input[_builtins.int]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] completed_datasources: Number of completed datasources in the last indexing job
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the last indexing job
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_source_uuids: Datasource UUIDs for the last indexing job
        :param pulumi.Input[_builtins.str] finished_at: Timestamp when the last indexing job finished
        :param pulumi.Input[_builtins.str] knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param pulumi.Input[_builtins.str] phase: Phase of the last indexing job
        :param pulumi.Input[_builtins.str] started_at: Timestamp when the last indexing job started
        :param pulumi.Input[_builtins.int] tokens: Number of tokens processed in the last indexing job
        :param pulumi.Input[_builtins.int] total_datasources: Total number of datasources in the last indexing job
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the last indexing job updated
        :param pulumi.Input[_builtins.str] uuid: UUID  of the last indexing job
        """
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if finished_at is not None:
            pulumi.set(__self__, "finished_at", finished_at)
        if knowledge_base_uuid is not None:
            pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if started_at is not None:
            pulumi.set(__self__, "started_at", started_at)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @completed_datasources.setter
    def completed_datasources(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "completed_datasources", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @data_source_uuids.setter
    def data_source_uuids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data_source_uuids", value)

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @finished_at.setter
    def finished_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finished_at", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @knowledge_base_uuid.setter
    def knowledge_base_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "knowledge_base_uuid", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "started_at", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @total_datasources.setter
    def total_datasources(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_datasources", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiOpenaiApiKeyModelArgsDict(TypedDict):
        agreements: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelAgreementArgsDict']]]]
        """
        Agreement information for the model
        """
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Created At timestamp for the Knowledge Base
        """
        inference_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Inference name of the model
        """
        inference_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Infernce version of the model
        """
        is_foundational: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Model Base is foundational
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Knowledge Base
        """
        parent_uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parent UUID of the Model
        """
        provider: NotRequired[pulumi.Input[_builtins.str]]
        """
        Provider of the Model
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timestamp when the Knowledge Base was updated
        """
        upload_complete: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the Model upload is complete
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the Model
        """
        usecases: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of Usecases for the Model
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelVersionArgsDict']]]]
        """
        URL of the Model
        """
elif False:
    GenaiOpenaiApiKeyModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiOpenaiApiKeyModelArgs:
    def __init__(__self__, *,
                 agreements: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelAgreementArgs']]]] = None,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_name: Optional[pulumi.Input[_builtins.str]] = None,
                 inference_version: Optional[pulumi.Input[_builtins.str]] = None,
                 is_foundational: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_uuid: Optional[pulumi.Input[_builtins.str]] = None,
                 provider: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None,
                 upload_complete: Optional[pulumi.Input[_builtins.bool]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 usecases: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelVersionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelAgreementArgs']]] agreements: Agreement information for the model
        :param pulumi.Input[_builtins.str] created_at: Created At timestamp for the Knowledge Base
        :param pulumi.Input[_builtins.str] inference_name: Inference name of the model
        :param pulumi.Input[_builtins.str] inference_version: Infernce version of the model
        :param pulumi.Input[_builtins.bool] is_foundational: Indicates if the Model Base is foundational
        :param pulumi.Input[_builtins.str] name: Name of the Knowledge Base
        :param pulumi.Input[_builtins.str] parent_uuid: Parent UUID of the Model
        :param pulumi.Input[_builtins.str] provider: Provider of the Model
        :param pulumi.Input[_builtins.str] updated_at: Timestamp when the Knowledge Base was updated
        :param pulumi.Input[_builtins.bool] upload_complete: Indicates if the Model upload is complete
        :param pulumi.Input[_builtins.str] url: URL of the Model
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] usecases: List of Usecases for the Model
        :param pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelVersionArgs']]] versions: URL of the Model
        """
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelAgreementArgs']]]]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @agreements.setter
    def agreements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelAgreementArgs']]]]):
        pulumi.set(self, "agreements", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @inference_name.setter
    def inference_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inference_name", value)

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @inference_version.setter
    def inference_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inference_version", value)

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @is_foundational.setter
    def is_foundational(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_foundational", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @parent_uuid.setter
    def parent_uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_uuid", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @upload_complete.setter
    def upload_complete(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "upload_complete", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @usecases.setter
    def usecases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "usecases", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelVersionArgs']]]]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GenaiOpenaiApiKeyModelVersionArgs']]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class GenaiOpenaiApiKeyModelAgreementArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the agreement
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the agreement
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        URL of the agreement
        """
        uuid: NotRequired[pulumi.Input[_builtins.str]]
        """
        UUID of the agreement
        """
elif False:
    GenaiOpenaiApiKeyModelAgreementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiOpenaiApiKeyModelAgreementArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None,
                 uuid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: Description of the agreement
        :param pulumi.Input[_builtins.str] name: Name of the agreement
        :param pulumi.Input[_builtins.str] url: URL of the agreement
        :param pulumi.Input[_builtins.str] uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GenaiOpenaiApiKeyModelVersionArgsDict(TypedDict):
        major: NotRequired[pulumi.Input[_builtins.int]]
        """
        Major version of the model
        """
        minor: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minor version of the model
        """
        patch: NotRequired[pulumi.Input[_builtins.int]]
        """
        Patch version of the model
        """
elif False:
    GenaiOpenaiApiKeyModelVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GenaiOpenaiApiKeyModelVersionArgs:
    def __init__(__self__, *,
                 major: Optional[pulumi.Input[_builtins.int]] = None,
                 minor: Optional[pulumi.Input[_builtins.int]] = None,
                 patch: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] major: Major version of the model
        :param pulumi.Input[_builtins.int] minor: Minor version of the model
        :param pulumi.Input[_builtins.int] patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @major.setter
    def major(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "major", value)

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @minor.setter
    def minor(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "minor", value)

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")

    @patch.setter
    def patch(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "patch", value)


if not MYPY:
    class KubernetesClusterClusterAutoscalerConfigurationArgsDict(TypedDict):
        expanders: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        scale_down_unneeded_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        String setting how long a node should be unneeded before it's eligible for scale down.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        scale_down_utilization_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        Float setting the Node utilization level, defined as sum of requested resources divided by capacity, in which a node can be considered for scale down.
        """
elif False:
    KubernetesClusterClusterAutoscalerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterClusterAutoscalerConfigurationArgs:
    def __init__(__self__, *,
                 expanders: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 scale_down_unneeded_time: Optional[pulumi.Input[_builtins.str]] = None,
                 scale_down_utilization_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] scale_down_unneeded_time: String setting how long a node should be unneeded before it's eligible for scale down.
               
               This resource supports customized create timeouts. The default timeout is 30 minutes.
        :param pulumi.Input[_builtins.float] scale_down_utilization_threshold: Float setting the Node utilization level, defined as sum of requested resources divided by capacity, in which a node can be considered for scale down.
        """
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if scale_down_unneeded_time is not None:
            pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        String setting how long a node should be unneeded before it's eligible for scale down.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        return pulumi.get(self, "scale_down_unneeded_time")

    @scale_down_unneeded_time.setter
    def scale_down_unneeded_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "scale_down_unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Float setting the Node utilization level, defined as sum of requested resources divided by capacity, in which a node can be considered for scale down.
        """
        return pulumi.get(self, "scale_down_utilization_threshold")

    @scale_down_utilization_threshold.setter
    def scale_down_utilization_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "scale_down_utilization_threshold", value)


if not MYPY:
    class KubernetesClusterControlPlaneFirewallArgsDict(TypedDict):
        allowed_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of addresses allowed (CIDR notation).
        """
        enabled: pulumi.Input[_builtins.bool]
        """
        Boolean flag whether the firewall should be enabled or not.
        """
elif False:
    KubernetesClusterControlPlaneFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterControlPlaneFirewallArgs:
    def __init__(__self__, *,
                 allowed_addresses: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_addresses: A list of addresses allowed (CIDR notation).
        :param pulumi.Input[_builtins.bool] enabled: Boolean flag whether the firewall should be enabled or not.
        """
        pulumi.set(__self__, "allowed_addresses", allowed_addresses)
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter(name="allowedAddresses")
    def allowed_addresses(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of addresses allowed (CIDR notation).
        """
        return pulumi.get(self, "allowed_addresses")

    @allowed_addresses.setter
    def allowed_addresses(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_addresses", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean flag whether the firewall should be enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class KubernetesClusterKubeConfigArgsDict(TypedDict):
        client_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        client_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        cluster_ca_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        The base64 encoded public certificate for the cluster's certificate authority.
        """
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time when the credentials will expire and need to be regenerated.
        """
        host: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL of the API server on the Kubernetes master node.
        """
        raw_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full contents of the Kubernetes cluster's kubeconfig file.
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The DigitalOcean API access token used by clients to access the cluster.
        """
elif False:
    KubernetesClusterKubeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterKubeConfigArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 client_key: Optional[pulumi.Input[_builtins.str]] = None,
                 cluster_ca_certificate: Optional[pulumi.Input[_builtins.str]] = None,
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None,
                 host: Optional[pulumi.Input[_builtins.str]] = None,
                 raw_config: Optional[pulumi.Input[_builtins.str]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_certificate: The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param pulumi.Input[_builtins.str] client_key: The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param pulumi.Input[_builtins.str] cluster_ca_certificate: The base64 encoded public certificate for the cluster's certificate authority.
        :param pulumi.Input[_builtins.str] expires_at: The date and time when the credentials will expire and need to be regenerated.
        :param pulumi.Input[_builtins.str] host: The URL of the API server on the Kubernetes master node.
        :param pulumi.Input[_builtins.str] raw_config: The full contents of the Kubernetes cluster's kubeconfig file.
        :param pulumi.Input[_builtins.str] token: The DigitalOcean API access token used by clients to access the cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if raw_config is not None:
            pulumi.set(__self__, "raw_config", raw_config)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_certificate", value)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The base64 encoded public certificate for the cluster's certificate authority.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time when the credentials will expire and need to be regenerated.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL of the API server on the Kubernetes master node.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "host", value)

    @_builtins.property
    @pulumi.getter(name="rawConfig")
    def raw_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full contents of the Kubernetes cluster's kubeconfig file.
        """
        return pulumi.get(self, "raw_config")

    @raw_config.setter
    def raw_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "raw_config", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The DigitalOcean API access token used by clients to access the cluster.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class KubernetesClusterMaintenancePolicyArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[_builtins.str]]
        """
        The day of the maintenance window policy. May be one of "monday" through "sunday", or "any" to indicate an arbitrary week day.
        """
        duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string denoting the duration of the service window, e.g., "04:00".
        """
        start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The start time in UTC of the maintenance window policy in 24-hour clock format / HH:MM notation (e.g., 15:00).
        """
elif False:
    KubernetesClusterMaintenancePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMaintenancePolicyArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[_builtins.str]] = None,
                 duration: Optional[pulumi.Input[_builtins.str]] = None,
                 start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] day: The day of the maintenance window policy. May be one of "monday" through "sunday", or "any" to indicate an arbitrary week day.
        :param pulumi.Input[_builtins.str] duration: A string denoting the duration of the service window, e.g., "04:00".
        :param pulumi.Input[_builtins.str] start_time: The start time in UTC of the maintenance window policy in 24-hour clock format / HH:MM notation (e.g., 15:00).
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The day of the maintenance window policy. May be one of "monday" through "sunday", or "any" to indicate an arbitrary week day.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string denoting the duration of the service window, e.g., "04:00".
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "duration", value)

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The start time in UTC of the maintenance window policy in 24-hour clock format / HH:MM notation (e.g., 15:00).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class KubernetesClusterNodePoolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        A name for the node pool.
        """
        size: pulumi.Input[_builtins.str]
        """
        The slug identifier for the type of Droplet to be used as workers in the node pool.
        """
        actual_node_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        """
        auto_scale: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique ID that can be used to identify and reference the node.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        """
        max_nodes: NotRequired[pulumi.Input[_builtins.int]]
        """
        If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        """
        min_nodes: NotRequired[pulumi.Input[_builtins.int]]
        """
        If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        """
        node_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgsDict']]]]
        """
        A list of nodes in the pool. Each node exports the following attributes:
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of tag names applied to the node pool.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgsDict']]]]
        """
        A block representing a taint applied to all nodes in the pool. Each taint exports the following attributes (taints must be unique by key and effect pair):
        """
elif False:
    KubernetesClusterNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 size: pulumi.Input[_builtins.str],
                 actual_node_count: Optional[pulumi.Input[_builtins.int]] = None,
                 auto_scale: Optional[pulumi.Input[_builtins.bool]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 max_nodes: Optional[pulumi.Input[_builtins.int]] = None,
                 min_nodes: Optional[pulumi.Input[_builtins.int]] = None,
                 node_count: Optional[pulumi.Input[_builtins.int]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: A name for the node pool.
        :param pulumi.Input[_builtins.str] size: The slug identifier for the type of Droplet to be used as workers in the node pool.
        :param pulumi.Input[_builtins.int] actual_node_count: A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        :param pulumi.Input[_builtins.bool] auto_scale: Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        :param pulumi.Input[_builtins.str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] labels: A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        :param pulumi.Input[_builtins.int] max_nodes: If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        :param pulumi.Input[_builtins.int] min_nodes: If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        :param pulumi.Input[_builtins.int] node_count: The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]] nodes: A list of nodes in the pool. Each node exports the following attributes:
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: A list of tag names applied to the node pool.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgs']]] taints: A block representing a taint applied to all nodes in the pool. Each taint exports the following attributes (taints must be unique by key and effect pair):
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if actual_node_count is not None:
            pulumi.set(__self__, "actual_node_count", actual_node_count)
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_nodes is not None:
            pulumi.set(__self__, "max_nodes", max_nodes)
        if min_nodes is not None:
            pulumi.set(__self__, "min_nodes", min_nodes)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def size(self) -> pulumi.Input[_builtins.str]:
        """
        The slug identifier for the type of Droplet to be used as workers in the node pool.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "size", value)

    @_builtins.property
    @pulumi.getter(name="actualNodeCount")
    def actual_node_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        """
        return pulumi.get(self, "actual_node_count")

    @actual_node_count.setter
    def actual_node_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "actual_node_count", value)

    @_builtins.property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        """
        return pulumi.get(self, "auto_scale")

    @auto_scale.setter
    def auto_scale(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "auto_scale", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @_builtins.property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        """
        return pulumi.get(self, "max_nodes")

    @max_nodes.setter
    def max_nodes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_nodes", value)

    @_builtins.property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        """
        return pulumi.get(self, "min_nodes")

    @min_nodes.setter
    def min_nodes(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_nodes", value)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "node_count", value)

    @_builtins.property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]]:
        """
        A list of nodes in the pool. Each node exports the following attributes:
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of tag names applied to the node pool.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgs']]]]:
        """
        A block representing a taint applied to all nodes in the pool. Each taint exports the following attributes (taints must be unique by key and effect pair):
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class KubernetesClusterNodePoolNodeArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time when the node was created.
        """
        droplet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the node's droplet
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique ID that can be used to identify and reference the node.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A name for the Kubernetes cluster.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string indicating the current status of the individual node.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time when the node was last updated.
        """
elif False:
    KubernetesClusterNodePoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterNodePoolNodeArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 droplet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: The date and time when the node was created.
        :param pulumi.Input[_builtins.str] droplet_id: The id of the node's droplet
        :param pulumi.Input[_builtins.str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[_builtins.str] name: A name for the Kubernetes cluster.
        :param pulumi.Input[_builtins.str] status: A string indicating the current status of the individual node.
        :param pulumi.Input[_builtins.str] updated_at: The date and time when the node was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the node's droplet
        """
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "droplet_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A name for the Kubernetes cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class KubernetesClusterNodePoolTaintArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        key: pulumi.Input[_builtins.str]
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        value: pulumi.Input[_builtins.str]
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
elif False:
    KubernetesClusterNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] effect: How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        :param pulumi.Input[_builtins.str] key: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        :param pulumi.Input[_builtins.str] value: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class KubernetesClusterRoutingAgentArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Boolean flag whether the routing-agent should be enabled or not.
        """
elif False:
    KubernetesClusterRoutingAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterRoutingAgentArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean flag whether the routing-agent should be enabled or not.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean flag whether the routing-agent should be enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class KubernetesNodePoolNodeArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time when the node was created.
        """
        droplet_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The id of the node's droplet
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        A unique ID that can be used to identify and reference the node.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        A name for the node pool.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string indicating the current status of the individual node.
        """
        updated_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        The date and time when the node was last updated.
        """
elif False:
    KubernetesNodePoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolNodeArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 droplet_id: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: The date and time when the node was created.
        :param pulumi.Input[_builtins.str] droplet_id: The id of the node's droplet
        :param pulumi.Input[_builtins.str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[_builtins.str] name: A name for the node pool.
        :param pulumi.Input[_builtins.str] status: A string indicating the current status of the individual node.
        :param pulumi.Input[_builtins.str] updated_at: The date and time when the node was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The id of the node's droplet
        """
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "droplet_id", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class KubernetesNodePoolTaintArgsDict(TypedDict):
        effect: pulumi.Input[_builtins.str]
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        key: pulumi.Input[_builtins.str]
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        value: pulumi.Input[_builtins.str]
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
elif False:
    KubernetesNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[_builtins.str],
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] effect: How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        :param pulumi.Input[_builtins.str] key: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        :param pulumi.Input[_builtins.str] value: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def effect(self) -> pulumi.Input[_builtins.str]:
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "effect", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadBalancerDomainArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The domain name to be used for ingressing traffic to a Global Load Balancer.
        """
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        **Deprecated** The certificate ID to be used for TLS handshaking.
        """
        certificate_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The certificate name to be used for TLS handshaking.
        """
        is_managed: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Control flag to specify whether the domain is managed by DigitalOcean.
        """
        ssl_validation_error_reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        list of domain SSL validation errors
        """
        verification_error_reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        list of domain verification errors
        """
elif False:
    LoadBalancerDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 is_managed: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssl_validation_error_reasons: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 verification_error_reasons: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The domain name to be used for ingressing traffic to a Global Load Balancer.
        :param pulumi.Input[_builtins.str] certificate_id: **Deprecated** The certificate ID to be used for TLS handshaking.
        :param pulumi.Input[_builtins.str] certificate_name: The certificate name to be used for TLS handshaking.
        :param pulumi.Input[_builtins.bool] is_managed: Control flag to specify whether the domain is managed by DigitalOcean.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ssl_validation_error_reasons: list of domain SSL validation errors
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] verification_error_reasons: list of domain verification errors
        """
        pulumi.set(__self__, "name", name)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if is_managed is not None:
            pulumi.set(__self__, "is_managed", is_managed)
        if ssl_validation_error_reasons is not None:
            pulumi.set(__self__, "ssl_validation_error_reasons", ssl_validation_error_reasons)
        if verification_error_reasons is not None:
            pulumi.set(__self__, "verification_error_reasons", verification_error_reasons)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The domain name to be used for ingressing traffic to a Global Load Balancer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **Deprecated** The certificate ID to be used for TLS handshaking.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The certificate name to be used for TLS handshaking.
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_name", value)

    @_builtins.property
    @pulumi.getter(name="isManaged")
    def is_managed(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Control flag to specify whether the domain is managed by DigitalOcean.
        """
        return pulumi.get(self, "is_managed")

    @is_managed.setter
    def is_managed(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_managed", value)

    @_builtins.property
    @pulumi.getter(name="sslValidationErrorReasons")
    def ssl_validation_error_reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        list of domain SSL validation errors
        """
        return pulumi.get(self, "ssl_validation_error_reasons")

    @ssl_validation_error_reasons.setter
    def ssl_validation_error_reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ssl_validation_error_reasons", value)

    @_builtins.property
    @pulumi.getter(name="verificationErrorReasons")
    def verification_error_reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        list of domain verification errors
        """
        return pulumi.get(self, "verification_error_reasons")

    @verification_error_reasons.setter
    def verification_error_reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "verification_error_reasons", value)


if not MYPY:
    class LoadBalancerFirewallArgsDict(TypedDict):
        allows: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of strings describing allow rules. Must be colon delimited strings of the form `{type}:{source}`
        * Ex. `deny = ["cidr:1.2.0.0/16", "ip:2.3.4.5"]` or `allow = ["ip:1.2.3.4", "cidr:2.3.4.0/24"]`
        """
        denies: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of strings describing deny rules. Must be colon delimited strings of the form `{type}:{source}`
        """
elif False:
    LoadBalancerFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerFirewallArgs:
    def __init__(__self__, *,
                 allows: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 denies: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allows: A list of strings describing allow rules. Must be colon delimited strings of the form `{type}:{source}`
               * Ex. `deny = ["cidr:1.2.0.0/16", "ip:2.3.4.5"]` or `allow = ["ip:1.2.3.4", "cidr:2.3.4.0/24"]`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] denies: A list of strings describing deny rules. Must be colon delimited strings of the form `{type}:{source}`
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)

    @_builtins.property
    @pulumi.getter
    def allows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of strings describing allow rules. Must be colon delimited strings of the form `{type}:{source}`
        * Ex. `deny = ["cidr:1.2.0.0/16", "ip:2.3.4.5"]` or `allow = ["ip:1.2.3.4", "cidr:2.3.4.0/24"]`
        """
        return pulumi.get(self, "allows")

    @allows.setter
    def allows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allows", value)

    @_builtins.property
    @pulumi.getter
    def denies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of strings describing deny rules. Must be colon delimited strings of the form `{type}:{source}`
        """
        return pulumi.get(self, "denies")

    @denies.setter
    def denies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "denies", value)


if not MYPY:
    class LoadBalancerForwardingRuleArgsDict(TypedDict):
        entry_port: pulumi.Input[_builtins.int]
        """
        An integer representing the port on which the Load Balancer instance will listen.
        """
        entry_protocol: pulumi.Input[_builtins.str]
        """
        The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`.
        """
        target_port: pulumi.Input[_builtins.int]
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        """
        target_protocol: pulumi.Input[_builtins.str]
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`.
        """
        certificate_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        **Deprecated** The ID of the TLS certificate to be used for SSL termination. Use `certificate_name` instead.
        """
        certificate_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique name of the TLS certificate to be used for SSL termination.
        """
        tls_passthrough: NotRequired[pulumi.Input[_builtins.bool]]
        """
        A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
elif False:
    LoadBalancerForwardingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerForwardingRuleArgs:
    def __init__(__self__, *,
                 entry_port: pulumi.Input[_builtins.int],
                 entry_protocol: pulumi.Input[_builtins.str],
                 target_port: pulumi.Input[_builtins.int],
                 target_protocol: pulumi.Input[_builtins.str],
                 certificate_id: Optional[pulumi.Input[_builtins.str]] = None,
                 certificate_name: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_passthrough: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] entry_port: An integer representing the port on which the Load Balancer instance will listen.
        :param pulumi.Input[_builtins.str] entry_protocol: The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`.
        :param pulumi.Input[_builtins.int] target_port: An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        :param pulumi.Input[_builtins.str] target_protocol: The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`.
        :param pulumi.Input[_builtins.str] certificate_id: **Deprecated** The ID of the TLS certificate to be used for SSL termination. Use `certificate_name` instead.
        :param pulumi.Input[_builtins.str] certificate_name: The unique name of the TLS certificate to be used for SSL termination.
        :param pulumi.Input[_builtins.bool] tls_passthrough: A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
        pulumi.set(__self__, "entry_port", entry_port)
        pulumi.set(__self__, "entry_protocol", entry_protocol)
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if certificate_id is not None:
            warnings.warn("""Certificate IDs may change, for example when a Let's Encrypt certificate is auto-renewed. Please specify 'certificate_name' instead.""", DeprecationWarning)
            pulumi.log.warn("""certificate_id is deprecated: Certificate IDs may change, for example when a Let's Encrypt certificate is auto-renewed. Please specify 'certificate_name' instead.""")
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if tls_passthrough is not None:
            pulumi.set(__self__, "tls_passthrough", tls_passthrough)

    @_builtins.property
    @pulumi.getter(name="entryPort")
    def entry_port(self) -> pulumi.Input[_builtins.int]:
        """
        An integer representing the port on which the Load Balancer instance will listen.
        """
        return pulumi.get(self, "entry_port")

    @entry_port.setter
    def entry_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "entry_port", value)

    @_builtins.property
    @pulumi.getter(name="entryProtocol")
    def entry_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`.
        """
        return pulumi.get(self, "entry_protocol")

    @entry_protocol.setter
    def entry_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entry_protocol", value)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[_builtins.int]:
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_port", value)

    @_builtins.property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`.
        """
        return pulumi.get(self, "target_protocol")

    @target_protocol.setter
    def target_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_protocol", value)

    @_builtins.property
    @pulumi.getter(name="certificateId")
    @_utilities.deprecated("""Certificate IDs may change, for example when a Let's Encrypt certificate is auto-renewed. Please specify 'certificate_name' instead.""")
    def certificate_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        **Deprecated** The ID of the TLS certificate to be used for SSL termination. Use `certificate_name` instead.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_id", value)

    @_builtins.property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique name of the TLS certificate to be used for SSL termination.
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "certificate_name", value)

    @_builtins.property
    @pulumi.getter(name="tlsPassthrough")
    def tls_passthrough(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
        return pulumi.get(self, "tls_passthrough")

    @tls_passthrough.setter
    def tls_passthrough(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "tls_passthrough", value)


if not MYPY:
    class LoadBalancerGlbSettingsArgsDict(TypedDict):
        target_port: pulumi.Input[_builtins.int]
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic. The possible values are: `80` for `http` and `443` for `https`.
        """
        target_protocol: pulumi.Input[_builtins.str]
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http` and `https`.
        """
        cdn: NotRequired[pulumi.Input['LoadBalancerGlbSettingsCdnArgsDict']]
        """
        CDN configuration supporting the following:
        """
        failover_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        fail-over threshold
        """
        region_priorities: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]
        """
        region priority map
        """
elif False:
    LoadBalancerGlbSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerGlbSettingsArgs:
    def __init__(__self__, *,
                 target_port: pulumi.Input[_builtins.int],
                 target_protocol: pulumi.Input[_builtins.str],
                 cdn: Optional[pulumi.Input['LoadBalancerGlbSettingsCdnArgs']] = None,
                 failover_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 region_priorities: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]] = None):
        """
        :param pulumi.Input[_builtins.int] target_port: An integer representing the port on the backend Droplets to which the Load Balancer will send traffic. The possible values are: `80` for `http` and `443` for `https`.
        :param pulumi.Input[_builtins.str] target_protocol: The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http` and `https`.
        :param pulumi.Input['LoadBalancerGlbSettingsCdnArgs'] cdn: CDN configuration supporting the following:
        :param pulumi.Input[_builtins.int] failover_threshold: fail-over threshold
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]] region_priorities: region priority map
        """
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if cdn is not None:
            pulumi.set(__self__, "cdn", cdn)
        if failover_threshold is not None:
            pulumi.set(__self__, "failover_threshold", failover_threshold)
        if region_priorities is not None:
            pulumi.set(__self__, "region_priorities", region_priorities)

    @_builtins.property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[_builtins.int]:
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic. The possible values are: `80` for `http` and `443` for `https`.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "target_port", value)

    @_builtins.property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http` and `https`.
        """
        return pulumi.get(self, "target_protocol")

    @target_protocol.setter
    def target_protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_protocol", value)

    @_builtins.property
    @pulumi.getter
    def cdn(self) -> Optional[pulumi.Input['LoadBalancerGlbSettingsCdnArgs']]:
        """
        CDN configuration supporting the following:
        """
        return pulumi.get(self, "cdn")

    @cdn.setter
    def cdn(self, value: Optional[pulumi.Input['LoadBalancerGlbSettingsCdnArgs']]):
        pulumi.set(self, "cdn", value)

    @_builtins.property
    @pulumi.getter(name="failoverThreshold")
    def failover_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        fail-over threshold
        """
        return pulumi.get(self, "failover_threshold")

    @failover_threshold.setter
    def failover_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "failover_threshold", value)

    @_builtins.property
    @pulumi.getter(name="regionPriorities")
    def region_priorities(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]:
        """
        region priority map
        """
        return pulumi.get(self, "region_priorities")

    @region_priorities.setter
    def region_priorities(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.int]]]]):
        pulumi.set(self, "region_priorities", value)


if not MYPY:
    class LoadBalancerGlbSettingsCdnArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Control flag to specify if caching is enabled.
        """
elif False:
    LoadBalancerGlbSettingsCdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerGlbSettingsCdnArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] is_enabled: Control flag to specify if caching is enabled.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @_builtins.property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Control flag to specify if caching is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class LoadBalancerHealthcheckArgsDict(TypedDict):
        port: pulumi.Input[_builtins.int]
        """
        An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https` or `tcp`.
        """
        check_interval_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds between two consecutive health checks. If not specified, the default value is `10`.
        """
        healthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path on the backend Droplets to which the Load Balancer instance will send a request.
        """
        response_timeout_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
elif False:
    LoadBalancerHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerHealthcheckArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[_builtins.int],
                 protocol: pulumi.Input[_builtins.str],
                 check_interval_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 healthy_threshold: Optional[pulumi.Input[_builtins.int]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 response_timeout_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] port: An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        :param pulumi.Input[_builtins.str] protocol: The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https` or `tcp`.
        :param pulumi.Input[_builtins.int] check_interval_seconds: The number of seconds between two consecutive health checks. If not specified, the default value is `10`.
        :param pulumi.Input[_builtins.int] healthy_threshold: The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        :param pulumi.Input[_builtins.str] path: The path on the backend Droplets to which the Load Balancer instance will send a request.
        :param pulumi.Input[_builtins.int] response_timeout_seconds: The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        :param pulumi.Input[_builtins.int] unhealthy_threshold: The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if check_interval_seconds is not None:
            pulumi.set(__self__, "check_interval_seconds", check_interval_seconds)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if response_timeout_seconds is not None:
            pulumi.set(__self__, "response_timeout_seconds", response_timeout_seconds)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @_builtins.property
    @pulumi.getter
    def port(self) -> pulumi.Input[_builtins.int]:
        """
        An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "port", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https` or `tcp`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="checkIntervalSeconds")
    def check_interval_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds between two consecutive health checks. If not specified, the default value is `10`.
        """
        return pulumi.get(self, "check_interval_seconds")

    @check_interval_seconds.setter
    def check_interval_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "check_interval_seconds", value)

    @_builtins.property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "healthy_threshold", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path on the backend Droplets to which the Load Balancer instance will send a request.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="responseTimeoutSeconds")
    def response_timeout_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        """
        return pulumi.get(self, "response_timeout_seconds")

    @response_timeout_seconds.setter
    def response_timeout_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "response_timeout_seconds", value)

    @_builtins.property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class LoadBalancerStickySessionsArgsDict(TypedDict):
        cookie_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        """
        cookie_ttl_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
elif False:
    LoadBalancerStickySessionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerStickySessionsArgs:
    def __init__(__self__, *,
                 cookie_name: Optional[pulumi.Input[_builtins.str]] = None,
                 cookie_ttl_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cookie_name: The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        :param pulumi.Input[_builtins.int] cookie_ttl_seconds: The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        :param pulumi.Input[_builtins.str] type: An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if cookie_ttl_seconds is not None:
            pulumi.set(__self__, "cookie_ttl_seconds", cookie_ttl_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cookie_name", value)

    @_builtins.property
    @pulumi.getter(name="cookieTtlSeconds")
    def cookie_ttl_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_ttl_seconds")

    @cookie_ttl_seconds.setter
    def cookie_ttl_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "cookie_ttl_seconds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitorAlertAlertsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of email addresses to sent notifications to
        """
        slacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitorAlertAlertsSlackArgsDict']]]]
elif False:
    MonitorAlertAlertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorAlertAlertsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slacks: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorAlertAlertsSlackArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: List of email addresses to sent notifications to
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of email addresses to sent notifications to
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter
    def slacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorAlertAlertsSlackArgs']]]]:
        return pulumi.get(self, "slacks")

    @slacks.setter
    def slacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorAlertAlertsSlackArgs']]]]):
        pulumi.set(self, "slacks", value)


if not MYPY:
    class MonitorAlertAlertsSlackArgsDict(TypedDict):
        channel: pulumi.Input[_builtins.str]
        """
        The Slack channel to send alerts to
        """
        url: pulumi.Input[_builtins.str]
        """
        The webhook URL for Slack
        """
elif False:
    MonitorAlertAlertsSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorAlertAlertsSlackArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] channel: The Slack channel to send alerts to
        :param pulumi.Input[_builtins.str] url: The webhook URL for Slack
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack channel to send alerts to
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The webhook URL for Slack
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PartnerAttachmentBgpArgsDict(TypedDict):
        auth_key: NotRequired[pulumi.Input[_builtins.str]]
        local_router_ip: NotRequired[pulumi.Input[_builtins.str]]
        peer_router_asn: NotRequired[pulumi.Input[_builtins.int]]
        peer_router_ip: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    PartnerAttachmentBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PartnerAttachmentBgpArgs:
    def __init__(__self__, *,
                 auth_key: Optional[pulumi.Input[_builtins.str]] = None,
                 local_router_ip: Optional[pulumi.Input[_builtins.str]] = None,
                 peer_router_asn: Optional[pulumi.Input[_builtins.int]] = None,
                 peer_router_ip: Optional[pulumi.Input[_builtins.str]] = None):
        if auth_key is not None:
            pulumi.set(__self__, "auth_key", auth_key)
        if local_router_ip is not None:
            pulumi.set(__self__, "local_router_ip", local_router_ip)
        if peer_router_asn is not None:
            pulumi.set(__self__, "peer_router_asn", peer_router_asn)
        if peer_router_ip is not None:
            pulumi.set(__self__, "peer_router_ip", peer_router_ip)

    @_builtins.property
    @pulumi.getter(name="authKey")
    def auth_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "auth_key")

    @auth_key.setter
    def auth_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_key", value)

    @_builtins.property
    @pulumi.getter(name="localRouterIp")
    def local_router_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "local_router_ip")

    @local_router_ip.setter
    def local_router_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "local_router_ip", value)

    @_builtins.property
    @pulumi.getter(name="peerRouterAsn")
    def peer_router_asn(self) -> Optional[pulumi.Input[_builtins.int]]:
        return pulumi.get(self, "peer_router_asn")

    @peer_router_asn.setter
    def peer_router_asn(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "peer_router_asn", value)

    @_builtins.property
    @pulumi.getter(name="peerRouterIp")
    def peer_router_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "peer_router_ip")

    @peer_router_ip.setter
    def peer_router_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "peer_router_ip", value)


if not MYPY:
    class SpacesBucketCorsConfigurationCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of Headers that are specified in the Access-Control-Request-Headers header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
elif False:
    SpacesBucketCorsConfigurationCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketCorsConfigurationCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: Set of origins you want customers to be able to access the bucket from.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: Set of Headers that are specified in the Access-Control-Request-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] expose_headers: Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule. The value cannot be longer than 255 characters.
        :param pulumi.Input[_builtins.int] max_age_seconds: Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of Headers that are specified in the Access-Control-Request-Headers header.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "expose_headers", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class SpacesBucketCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        """
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time in seconds that browser can cache the response for a preflight request.
        """
elif False:
    SpacesBucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_methods: A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_origins: A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_headers: A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        :param pulumi.Input[_builtins.int] max_age_seconds: The time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @_builtins.property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_methods", value)

    @_builtins.property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_origins", value)

    @_builtins.property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class SpacesBucketLifecycleRuleArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Specifies lifecycle rule status.
        """
        abort_incomplete_multipart_upload_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after initiating a multipart
        upload when the multipart upload must be completed or else Spaces will abort the upload.
        """
        expiration: NotRequired[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgsDict']]
        """
        Specifies a time period after which applicable objects expire (documented below).
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique identifier for the rule.
        """
        noncurrent_version_expiration: NotRequired[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgsDict']]
        """
        Specifies when non-current object versions expire (documented below).

        At least one of `expiration` or `noncurrent_version_expiration` must be specified.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
elif False:
    SpacesBucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 abort_incomplete_multipart_upload_days: Optional[pulumi.Input[_builtins.int]] = None,
                 expiration: Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Specifies lifecycle rule status.
        :param pulumi.Input[_builtins.int] abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart
               upload when the multipart upload must be completed or else Spaces will abort the upload.
        :param pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs'] expiration: Specifies a time period after which applicable objects expire (documented below).
        :param pulumi.Input[_builtins.str] id: Unique identifier for the rule.
        :param pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs'] noncurrent_version_expiration: Specifies when non-current object versions expire (documented below).
               
               At least one of `expiration` or `noncurrent_version_expiration` must be specified.
        :param pulumi.Input[_builtins.str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after initiating a multipart
        upload when the multipart upload must be completed or else Spaces will abort the upload.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @abort_incomplete_multipart_upload_days.setter
    def abort_incomplete_multipart_upload_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "abort_incomplete_multipart_upload_days", value)

    @_builtins.property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']]:
        """
        Specifies a time period after which applicable objects expire (documented below).
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique identifier for the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']]:
        """
        Specifies when non-current object versions expire (documented below).

        At least one of `expiration` or `noncurrent_version_expiration` must be specified.
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class SpacesBucketLifecycleRuleExpirationArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the date/time after which you want applicable objects to expire. The argument uses
        RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        """
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after object creation when the applicable objects will expire.
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[_builtins.bool]]
        """
        On a versioned bucket (versioning-enabled or versioning-suspended
        bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
elif False:
    SpacesBucketLifecycleRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[_builtins.str]] = None,
                 days: Optional[pulumi.Input[_builtins.int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] date: Specifies the date/time after which you want applicable objects to expire. The argument uses
               RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        :param pulumi.Input[_builtins.int] days: Specifies the number of days after object creation when the applicable objects will expire.
        :param pulumi.Input[_builtins.bool] expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended
               bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @_builtins.property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the date/time after which you want applicable objects to expire. The argument uses
        RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "date", value)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after object creation when the applicable objects will expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)

    @_builtins.property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended
        bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[_builtins.int]]
        """
        Specifies the number of days after which an object's non-current versions expire.
        """
elif False:
    SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] days: Specifies the number of days after which an object's non-current versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @_builtins.property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Specifies the number of days after which an object's non-current versions expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class SpacesBucketVersioningArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
        state. You can, however, suspend versioning on that bucket.
        """
elif False:
    SpacesBucketVersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketVersioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
               state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
        state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class SpacesKeyGrantArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Name of the bucket associated with this grant. In case of a `fullaccess` permission, this value should be an empty string.
        """
        permission: pulumi.Input[_builtins.str]
        """
        Permission associated with this grant. Values can be `read`, `readwrite`, `fullaccess`.
        """
elif False:
    SpacesKeyGrantArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesKeyGrantArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 permission: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] bucket: Name of the bucket associated with this grant. In case of a `fullaccess` permission, this value should be an empty string.
        :param pulumi.Input[_builtins.str] permission: Permission associated with this grant. Values can be `read`, `readwrite`, `fullaccess`.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "permission", permission)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the bucket associated with this grant. In case of a `fullaccess` permission, this value should be an empty string.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def permission(self) -> pulumi.Input[_builtins.str]:
        """
        Permission associated with this grant. Values can be `read`, `readwrite`, `fullaccess`.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class UptimeAlertNotificationArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of email addresses to sent notifications to.
        """
        slacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['UptimeAlertNotificationSlackArgsDict']]]]
elif False:
    UptimeAlertNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeAlertNotificationArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 slacks: Optional[pulumi.Input[Sequence[pulumi.Input['UptimeAlertNotificationSlackArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] emails: List of email addresses to sent notifications to.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)

    @_builtins.property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of email addresses to sent notifications to.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "emails", value)

    @_builtins.property
    @pulumi.getter
    def slacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UptimeAlertNotificationSlackArgs']]]]:
        return pulumi.get(self, "slacks")

    @slacks.setter
    def slacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UptimeAlertNotificationSlackArgs']]]]):
        pulumi.set(self, "slacks", value)


if not MYPY:
    class UptimeAlertNotificationSlackArgsDict(TypedDict):
        channel: pulumi.Input[_builtins.str]
        """
        The Slack channel to send alerts to.
        """
        url: pulumi.Input[_builtins.str]
        """
        The webhook URL for Slack.
        """
elif False:
    UptimeAlertNotificationSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeAlertNotificationSlackArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[_builtins.str],
                 url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] channel: The Slack channel to send alerts to.
        :param pulumi.Input[_builtins.str] url: The webhook URL for Slack.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> pulumi.Input[_builtins.str]:
        """
        The Slack channel to send alerts to.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The webhook URL for Slack.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class VpcNatGatewayEgressArgsDict(TypedDict):
        public_gateways: NotRequired[pulumi.Input[Sequence[pulumi.Input['VpcNatGatewayEgressPublicGatewayArgsDict']]]]
        """
        List of public gateway IPs
        """
elif False:
    VpcNatGatewayEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcNatGatewayEgressArgs:
    def __init__(__self__, *,
                 public_gateways: Optional[pulumi.Input[Sequence[pulumi.Input['VpcNatGatewayEgressPublicGatewayArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VpcNatGatewayEgressPublicGatewayArgs']]] public_gateways: List of public gateway IPs
        """
        if public_gateways is not None:
            pulumi.set(__self__, "public_gateways", public_gateways)

    @_builtins.property
    @pulumi.getter(name="publicGateways")
    def public_gateways(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VpcNatGatewayEgressPublicGatewayArgs']]]]:
        """
        List of public gateway IPs
        """
        return pulumi.get(self, "public_gateways")

    @public_gateways.setter
    def public_gateways(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VpcNatGatewayEgressPublicGatewayArgs']]]]):
        pulumi.set(self, "public_gateways", value)


if not MYPY:
    class VpcNatGatewayEgressPublicGatewayArgsDict(TypedDict):
        ipv4: NotRequired[pulumi.Input[_builtins.str]]
        """
        IPv4 address
        """
elif False:
    VpcNatGatewayEgressPublicGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcNatGatewayEgressPublicGatewayArgs:
    def __init__(__self__, *,
                 ipv4: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] ipv4: IPv4 address
        """
        if ipv4 is not None:
            pulumi.set(__self__, "ipv4", ipv4)

    @_builtins.property
    @pulumi.getter
    def ipv4(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        IPv4 address
        """
        return pulumi.get(self, "ipv4")

    @ipv4.setter
    def ipv4(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ipv4", value)


if not MYPY:
    class VpcNatGatewayVpcArgsDict(TypedDict):
        vpc_uuid: pulumi.Input[_builtins.str]
        """
        The ID of the ingress VPC
        """
        default_gateway: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Boolean flag indicating if this should be the default gateway in this VPC
        """
        gateway_ip: NotRequired[pulumi.Input[_builtins.str]]
        """
        The private IP of the VPC NAT Gateway
        """
elif False:
    VpcNatGatewayVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class VpcNatGatewayVpcArgs:
    def __init__(__self__, *,
                 vpc_uuid: pulumi.Input[_builtins.str],
                 default_gateway: Optional[pulumi.Input[_builtins.bool]] = None,
                 gateway_ip: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] vpc_uuid: The ID of the ingress VPC
        :param pulumi.Input[_builtins.bool] default_gateway: Boolean flag indicating if this should be the default gateway in this VPC
        :param pulumi.Input[_builtins.str] gateway_ip: The private IP of the VPC NAT Gateway
        """
        pulumi.set(__self__, "vpc_uuid", vpc_uuid)
        if default_gateway is not None:
            pulumi.set(__self__, "default_gateway", default_gateway)
        if gateway_ip is not None:
            pulumi.set(__self__, "gateway_ip", gateway_ip)

    @_builtins.property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the ingress VPC
        """
        return pulumi.get(self, "vpc_uuid")

    @vpc_uuid.setter
    def vpc_uuid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "vpc_uuid", value)

    @_builtins.property
    @pulumi.getter(name="defaultGateway")
    def default_gateway(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Boolean flag indicating if this should be the default gateway in this VPC
        """
        return pulumi.get(self, "default_gateway")

    @default_gateway.setter
    def default_gateway(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "default_gateway", value)

    @_builtins.property
    @pulumi.getter(name="gatewayIp")
    def gateway_ip(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The private IP of the VPC NAT Gateway
        """
        return pulumi.get(self, "gateway_ip")

    @gateway_ip.setter
    def gateway_ip(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gateway_ip", value)


if not MYPY:
    class GetAppDedicatedIpArgsDict(TypedDict):
        id: _builtins.str
        """
        The ID of the dedicated egress IP.
        """
        ip: _builtins.str
        """
        The IP address of the dedicated egress IP.
        """
        status: _builtins.str
        """
        The status of the dedicated egress IP.
        """
elif False:
    GetAppDedicatedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppDedicatedIpArgs:
    def __init__(__self__, *,
                 id: _builtins.str,
                 ip: _builtins.str,
                 status: _builtins.str):
        """
        :param _builtins.str id: The ID of the dedicated egress IP.
        :param _builtins.str ip: The IP address of the dedicated egress IP.
        :param _builtins.str status: The status of the dedicated egress IP.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        The ID of the dedicated egress IP.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: _builtins.str):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def ip(self) -> _builtins.str:
        """
        The IP address of the dedicated egress IP.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: _builtins.str):
        pulumi.set(self, "ip", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> _builtins.str:
        """
        The status of the dedicated egress IP.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: _builtins.str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetDomainsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values to match against the `key` field. Only retrieves domains
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDomainsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves domains
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves domains
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetDomainsSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetDomainsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDomainsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetDropletsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values to match against the `key` field. Only retrieves Droplets
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetDropletsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDropletsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
               `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
               `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
               `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves Droplets
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves Droplets
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetDropletsSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `urn`, `vcpus`, or `vpc_uuid`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetDropletsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDropletsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
               `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
               `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
               `status`, `urn`, `vcpus`, or `vpc_uuid`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `urn`, `vcpus`, or `vpc_uuid`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetFirewallInboundRuleArgsDict(TypedDict):
        protocol: _builtins.str
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        port_range: NotRequired[_builtins.str]
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        source_addresses: NotRequired[Sequence[_builtins.str]]
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        source_droplet_ids: NotRequired[Sequence[_builtins.int]]
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        source_kubernetes_ids: NotRequired[Sequence[_builtins.str]]
        source_load_balancer_uids: NotRequired[Sequence[_builtins.str]]
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        source_tags: NotRequired[Sequence[_builtins.str]]
        """
        A set of names of Tags corresponding to group of
        Droplets from which the inbound traffic will be accepted.
        """
elif False:
    GetFirewallInboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFirewallInboundRuleArgs:
    def __init__(__self__, *,
                 protocol: _builtins.str,
                 port_range: Optional[_builtins.str] = None,
                 source_addresses: Optional[Sequence[_builtins.str]] = None,
                 source_droplet_ids: Optional[Sequence[_builtins.int]] = None,
                 source_kubernetes_ids: Optional[Sequence[_builtins.str]] = None,
                 source_load_balancer_uids: Optional[Sequence[_builtins.str]] = None,
                 source_tags: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param _builtins.str port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        :param Sequence[_builtins.str] source_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
               inbound traffic will be accepted.
        :param Sequence[_builtins.int] source_droplet_ids: An array containing the IDs of
               the Droplets from which the inbound traffic will be accepted.
        :param Sequence[_builtins.str] source_load_balancer_uids: An array containing the IDs
               of the Load Balancers from which the inbound traffic will be accepted.
        :param Sequence[_builtins.str] source_tags: A set of names of Tags corresponding to group of
               Droplets from which the inbound traffic will be accepted.
        """
        pulumi.set(__self__, "protocol", protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_droplet_ids is not None:
            pulumi.set(__self__, "source_droplet_ids", source_droplet_ids)
        if source_kubernetes_ids is not None:
            pulumi.set(__self__, "source_kubernetes_ids", source_kubernetes_ids)
        if source_load_balancer_uids is not None:
            pulumi.set(__self__, "source_load_balancer_uids", source_load_balancer_uids)
        if source_tags is not None:
            pulumi.set(__self__, "source_tags", source_tags)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: _builtins.str):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[_builtins.str]):
        pulumi.set(self, "port_range", value)

    @_builtins.property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "source_addresses", value)

    @_builtins.property
    @pulumi.getter(name="sourceDropletIds")
    def source_droplet_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_droplet_ids")

    @source_droplet_ids.setter
    def source_droplet_ids(self, value: Optional[Sequence[_builtins.int]]):
        pulumi.set(self, "source_droplet_ids", value)

    @_builtins.property
    @pulumi.getter(name="sourceKubernetesIds")
    def source_kubernetes_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "source_kubernetes_ids")

    @source_kubernetes_ids.setter
    def source_kubernetes_ids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "source_kubernetes_ids", value)

    @_builtins.property
    @pulumi.getter(name="sourceLoadBalancerUids")
    def source_load_balancer_uids(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_load_balancer_uids")

    @source_load_balancer_uids.setter
    def source_load_balancer_uids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "source_load_balancer_uids", value)

    @_builtins.property
    @pulumi.getter(name="sourceTags")
    def source_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        A set of names of Tags corresponding to group of
        Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_tags")

    @source_tags.setter
    def source_tags(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "source_tags", value)


if not MYPY:
    class GetFirewallOutboundRuleArgsDict(TypedDict):
        protocol: _builtins.str
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        destination_addresses: NotRequired[Sequence[_builtins.str]]
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        destination_droplet_ids: NotRequired[Sequence[_builtins.int]]
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        destination_kubernetes_ids: NotRequired[Sequence[_builtins.str]]
        destination_load_balancer_uids: NotRequired[Sequence[_builtins.str]]
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        destination_tags: NotRequired[Sequence[_builtins.str]]
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        traffic.
        """
        port_range: NotRequired[_builtins.str]
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
elif False:
    GetFirewallOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFirewallOutboundRuleArgs:
    def __init__(__self__, *,
                 protocol: _builtins.str,
                 destination_addresses: Optional[Sequence[_builtins.str]] = None,
                 destination_droplet_ids: Optional[Sequence[_builtins.int]] = None,
                 destination_kubernetes_ids: Optional[Sequence[_builtins.str]] = None,
                 destination_load_balancer_uids: Optional[Sequence[_builtins.str]] = None,
                 destination_tags: Optional[Sequence[_builtins.str]] = None,
                 port_range: Optional[_builtins.str] = None):
        """
        :param _builtins.str protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param Sequence[_builtins.str] destination_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
               outbound traffic will be allowed.
        :param Sequence[_builtins.int] destination_droplet_ids: An array containing the IDs of
               the Droplets to which the outbound traffic will be allowed.
        :param Sequence[_builtins.str] destination_load_balancer_uids: An array containing the IDs
               of the Load Balancers to which the outbound traffic will be allowed.
        :param Sequence[_builtins.str] destination_tags: An array containing the names of Tags
               corresponding to groups of Droplets to which the outbound traffic will
               be allowed.
               traffic.
        :param _builtins.str port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        """
        pulumi.set(__self__, "protocol", protocol)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_droplet_ids is not None:
            pulumi.set(__self__, "destination_droplet_ids", destination_droplet_ids)
        if destination_kubernetes_ids is not None:
            pulumi.set(__self__, "destination_kubernetes_ids", destination_kubernetes_ids)
        if destination_load_balancer_uids is not None:
            pulumi.set(__self__, "destination_load_balancer_uids", destination_load_balancer_uids)
        if destination_tags is not None:
            pulumi.set(__self__, "destination_tags", destination_tags)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> _builtins.str:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: _builtins.str):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "destination_addresses", value)

    @_builtins.property
    @pulumi.getter(name="destinationDropletIds")
    def destination_droplet_ids(self) -> Optional[Sequence[_builtins.int]]:
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_droplet_ids")

    @destination_droplet_ids.setter
    def destination_droplet_ids(self, value: Optional[Sequence[_builtins.int]]):
        pulumi.set(self, "destination_droplet_ids", value)

    @_builtins.property
    @pulumi.getter(name="destinationKubernetesIds")
    def destination_kubernetes_ids(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "destination_kubernetes_ids")

    @destination_kubernetes_ids.setter
    def destination_kubernetes_ids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "destination_kubernetes_ids", value)

    @_builtins.property
    @pulumi.getter(name="destinationLoadBalancerUids")
    def destination_load_balancer_uids(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_load_balancer_uids")

    @destination_load_balancer_uids.setter
    def destination_load_balancer_uids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "destination_load_balancer_uids", value)

    @_builtins.property
    @pulumi.getter(name="destinationTags")
    def destination_tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        traffic.
        """
        return pulumi.get(self, "destination_tags")

    @destination_tags.setter
    def destination_tags(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "destination_tags", value)

    @_builtins.property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[_builtins.str]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[_builtins.str]):
        pulumi.set(self, "port_range", value)


if not MYPY:
    class GetGenaiAgentAgentGuardrailArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Created At timestamp for the Guardrail
        """
        is_attached: _builtins.bool
        """
        Indicates if the Guardrail is attached
        """
        updated_at: _builtins.str
        """
        Updated At timestamp for the Guardrail
        """
        agent_uuid: NotRequired[_builtins.str]
        """
        Agent UUID for the Guardrail
        """
        default_response: NotRequired[_builtins.str]
        """
        Default response for the Guardrail
        """
        description: NotRequired[_builtins.str]
        """
        Description of the Guardrail
        """
        guardrail_uuid: NotRequired[_builtins.str]
        """
        Guardrail UUID
        """
        is_default: NotRequired[_builtins.bool]
        """
        Indicates if the Guardrail is default
        """
        name: NotRequired[_builtins.str]
        """
        Name of Guardrail
        """
        priority: NotRequired[_builtins.int]
        """
        Priority of the Guardrail
        """
        type: NotRequired[_builtins.str]
        """
        Type of the Guardrail
        """
        uuid: NotRequired[_builtins.str]
        """
        Guardrail UUID
        """
elif False:
    GetGenaiAgentAgentGuardrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentAgentGuardrailArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 is_attached: _builtins.bool,
                 updated_at: _builtins.str,
                 agent_uuid: Optional[_builtins.str] = None,
                 default_response: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 is_default: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 priority: Optional[_builtins.int] = None,
                 type: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Guardrail
        :param _builtins.bool is_attached: Indicates if the Guardrail is attached
        :param _builtins.str updated_at: Updated At timestamp for the Guardrail
        :param _builtins.str agent_uuid: Agent UUID for the Guardrail
        :param _builtins.str default_response: Default response for the Guardrail
        :param _builtins.str description: Description of the Guardrail
        :param _builtins.str guardrail_uuid: Guardrail UUID
        :param _builtins.bool is_default: Indicates if the Guardrail is default
        :param _builtins.str name: Name of Guardrail
        :param _builtins.int priority: Priority of the Guardrail
        :param _builtins.str type: Type of the Guardrail
        :param _builtins.str uuid: Guardrail UUID
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "is_attached", is_attached)
        pulumi.set(__self__, "updated_at", updated_at)
        if agent_uuid is not None:
            pulumi.set(__self__, "agent_uuid", agent_uuid)
        if default_response is not None:
            pulumi.set(__self__, "default_response", default_response)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if is_default is not None:
            pulumi.set(__self__, "is_default", is_default)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Guardrail
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="isAttached")
    def is_attached(self) -> _builtins.bool:
        """
        Indicates if the Guardrail is attached
        """
        return pulumi.get(self, "is_attached")

    @is_attached.setter
    def is_attached(self, value: _builtins.bool):
        pulumi.set(self, "is_attached", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Guardrail
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="agentUuid")
    def agent_uuid(self) -> Optional[_builtins.str]:
        """
        Agent UUID for the Guardrail
        """
        return pulumi.get(self, "agent_uuid")

    @agent_uuid.setter
    def agent_uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "agent_uuid", value)

    @_builtins.property
    @pulumi.getter(name="defaultResponse")
    def default_response(self) -> Optional[_builtins.str]:
        """
        Default response for the Guardrail
        """
        return pulumi.get(self, "default_response")

    @default_response.setter
    def default_response(self, value: Optional[_builtins.str]):
        pulumi.set(self, "default_response", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Guardrail
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "guardrail_uuid")

    @guardrail_uuid.setter
    def guardrail_uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "guardrail_uuid", value)

    @_builtins.property
    @pulumi.getter(name="isDefault")
    def is_default(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Guardrail is default
        """
        return pulumi.get(self, "is_default")

    @is_default.setter
    def is_default(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_default", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of Guardrail
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> Optional[_builtins.int]:
        """
        Priority of the Guardrail
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        Type of the Guardrail
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentAnthropicApiKeyArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Timestamp when the API Key was created
        """
        deleted_at: _builtins.str
        """
        Deleted At timestamp for the API Key
        """
        updated_at: _builtins.str
        """
        Updated At timestamp for the API Key
        """
        created_by: NotRequired[_builtins.str]
        """
        Created By user ID for the API Key
        """
        name: NotRequired[_builtins.str]
        """
        Name of the API Key
        """
        uuid: NotRequired[_builtins.str]
        """
        API Key value
        """
elif False:
    GetGenaiAgentAnthropicApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentAnthropicApiKeyArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 updated_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Timestamp when the API Key was created
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str updated_at: Updated At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Timestamp when the API Key was created
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: _builtins.str):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentApiKeyArgsDict(TypedDict):
        api_key: NotRequired[_builtins.str]
        """
        API Key value
        """
elif False:
    GetGenaiAgentApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentApiKeyArgs:
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: API Key value
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "api_key", value)


if not MYPY:
    class GetGenaiAgentApiKeyInfoArgsDict(TypedDict):
        created_at: _builtins.str
        """
        API Key value
        """
        deleted_at: _builtins.str
        """
        Deleted At timestamp for the API Key
        """
        created_by: NotRequired[_builtins.str]
        """
        Created By user ID for the API Key
        """
        name: NotRequired[_builtins.str]
        """
        Name of the API Key
        """
        secret_key: NotRequired[_builtins.str]
        """
        Updated At timestamp for the API Key
        """
        uuid: NotRequired[_builtins.str]
        """
        API Key value
        """
elif False:
    GetGenaiAgentApiKeyInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentApiKeyInfoArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 deleted_at: _builtins.str,
                 created_by: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 secret_key: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str deleted_at: Deleted At timestamp for the API Key
        :param _builtins.str created_by: Created By user ID for the API Key
        :param _builtins.str name: Name of the API Key
        :param _builtins.str secret_key: Updated At timestamp for the API Key
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "deleted_at", deleted_at)
        if created_by is not None:
            pulumi.set(__self__, "created_by", created_by)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if secret_key is not None:
            pulumi.set(__self__, "secret_key", secret_key)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="deletedAt")
    def deleted_at(self) -> _builtins.str:
        """
        Deleted At timestamp for the API Key
        """
        return pulumi.get(self, "deleted_at")

    @deleted_at.setter
    def deleted_at(self, value: _builtins.str):
        pulumi.set(self, "deleted_at", value)

    @_builtins.property
    @pulumi.getter(name="createdBy")
    def created_by(self) -> Optional[_builtins.str]:
        """
        Created By user ID for the API Key
        """
        return pulumi.get(self, "created_by")

    @created_by.setter
    def created_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "created_by", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="secretKey")
    def secret_key(self) -> Optional[_builtins.str]:
        """
        Updated At timestamp for the API Key
        """
        return pulumi.get(self, "secret_key")

    @secret_key.setter
    def secret_key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "secret_key", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentChatbotArgsDict(TypedDict):
        button_background_color: NotRequired[_builtins.str]
        """
        Background color for the chatbot button
        """
        logo: NotRequired[_builtins.str]
        """
        Logo for the chatbot
        """
        name: NotRequired[_builtins.str]
        """
        Name of the chatbot
        """
        primary_color: NotRequired[_builtins.str]
        """
        Primary color for the chatbot
        """
        secondary_color: NotRequired[_builtins.str]
        """
        Secondary color for the chatbot
        """
        starting_message: NotRequired[_builtins.str]
        """
        Starting message for the chatbot
        """
elif False:
    GetGenaiAgentChatbotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentChatbotArgs:
    def __init__(__self__, *,
                 button_background_color: Optional[_builtins.str] = None,
                 logo: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 primary_color: Optional[_builtins.str] = None,
                 secondary_color: Optional[_builtins.str] = None,
                 starting_message: Optional[_builtins.str] = None):
        """
        :param _builtins.str button_background_color: Background color for the chatbot button
        :param _builtins.str logo: Logo for the chatbot
        :param _builtins.str name: Name of the chatbot
        :param _builtins.str primary_color: Primary color for the chatbot
        :param _builtins.str secondary_color: Secondary color for the chatbot
        :param _builtins.str starting_message: Starting message for the chatbot
        """
        if button_background_color is not None:
            pulumi.set(__self__, "button_background_color", button_background_color)
        if logo is not None:
            pulumi.set(__self__, "logo", logo)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if primary_color is not None:
            pulumi.set(__self__, "primary_color", primary_color)
        if secondary_color is not None:
            pulumi.set(__self__, "secondary_color", secondary_color)
        if starting_message is not None:
            pulumi.set(__self__, "starting_message", starting_message)

    @_builtins.property
    @pulumi.getter(name="buttonBackgroundColor")
    def button_background_color(self) -> Optional[_builtins.str]:
        """
        Background color for the chatbot button
        """
        return pulumi.get(self, "button_background_color")

    @button_background_color.setter
    def button_background_color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "button_background_color", value)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional[_builtins.str]:
        """
        Logo for the chatbot
        """
        return pulumi.get(self, "logo")

    @logo.setter
    def logo(self, value: Optional[_builtins.str]):
        pulumi.set(self, "logo", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the chatbot
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="primaryColor")
    def primary_color(self) -> Optional[_builtins.str]:
        """
        Primary color for the chatbot
        """
        return pulumi.get(self, "primary_color")

    @primary_color.setter
    def primary_color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "primary_color", value)

    @_builtins.property
    @pulumi.getter(name="secondaryColor")
    def secondary_color(self) -> Optional[_builtins.str]:
        """
        Secondary color for the chatbot
        """
        return pulumi.get(self, "secondary_color")

    @secondary_color.setter
    def secondary_color(self, value: Optional[_builtins.str]):
        pulumi.set(self, "secondary_color", value)

    @_builtins.property
    @pulumi.getter(name="startingMessage")
    def starting_message(self) -> Optional[_builtins.str]:
        """
        Starting message for the chatbot
        """
        return pulumi.get(self, "starting_message")

    @starting_message.setter
    def starting_message(self, value: Optional[_builtins.str]):
        pulumi.set(self, "starting_message", value)


if not MYPY:
    class GetGenaiAgentChatbotIdentifierArgsDict(TypedDict):
        chatbot_id: NotRequired[_builtins.str]
        """
        Chatbot ID
        """
elif False:
    GetGenaiAgentChatbotIdentifierArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentChatbotIdentifierArgs:
    def __init__(__self__, *,
                 chatbot_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str chatbot_id: Chatbot ID
        """
        if chatbot_id is not None:
            pulumi.set(__self__, "chatbot_id", chatbot_id)

    @_builtins.property
    @pulumi.getter(name="chatbotId")
    def chatbot_id(self) -> Optional[_builtins.str]:
        """
        Chatbot ID
        """
        return pulumi.get(self, "chatbot_id")

    @chatbot_id.setter
    def chatbot_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "chatbot_id", value)


if not MYPY:
    class GetGenaiAgentDeploymentArgsDict(TypedDict):
        created_at: _builtins.str
        """
        API Key value
        """
        updated_at: _builtins.str
        """
        Updated At timestamp for the Agent
        """
        name: NotRequired[_builtins.str]
        """
        Name of the API Key
        """
        status: NotRequired[_builtins.str]
        """
        Status of the Deployment
        """
        url: NotRequired[_builtins.str]
        """
        Url of the Deployment
        """
        uuid: NotRequired[_builtins.str]
        """
        API Key value
        """
        visibility: NotRequired[_builtins.str]
        """
        Visibility of the Deployment
        """
elif False:
    GetGenaiAgentDeploymentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentDeploymentArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 name: Optional[_builtins.str] = None,
                 status: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None,
                 visibility: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: API Key value
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str name: Name of the API Key
        :param _builtins.str status: Status of the Deployment
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        :param _builtins.str visibility: Visibility of the Deployment
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)
        if visibility is not None:
            pulumi.set(__self__, "visibility", visibility)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        API Key value
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the API Key
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[_builtins.str]:
        """
        Status of the Deployment
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[_builtins.str]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter
    def visibility(self) -> Optional[_builtins.str]:
        """
        Visibility of the Deployment
        """
        return pulumi.get(self, "visibility")

    @visibility.setter
    def visibility(self, value: Optional[_builtins.str]):
        pulumi.set(self, "visibility", value)


if not MYPY:
    class GetGenaiAgentFunctionArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Created At timestamp for the Function
        """
        updated_at: _builtins.str
        """
        Updated At timestamp for the Agent
        """
        api_key: NotRequired[_builtins.str]
        """
        API Key value
        """
        description: NotRequired[_builtins.str]
        """
        Description of the Function
        """
        faasname: NotRequired[_builtins.str]
        """
        Name of function
        """
        faasnamespace: NotRequired[_builtins.str]
        """
        Namespace of function
        """
        guardrail_uuid: NotRequired[_builtins.str]
        """
        Guardrail UUID for the Function
        """
        name: NotRequired[_builtins.str]
        """
        Name of function
        """
        url: NotRequired[_builtins.str]
        """
        Url of the Deployment
        """
        uuid: NotRequired[_builtins.str]
        """
        API Key value
        """
elif False:
    GetGenaiAgentFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentFunctionArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 api_key: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 faasname: Optional[_builtins.str] = None,
                 faasnamespace: Optional[_builtins.str] = None,
                 guardrail_uuid: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Function
        :param _builtins.str updated_at: Updated At timestamp for the Agent
        :param _builtins.str api_key: API Key value
        :param _builtins.str description: Description of the Function
        :param _builtins.str faasname: Name of function
        :param _builtins.str faasnamespace: Namespace of function
        :param _builtins.str guardrail_uuid: Guardrail UUID for the Function
        :param _builtins.str name: Name of function
        :param _builtins.str url: Url of the Deployment
        :param _builtins.str uuid: API Key value
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if faasname is not None:
            pulumi.set(__self__, "faasname", faasname)
        if faasnamespace is not None:
            pulumi.set(__self__, "faasnamespace", faasnamespace)
        if guardrail_uuid is not None:
            pulumi.set(__self__, "guardrail_uuid", guardrail_uuid)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Function
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Function
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def faasname(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "faasname")

    @faasname.setter
    def faasname(self, value: Optional[_builtins.str]):
        pulumi.set(self, "faasname", value)

    @_builtins.property
    @pulumi.getter
    def faasnamespace(self) -> Optional[_builtins.str]:
        """
        Namespace of function
        """
        return pulumi.get(self, "faasnamespace")

    @faasnamespace.setter
    def faasnamespace(self, value: Optional[_builtins.str]):
        pulumi.set(self, "faasnamespace", value)

    @_builtins.property
    @pulumi.getter(name="guardrailUuid")
    def guardrail_uuid(self) -> Optional[_builtins.str]:
        """
        Guardrail UUID for the Function
        """
        return pulumi.get(self, "guardrail_uuid")

    @guardrail_uuid.setter
    def guardrail_uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "guardrail_uuid", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of function
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Url of the Deployment
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        API Key value
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentKnowledgeBaseArgsDict(TypedDict):
        added_to_agent_at: _builtins.str
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        created_at: _builtins.str
        """
        Created At timestamp for the Knowledge Base
        """
        updated_at: _builtins.str
        """
        Timestamp when the Knowledge Base was updated
        """
        uuid: _builtins.str
        """
        UUID of the Knowledge Base
        """
        database_id: NotRequired[_builtins.str]
        """
        Database ID of the Knowledge Base
        """
        embedding_model_uuid: NotRequired[_builtins.str]
        """
        Embedding model UUID for the Knowledge Base
        """
        is_public: NotRequired[_builtins.bool]
        """
        Indicates if the Knowledge Base is public
        """
        last_indexing_jobs: NotRequired[Sequence['GetGenaiAgentKnowledgeBaseLastIndexingJobArgsDict']]
        """
        Last indexing job for the Knowledge Base
        """
        name: NotRequired[_builtins.str]
        """
        Name of the Knowledge Base
        """
        project_id: NotRequired[_builtins.str]
        """
        Project ID of the Knowledge Base
        """
        region: NotRequired[_builtins.str]
        """
        Region of the Knowledge Base
        """
        tags: NotRequired[Sequence[_builtins.str]]
        """
        List of tags
        """
        user_id: NotRequired[_builtins.str]
        """
        User ID of the Knowledge Base
        """
elif False:
    GetGenaiAgentKnowledgeBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentKnowledgeBaseArgs:
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_jobs: Optional[Sequence['GetGenaiAgentKnowledgeBaseLastIndexingJobArgs']] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GetGenaiAgentKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str user_id: User ID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @added_to_agent_at.setter
    def added_to_agent_at(self, value: _builtins.str):
        pulumi.set(self, "added_to_agent_at", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: _builtins.str):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "database_id", value)

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @embedding_model_uuid.setter
    def embedding_model_uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "embedding_model_uuid", value)

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_public", value)

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['GetGenaiAgentKnowledgeBaseLastIndexingJobArgs']]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @last_indexing_jobs.setter
    def last_indexing_jobs(self, value: Optional[Sequence['GetGenaiAgentKnowledgeBaseLastIndexingJobArgs']]):
        pulumi.set(self, "last_indexing_jobs", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetGenaiAgentKnowledgeBaseLastIndexingJobArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Created At timestamp for the last indexing job
        """
        finished_at: _builtins.str
        """
        Timestamp when the last indexing job finished
        """
        knowledge_base_uuid: _builtins.str
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        started_at: _builtins.str
        """
        Timestamp when the last indexing job started
        """
        updated_at: _builtins.str
        """
        Timestamp when the last indexing job updated
        """
        completed_datasources: NotRequired[_builtins.int]
        """
        Number of completed datasources in the last indexing job
        """
        data_source_uuids: NotRequired[Sequence[_builtins.str]]
        """
        Datasource UUIDs for the last indexing job
        """
        phase: NotRequired[_builtins.str]
        """
        Phase of the last indexing job
        """
        tokens: NotRequired[_builtins.int]
        """
        Number of tokens processed in the last indexing job
        """
        total_datasources: NotRequired[_builtins.int]
        """
        Total number of datasources in the last indexing job
        """
        uuid: NotRequired[_builtins.str]
        """
        UUID  of the last indexing job
        """
elif False:
    GetGenaiAgentKnowledgeBaseLastIndexingJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentKnowledgeBaseLastIndexingJobArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @finished_at.setter
    def finished_at(self, value: _builtins.str):
        pulumi.set(self, "finished_at", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @knowledge_base_uuid.setter
    def knowledge_base_uuid(self, value: _builtins.str):
        pulumi.set(self, "knowledge_base_uuid", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: _builtins.str):
        pulumi.set(self, "started_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @completed_datasources.setter
    def completed_datasources(self, value: Optional[_builtins.int]):
        pulumi.set(self, "completed_datasources", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @data_source_uuids.setter
    def data_source_uuids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "data_source_uuids", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[_builtins.str]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[_builtins.int]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @total_datasources.setter
    def total_datasources(self, value: Optional[_builtins.int]):
        pulumi.set(self, "total_datasources", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentModelArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Created At timestamp for the Knowledge Base
        """
        updated_at: _builtins.str
        """
        Timestamp when the Knowledge Base was updated
        """
        agreements: NotRequired[Sequence['GetGenaiAgentModelAgreementArgsDict']]
        """
        Agreement information for the model
        """
        inference_name: NotRequired[_builtins.str]
        """
        Inference name of the model
        """
        inference_version: NotRequired[_builtins.str]
        """
        Infernce version of the model
        """
        is_foundational: NotRequired[_builtins.bool]
        """
        Indicates if the Model Base is foundational
        """
        name: NotRequired[_builtins.str]
        """
        Name of the Knowledge Base
        """
        parent_uuid: NotRequired[_builtins.str]
        """
        Parent UUID of the Model
        """
        provider: NotRequired[_builtins.str]
        """
        Provider of the Model
        """
        upload_complete: NotRequired[_builtins.bool]
        """
        Indicates if the Model upload is complete
        """
        url: NotRequired[_builtins.str]
        """
        URL of the Model
        """
        usecases: NotRequired[Sequence[_builtins.str]]
        """
        List of Usecases for the Model
        """
        versions: NotRequired[Sequence['GetGenaiAgentModelVersionArgsDict']]
        """
        URL of the Model
        """
elif False:
    GetGenaiAgentModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentModelArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['GetGenaiAgentModelAgreementArgs']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['GetGenaiAgentModelVersionArgs']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiAgentModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiAgentModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['GetGenaiAgentModelAgreementArgs']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @agreements.setter
    def agreements(self, value: Optional[Sequence['GetGenaiAgentModelAgreementArgs']]):
        pulumi.set(self, "agreements", value)

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @inference_name.setter
    def inference_name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "inference_name", value)

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @inference_version.setter
    def inference_version(self, value: Optional[_builtins.str]):
        pulumi.set(self, "inference_version", value)

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @is_foundational.setter
    def is_foundational(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_foundational", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @parent_uuid.setter
    def parent_uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "parent_uuid", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[_builtins.str]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @upload_complete.setter
    def upload_complete(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "upload_complete", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @usecases.setter
    def usecases(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "usecases", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['GetGenaiAgentModelVersionArgs']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[Sequence['GetGenaiAgentModelVersionArgs']]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class GetGenaiAgentModelAgreementArgsDict(TypedDict):
        description: NotRequired[_builtins.str]
        """
        Description of the agreement
        """
        name: NotRequired[_builtins.str]
        """
        Name of the agreement
        """
        url: NotRequired[_builtins.str]
        """
        URL of the agreement
        """
        uuid: NotRequired[_builtins.str]
        """
        UUID of the agreement
        """
elif False:
    GetGenaiAgentModelAgreementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentModelAgreementArgs:
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentModelVersionArgsDict(TypedDict):
        major: NotRequired[_builtins.int]
        """
        Major version of the model
        """
        minor: NotRequired[_builtins.int]
        """
        Minor version of the model
        """
        patch: NotRequired[_builtins.int]
        """
        Patch version of the model
        """
elif False:
    GetGenaiAgentModelVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentModelVersionArgs:
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @major.setter
    def major(self, value: Optional[_builtins.int]):
        pulumi.set(self, "major", value)

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @minor.setter
    def minor(self, value: Optional[_builtins.int]):
        pulumi.set(self, "minor", value)

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")

    @patch.setter
    def patch(self, value: Optional[_builtins.int]):
        pulumi.set(self, "patch", value)


if not MYPY:
    class GetGenaiAgentOpenAiApiKeyArgsDict(TypedDict):
        api_key: NotRequired[_builtins.str]
        """
        OpenAI API Key
        """
elif False:
    GetGenaiAgentOpenAiApiKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentOpenAiApiKeyArgs:
    def __init__(__self__, *,
                 api_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key: OpenAI API Key
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[_builtins.str]:
        """
        OpenAI API Key
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[_builtins.str]):
        pulumi.set(self, "api_key", value)


if not MYPY:
    class GetGenaiAgentTemplateArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Created At timestamp for the Knowledge Base
        """
        updated_at: _builtins.str
        """
        Updated At timestamp for the Agent Template
        """
        description: NotRequired[_builtins.str]
        """
        Description of the Agent Template
        """
        instruction: NotRequired[_builtins.str]
        """
        Instruction for the Agent
        """
        k: NotRequired[_builtins.int]
        """
        K value for the Agent Template
        """
        knowledge_bases: NotRequired[Sequence['GetGenaiAgentTemplateKnowledgeBaseArgsDict']]
        """
        List of Knowledge Bases
        """
        max_tokens: NotRequired[_builtins.int]
        """
        Maximum tokens allowed
        """
        models: NotRequired[Sequence['GetGenaiAgentTemplateModelArgsDict']]
        """
        Model of the Agent Template
        """
        name: NotRequired[_builtins.str]
        """
        Name of the Agent Template
        """
        temperature: NotRequired[_builtins.float]
        """
        Agent temperature setting
        """
        top_p: NotRequired[_builtins.float]
        """
        Top P sampling parameter
        """
        uuid: NotRequired[_builtins.str]
        """
        uuid of the Agent Template
        """
elif False:
    GetGenaiAgentTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentTemplateArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 instruction: Optional[_builtins.str] = None,
                 k: Optional[_builtins.int] = None,
                 knowledge_bases: Optional[Sequence['GetGenaiAgentTemplateKnowledgeBaseArgs']] = None,
                 max_tokens: Optional[_builtins.int] = None,
                 models: Optional[Sequence['GetGenaiAgentTemplateModelArgs']] = None,
                 name: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None,
                 top_p: Optional[_builtins.float] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Updated At timestamp for the Agent Template
        :param _builtins.str description: Description of the Agent Template
        :param _builtins.str instruction: Instruction for the Agent
        :param _builtins.int k: K value for the Agent Template
        :param Sequence['GetGenaiAgentTemplateKnowledgeBaseArgs'] knowledge_bases: List of Knowledge Bases
        :param _builtins.int max_tokens: Maximum tokens allowed
        :param Sequence['GetGenaiAgentTemplateModelArgs'] models: Model of the Agent Template
        :param _builtins.str name: Name of the Agent Template
        :param _builtins.float temperature: Agent temperature setting
        :param _builtins.float top_p: Top P sampling parameter
        :param _builtins.str uuid: uuid of the Agent Template
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)
        if k is not None:
            pulumi.set(__self__, "k", k)
        if knowledge_bases is not None:
            pulumi.set(__self__, "knowledge_bases", knowledge_bases)
        if max_tokens is not None:
            pulumi.set(__self__, "max_tokens", max_tokens)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Updated At timestamp for the Agent Template
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the Agent Template
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[_builtins.str]:
        """
        Instruction for the Agent
        """
        return pulumi.get(self, "instruction")

    @instruction.setter
    def instruction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "instruction", value)

    @_builtins.property
    @pulumi.getter
    def k(self) -> Optional[_builtins.int]:
        """
        K value for the Agent Template
        """
        return pulumi.get(self, "k")

    @k.setter
    def k(self, value: Optional[_builtins.int]):
        pulumi.set(self, "k", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> Optional[Sequence['GetGenaiAgentTemplateKnowledgeBaseArgs']]:
        """
        List of Knowledge Bases
        """
        return pulumi.get(self, "knowledge_bases")

    @knowledge_bases.setter
    def knowledge_bases(self, value: Optional[Sequence['GetGenaiAgentTemplateKnowledgeBaseArgs']]):
        pulumi.set(self, "knowledge_bases", value)

    @_builtins.property
    @pulumi.getter(name="maxTokens")
    def max_tokens(self) -> Optional[_builtins.int]:
        """
        Maximum tokens allowed
        """
        return pulumi.get(self, "max_tokens")

    @max_tokens.setter
    def max_tokens(self, value: Optional[_builtins.int]):
        pulumi.set(self, "max_tokens", value)

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[Sequence['GetGenaiAgentTemplateModelArgs']]:
        """
        Model of the Agent Template
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[Sequence['GetGenaiAgentTemplateModelArgs']]):
        pulumi.set(self, "models", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Agent Template
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        Agent temperature setting
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[_builtins.float]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[_builtins.float]:
        """
        Top P sampling parameter
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[_builtins.float]):
        pulumi.set(self, "top_p", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        uuid of the Agent Template
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentTemplateKnowledgeBaseArgsDict(TypedDict):
        added_to_agent_at: _builtins.str
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        created_at: _builtins.str
        """
        Created At timestamp for the Knowledge Base
        """
        updated_at: _builtins.str
        """
        Timestamp when the Knowledge Base was updated
        """
        uuid: _builtins.str
        """
        UUID of the Knowledge Base
        """
        database_id: NotRequired[_builtins.str]
        """
        Database ID of the Knowledge Base
        """
        embedding_model_uuid: NotRequired[_builtins.str]
        """
        Embedding model UUID for the Knowledge Base
        """
        is_public: NotRequired[_builtins.bool]
        """
        Indicates if the Knowledge Base is public
        """
        last_indexing_jobs: NotRequired[Sequence['GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgsDict']]
        """
        Last indexing job for the Knowledge Base
        """
        name: NotRequired[_builtins.str]
        """
        Name of the Knowledge Base
        """
        project_id: NotRequired[_builtins.str]
        """
        Project ID of the Knowledge Base
        """
        region: NotRequired[_builtins.str]
        """
        Region of the Knowledge Base
        """
        tags: NotRequired[Sequence[_builtins.str]]
        """
        List of tags
        """
        user_id: NotRequired[_builtins.str]
        """
        User ID of the Knowledge Base
        """
elif False:
    GetGenaiAgentTemplateKnowledgeBaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentTemplateKnowledgeBaseArgs:
    def __init__(__self__, *,
                 added_to_agent_at: _builtins.str,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 uuid: _builtins.str,
                 database_id: Optional[_builtins.str] = None,
                 embedding_model_uuid: Optional[_builtins.str] = None,
                 is_public: Optional[_builtins.bool] = None,
                 last_indexing_jobs: Optional[Sequence['GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs']] = None,
                 name: Optional[_builtins.str] = None,
                 project_id: Optional[_builtins.str] = None,
                 region: Optional[_builtins.str] = None,
                 tags: Optional[Sequence[_builtins.str]] = None,
                 user_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str added_to_agent_at: Timestamp when the Knowledge Base was added to the Agent
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param _builtins.str uuid: UUID of the Knowledge Base
        :param _builtins.str database_id: Database ID of the Knowledge Base
        :param _builtins.str embedding_model_uuid: Embedding model UUID for the Knowledge Base
        :param _builtins.bool is_public: Indicates if the Knowledge Base is public
        :param Sequence['GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs'] last_indexing_jobs: Last indexing job for the Knowledge Base
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str project_id: Project ID of the Knowledge Base
        :param _builtins.str region: Region of the Knowledge Base
        :param Sequence[_builtins.str] tags: List of tags
        :param _builtins.str user_id: User ID of the Knowledge Base
        """
        pulumi.set(__self__, "added_to_agent_at", added_to_agent_at)
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        pulumi.set(__self__, "uuid", uuid)
        if database_id is not None:
            pulumi.set(__self__, "database_id", database_id)
        if embedding_model_uuid is not None:
            pulumi.set(__self__, "embedding_model_uuid", embedding_model_uuid)
        if is_public is not None:
            pulumi.set(__self__, "is_public", is_public)
        if last_indexing_jobs is not None:
            pulumi.set(__self__, "last_indexing_jobs", last_indexing_jobs)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_id is not None:
            pulumi.set(__self__, "user_id", user_id)

    @_builtins.property
    @pulumi.getter(name="addedToAgentAt")
    def added_to_agent_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was added to the Agent
        """
        return pulumi.get(self, "added_to_agent_at")

    @added_to_agent_at.setter
    def added_to_agent_at(self, value: _builtins.str):
        pulumi.set(self, "added_to_agent_at", value)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> _builtins.str:
        """
        UUID of the Knowledge Base
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: _builtins.str):
        pulumi.set(self, "uuid", value)

    @_builtins.property
    @pulumi.getter(name="databaseId")
    def database_id(self) -> Optional[_builtins.str]:
        """
        Database ID of the Knowledge Base
        """
        return pulumi.get(self, "database_id")

    @database_id.setter
    def database_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "database_id", value)

    @_builtins.property
    @pulumi.getter(name="embeddingModelUuid")
    def embedding_model_uuid(self) -> Optional[_builtins.str]:
        """
        Embedding model UUID for the Knowledge Base
        """
        return pulumi.get(self, "embedding_model_uuid")

    @embedding_model_uuid.setter
    def embedding_model_uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "embedding_model_uuid", value)

    @_builtins.property
    @pulumi.getter(name="isPublic")
    def is_public(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Knowledge Base is public
        """
        return pulumi.get(self, "is_public")

    @is_public.setter
    def is_public(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_public", value)

    @_builtins.property
    @pulumi.getter(name="lastIndexingJobs")
    def last_indexing_jobs(self) -> Optional[Sequence['GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs']]:
        """
        Last indexing job for the Knowledge Base
        """
        return pulumi.get(self, "last_indexing_jobs")

    @last_indexing_jobs.setter
    def last_indexing_jobs(self, value: Optional[Sequence['GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs']]):
        pulumi.set(self, "last_indexing_jobs", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Project ID of the Knowledge Base
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[_builtins.str]:
        """
        Region of the Knowledge Base
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[_builtins.str]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of tags
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "tags", value)

    @_builtins.property
    @pulumi.getter(name="userId")
    def user_id(self) -> Optional[_builtins.str]:
        """
        User ID of the Knowledge Base
        """
        return pulumi.get(self, "user_id")

    @user_id.setter
    def user_id(self, value: Optional[_builtins.str]):
        pulumi.set(self, "user_id", value)


if not MYPY:
    class GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Created At timestamp for the last indexing job
        """
        finished_at: _builtins.str
        """
        Timestamp when the last indexing job finished
        """
        knowledge_base_uuid: _builtins.str
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        started_at: _builtins.str
        """
        Timestamp when the last indexing job started
        """
        updated_at: _builtins.str
        """
        Timestamp when the last indexing job updated
        """
        completed_datasources: NotRequired[_builtins.int]
        """
        Number of completed datasources in the last indexing job
        """
        data_source_uuids: NotRequired[Sequence[_builtins.str]]
        """
        Datasource UUIDs for the last indexing job
        """
        phase: NotRequired[_builtins.str]
        """
        Phase of the last indexing job
        """
        tokens: NotRequired[_builtins.int]
        """
        Number of tokens processed in the last indexing job
        """
        total_datasources: NotRequired[_builtins.int]
        """
        Total number of datasources in the last indexing job
        """
        uuid: NotRequired[_builtins.str]
        """
        UUID  of the last indexing job
        """
elif False:
    GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentTemplateKnowledgeBaseLastIndexingJobArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @finished_at.setter
    def finished_at(self, value: _builtins.str):
        pulumi.set(self, "finished_at", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @knowledge_base_uuid.setter
    def knowledge_base_uuid(self, value: _builtins.str):
        pulumi.set(self, "knowledge_base_uuid", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: _builtins.str):
        pulumi.set(self, "started_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @completed_datasources.setter
    def completed_datasources(self, value: Optional[_builtins.int]):
        pulumi.set(self, "completed_datasources", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @data_source_uuids.setter
    def data_source_uuids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "data_source_uuids", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[_builtins.str]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[_builtins.int]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @total_datasources.setter
    def total_datasources(self, value: Optional[_builtins.int]):
        pulumi.set(self, "total_datasources", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentTemplateModelArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Created At timestamp for the Knowledge Base
        """
        updated_at: _builtins.str
        """
        Timestamp when the Knowledge Base was updated
        """
        agreements: NotRequired[Sequence['GetGenaiAgentTemplateModelAgreementArgsDict']]
        """
        Agreement information for the model
        """
        inference_name: NotRequired[_builtins.str]
        """
        Inference name of the model
        """
        inference_version: NotRequired[_builtins.str]
        """
        Infernce version of the model
        """
        is_foundational: NotRequired[_builtins.bool]
        """
        Indicates if the Model Base is foundational
        """
        name: NotRequired[_builtins.str]
        """
        Name of the Knowledge Base
        """
        parent_uuid: NotRequired[_builtins.str]
        """
        Parent UUID of the Model
        """
        provider: NotRequired[_builtins.str]
        """
        Provider of the Model
        """
        upload_complete: NotRequired[_builtins.bool]
        """
        Indicates if the Model upload is complete
        """
        url: NotRequired[_builtins.str]
        """
        URL of the Model
        """
        usecases: NotRequired[Sequence[_builtins.str]]
        """
        List of Usecases for the Model
        """
        versions: NotRequired[Sequence['GetGenaiAgentTemplateModelVersionArgsDict']]
        """
        URL of the Model
        """
elif False:
    GetGenaiAgentTemplateModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentTemplateModelArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 updated_at: _builtins.str,
                 agreements: Optional[Sequence['GetGenaiAgentTemplateModelAgreementArgs']] = None,
                 inference_name: Optional[_builtins.str] = None,
                 inference_version: Optional[_builtins.str] = None,
                 is_foundational: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 parent_uuid: Optional[_builtins.str] = None,
                 provider: Optional[_builtins.str] = None,
                 upload_complete: Optional[_builtins.bool] = None,
                 url: Optional[_builtins.str] = None,
                 usecases: Optional[Sequence[_builtins.str]] = None,
                 versions: Optional[Sequence['GetGenaiAgentTemplateModelVersionArgs']] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the Knowledge Base
        :param _builtins.str updated_at: Timestamp when the Knowledge Base was updated
        :param Sequence['GetGenaiAgentTemplateModelAgreementArgs'] agreements: Agreement information for the model
        :param _builtins.str inference_name: Inference name of the model
        :param _builtins.str inference_version: Infernce version of the model
        :param _builtins.bool is_foundational: Indicates if the Model Base is foundational
        :param _builtins.str name: Name of the Knowledge Base
        :param _builtins.str parent_uuid: Parent UUID of the Model
        :param _builtins.str provider: Provider of the Model
        :param _builtins.bool upload_complete: Indicates if the Model upload is complete
        :param _builtins.str url: URL of the Model
        :param Sequence[_builtins.str] usecases: List of Usecases for the Model
        :param Sequence['GetGenaiAgentTemplateModelVersionArgs'] versions: URL of the Model
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if agreements is not None:
            pulumi.set(__self__, "agreements", agreements)
        if inference_name is not None:
            pulumi.set(__self__, "inference_name", inference_name)
        if inference_version is not None:
            pulumi.set(__self__, "inference_version", inference_version)
        if is_foundational is not None:
            pulumi.set(__self__, "is_foundational", is_foundational)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parent_uuid is not None:
            pulumi.set(__self__, "parent_uuid", parent_uuid)
        if provider is not None:
            pulumi.set(__self__, "provider", provider)
        if upload_complete is not None:
            pulumi.set(__self__, "upload_complete", upload_complete)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if usecases is not None:
            pulumi.set(__self__, "usecases", usecases)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the Knowledge Base
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the Knowledge Base was updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter
    def agreements(self) -> Optional[Sequence['GetGenaiAgentTemplateModelAgreementArgs']]:
        """
        Agreement information for the model
        """
        return pulumi.get(self, "agreements")

    @agreements.setter
    def agreements(self, value: Optional[Sequence['GetGenaiAgentTemplateModelAgreementArgs']]):
        pulumi.set(self, "agreements", value)

    @_builtins.property
    @pulumi.getter(name="inferenceName")
    def inference_name(self) -> Optional[_builtins.str]:
        """
        Inference name of the model
        """
        return pulumi.get(self, "inference_name")

    @inference_name.setter
    def inference_name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "inference_name", value)

    @_builtins.property
    @pulumi.getter(name="inferenceVersion")
    def inference_version(self) -> Optional[_builtins.str]:
        """
        Infernce version of the model
        """
        return pulumi.get(self, "inference_version")

    @inference_version.setter
    def inference_version(self, value: Optional[_builtins.str]):
        pulumi.set(self, "inference_version", value)

    @_builtins.property
    @pulumi.getter(name="isFoundational")
    def is_foundational(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model Base is foundational
        """
        return pulumi.get(self, "is_foundational")

    @is_foundational.setter
    def is_foundational(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "is_foundational", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the Knowledge Base
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="parentUuid")
    def parent_uuid(self) -> Optional[_builtins.str]:
        """
        Parent UUID of the Model
        """
        return pulumi.get(self, "parent_uuid")

    @parent_uuid.setter
    def parent_uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "parent_uuid", value)

    @_builtins.property
    @pulumi.getter
    def provider(self) -> Optional[_builtins.str]:
        """
        Provider of the Model
        """
        return pulumi.get(self, "provider")

    @provider.setter
    def provider(self, value: Optional[_builtins.str]):
        pulumi.set(self, "provider", value)

    @_builtins.property
    @pulumi.getter(name="uploadComplete")
    def upload_complete(self) -> Optional[_builtins.bool]:
        """
        Indicates if the Model upload is complete
        """
        return pulumi.get(self, "upload_complete")

    @upload_complete.setter
    def upload_complete(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "upload_complete", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the Model
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def usecases(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of Usecases for the Model
        """
        return pulumi.get(self, "usecases")

    @usecases.setter
    def usecases(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "usecases", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[Sequence['GetGenaiAgentTemplateModelVersionArgs']]:
        """
        URL of the Model
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[Sequence['GetGenaiAgentTemplateModelVersionArgs']]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class GetGenaiAgentTemplateModelAgreementArgsDict(TypedDict):
        description: NotRequired[_builtins.str]
        """
        Description of the agreement
        """
        name: NotRequired[_builtins.str]
        """
        Name of the agreement
        """
        url: NotRequired[_builtins.str]
        """
        URL of the agreement
        """
        uuid: NotRequired[_builtins.str]
        """
        UUID of the agreement
        """
elif False:
    GetGenaiAgentTemplateModelAgreementArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentTemplateModelAgreementArgs:
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 url: Optional[_builtins.str] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: Description of the agreement
        :param _builtins.str name: Name of the agreement
        :param _builtins.str url: URL of the agreement
        :param _builtins.str uuid: UUID of the agreement
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if url is not None:
            pulumi.set(__self__, "url", url)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the agreement
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Name of the agreement
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        URL of the agreement
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID of the agreement
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiAgentTemplateModelVersionArgsDict(TypedDict):
        major: NotRequired[_builtins.int]
        """
        Major version of the model
        """
        minor: NotRequired[_builtins.int]
        """
        Minor version of the model
        """
        patch: NotRequired[_builtins.int]
        """
        Patch version of the model
        """
elif False:
    GetGenaiAgentTemplateModelVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentTemplateModelVersionArgs:
    def __init__(__self__, *,
                 major: Optional[_builtins.int] = None,
                 minor: Optional[_builtins.int] = None,
                 patch: Optional[_builtins.int] = None):
        """
        :param _builtins.int major: Major version of the model
        :param _builtins.int minor: Minor version of the model
        :param _builtins.int patch: Patch version of the model
        """
        if major is not None:
            pulumi.set(__self__, "major", major)
        if minor is not None:
            pulumi.set(__self__, "minor", minor)
        if patch is not None:
            pulumi.set(__self__, "patch", patch)

    @_builtins.property
    @pulumi.getter
    def major(self) -> Optional[_builtins.int]:
        """
        Major version of the model
        """
        return pulumi.get(self, "major")

    @major.setter
    def major(self, value: Optional[_builtins.int]):
        pulumi.set(self, "major", value)

    @_builtins.property
    @pulumi.getter
    def minor(self) -> Optional[_builtins.int]:
        """
        Minor version of the model
        """
        return pulumi.get(self, "minor")

    @minor.setter
    def minor(self, value: Optional[_builtins.int]):
        pulumi.set(self, "minor", value)

    @_builtins.property
    @pulumi.getter
    def patch(self) -> Optional[_builtins.int]:
        """
        Patch version of the model
        """
        return pulumi.get(self, "patch")

    @patch.setter
    def patch(self, value: Optional[_builtins.int]):
        pulumi.set(self, "patch", value)


if not MYPY:
    class GetGenaiAgentVersionsFilterArgsDict(TypedDict):
        key: _builtins.str
        values: Sequence[_builtins.str]
        all: NotRequired[_builtins.bool]
        match_by: NotRequired[_builtins.str]
elif False:
    GetGenaiAgentVersionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentVersionsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetGenaiAgentVersionsSortArgsDict(TypedDict):
        key: _builtins.str
        direction: NotRequired[_builtins.str]
elif False:
    GetGenaiAgentVersionsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentVersionsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetGenaiAgentsFilterArgsDict(TypedDict):
        key: _builtins.str
        values: Sequence[_builtins.str]
        all: NotRequired[_builtins.bool]
        match_by: NotRequired[_builtins.str]
elif False:
    GetGenaiAgentsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetGenaiAgentsSortArgsDict(TypedDict):
        key: _builtins.str
        direction: NotRequired[_builtins.str]
elif False:
    GetGenaiAgentsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiAgentsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetGenaiKnowledgeBaseLastIndexingJobArgsDict(TypedDict):
        created_at: _builtins.str
        """
        Created At timestamp for the last indexing job
        """
        finished_at: _builtins.str
        """
        Timestamp when the last indexing job finished
        """
        knowledge_base_uuid: _builtins.str
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        started_at: _builtins.str
        """
        Timestamp when the last indexing job started
        """
        updated_at: _builtins.str
        """
        Timestamp when the last indexing job updated
        """
        completed_datasources: NotRequired[_builtins.int]
        """
        Number of completed datasources in the last indexing job
        """
        data_source_uuids: NotRequired[Sequence[_builtins.str]]
        """
        Datasource UUIDs for the last indexing job
        """
        phase: NotRequired[_builtins.str]
        """
        Phase of the last indexing job
        """
        tokens: NotRequired[_builtins.int]
        """
        Number of tokens processed in the last indexing job
        """
        total_datasources: NotRequired[_builtins.int]
        """
        Total number of datasources in the last indexing job
        """
        uuid: NotRequired[_builtins.str]
        """
        UUID  of the last indexing job
        """
elif False:
    GetGenaiKnowledgeBaseLastIndexingJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiKnowledgeBaseLastIndexingJobArgs:
    def __init__(__self__, *,
                 created_at: _builtins.str,
                 finished_at: _builtins.str,
                 knowledge_base_uuid: _builtins.str,
                 started_at: _builtins.str,
                 updated_at: _builtins.str,
                 completed_datasources: Optional[_builtins.int] = None,
                 data_source_uuids: Optional[Sequence[_builtins.str]] = None,
                 phase: Optional[_builtins.str] = None,
                 tokens: Optional[_builtins.int] = None,
                 total_datasources: Optional[_builtins.int] = None,
                 uuid: Optional[_builtins.str] = None):
        """
        :param _builtins.str created_at: Created At timestamp for the last indexing job
        :param _builtins.str finished_at: Timestamp when the last indexing job finished
        :param _builtins.str knowledge_base_uuid: UUID  of the Knowledge Base for the last indexing job
        :param _builtins.str started_at: Timestamp when the last indexing job started
        :param _builtins.str updated_at: Timestamp when the last indexing job updated
        :param _builtins.int completed_datasources: Number of completed datasources in the last indexing job
        :param Sequence[_builtins.str] data_source_uuids: Datasource UUIDs for the last indexing job
        :param _builtins.str phase: Phase of the last indexing job
        :param _builtins.int tokens: Number of tokens processed in the last indexing job
        :param _builtins.int total_datasources: Total number of datasources in the last indexing job
        :param _builtins.str uuid: UUID  of the last indexing job
        """
        pulumi.set(__self__, "created_at", created_at)
        pulumi.set(__self__, "finished_at", finished_at)
        pulumi.set(__self__, "knowledge_base_uuid", knowledge_base_uuid)
        pulumi.set(__self__, "started_at", started_at)
        pulumi.set(__self__, "updated_at", updated_at)
        if completed_datasources is not None:
            pulumi.set(__self__, "completed_datasources", completed_datasources)
        if data_source_uuids is not None:
            pulumi.set(__self__, "data_source_uuids", data_source_uuids)
        if phase is not None:
            pulumi.set(__self__, "phase", phase)
        if tokens is not None:
            pulumi.set(__self__, "tokens", tokens)
        if total_datasources is not None:
            pulumi.set(__self__, "total_datasources", total_datasources)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> _builtins.str:
        """
        Created At timestamp for the last indexing job
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: _builtins.str):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="finishedAt")
    def finished_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job finished
        """
        return pulumi.get(self, "finished_at")

    @finished_at.setter
    def finished_at(self, value: _builtins.str):
        pulumi.set(self, "finished_at", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseUuid")
    def knowledge_base_uuid(self) -> _builtins.str:
        """
        UUID  of the Knowledge Base for the last indexing job
        """
        return pulumi.get(self, "knowledge_base_uuid")

    @knowledge_base_uuid.setter
    def knowledge_base_uuid(self, value: _builtins.str):
        pulumi.set(self, "knowledge_base_uuid", value)

    @_builtins.property
    @pulumi.getter(name="startedAt")
    def started_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job started
        """
        return pulumi.get(self, "started_at")

    @started_at.setter
    def started_at(self, value: _builtins.str):
        pulumi.set(self, "started_at", value)

    @_builtins.property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> _builtins.str:
        """
        Timestamp when the last indexing job updated
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: _builtins.str):
        pulumi.set(self, "updated_at", value)

    @_builtins.property
    @pulumi.getter(name="completedDatasources")
    def completed_datasources(self) -> Optional[_builtins.int]:
        """
        Number of completed datasources in the last indexing job
        """
        return pulumi.get(self, "completed_datasources")

    @completed_datasources.setter
    def completed_datasources(self, value: Optional[_builtins.int]):
        pulumi.set(self, "completed_datasources", value)

    @_builtins.property
    @pulumi.getter(name="dataSourceUuids")
    def data_source_uuids(self) -> Optional[Sequence[_builtins.str]]:
        """
        Datasource UUIDs for the last indexing job
        """
        return pulumi.get(self, "data_source_uuids")

    @data_source_uuids.setter
    def data_source_uuids(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "data_source_uuids", value)

    @_builtins.property
    @pulumi.getter
    def phase(self) -> Optional[_builtins.str]:
        """
        Phase of the last indexing job
        """
        return pulumi.get(self, "phase")

    @phase.setter
    def phase(self, value: Optional[_builtins.str]):
        pulumi.set(self, "phase", value)

    @_builtins.property
    @pulumi.getter
    def tokens(self) -> Optional[_builtins.int]:
        """
        Number of tokens processed in the last indexing job
        """
        return pulumi.get(self, "tokens")

    @tokens.setter
    def tokens(self, value: Optional[_builtins.int]):
        pulumi.set(self, "tokens", value)

    @_builtins.property
    @pulumi.getter(name="totalDatasources")
    def total_datasources(self) -> Optional[_builtins.int]:
        """
        Total number of datasources in the last indexing job
        """
        return pulumi.get(self, "total_datasources")

    @total_datasources.setter
    def total_datasources(self, value: Optional[_builtins.int]):
        pulumi.set(self, "total_datasources", value)

    @_builtins.property
    @pulumi.getter
    def uuid(self) -> Optional[_builtins.str]:
        """
        UUID  of the last indexing job
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[_builtins.str]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class GetGenaiKnowledgeBasesFilterArgsDict(TypedDict):
        key: _builtins.str
        values: Sequence[_builtins.str]
        all: NotRequired[_builtins.bool]
        match_by: NotRequired[_builtins.str]
elif False:
    GetGenaiKnowledgeBasesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiKnowledgeBasesFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetGenaiKnowledgeBasesSortArgsDict(TypedDict):
        key: _builtins.str
        direction: NotRequired[_builtins.str]
elif False:
    GetGenaiKnowledgeBasesSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiKnowledgeBasesSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetGenaiOpenaiApiKeysFilterArgsDict(TypedDict):
        key: _builtins.str
        values: Sequence[_builtins.str]
        all: NotRequired[_builtins.bool]
        match_by: NotRequired[_builtins.str]
elif False:
    GetGenaiOpenaiApiKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiOpenaiApiKeysFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetGenaiOpenaiApiKeysSortArgsDict(TypedDict):
        key: _builtins.str
        direction: NotRequired[_builtins.str]
elif False:
    GetGenaiOpenaiApiKeysSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetGenaiOpenaiApiKeysSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetImagesFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the images by this key. This may be one of `distribution`, `error_message`,
        `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
        `tags`, or `type`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values to match against the `key` field. Only retrieves images
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetImagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagesFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the images by this key. This may be one of `distribution`, `error_message`,
               `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
               `tags`, or `type`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves images
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the images by this key. This may be one of `distribution`, `error_message`,
        `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
        `tags`, or `type`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves images
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetImagesSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
        `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetImagesSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagesSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
               `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
        `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetKubernetesClusterClusterAutoscalerConfigurationArgsDict(TypedDict):
        expanders: NotRequired[Sequence[_builtins.str]]
        scale_down_unneeded_time: NotRequired[_builtins.str]
        scale_down_utilization_threshold: NotRequired[_builtins.float]
elif False:
    GetKubernetesClusterClusterAutoscalerConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubernetesClusterClusterAutoscalerConfigurationArgs:
    def __init__(__self__, *,
                 expanders: Optional[Sequence[_builtins.str]] = None,
                 scale_down_unneeded_time: Optional[_builtins.str] = None,
                 scale_down_utilization_threshold: Optional[_builtins.float] = None):
        if expanders is not None:
            pulumi.set(__self__, "expanders", expanders)
        if scale_down_unneeded_time is not None:
            pulumi.set(__self__, "scale_down_unneeded_time", scale_down_unneeded_time)
        if scale_down_utilization_threshold is not None:
            pulumi.set(__self__, "scale_down_utilization_threshold", scale_down_utilization_threshold)

    @_builtins.property
    @pulumi.getter
    def expanders(self) -> Optional[Sequence[_builtins.str]]:
        return pulumi.get(self, "expanders")

    @expanders.setter
    def expanders(self, value: Optional[Sequence[_builtins.str]]):
        pulumi.set(self, "expanders", value)

    @_builtins.property
    @pulumi.getter(name="scaleDownUnneededTime")
    def scale_down_unneeded_time(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "scale_down_unneeded_time")

    @scale_down_unneeded_time.setter
    def scale_down_unneeded_time(self, value: Optional[_builtins.str]):
        pulumi.set(self, "scale_down_unneeded_time", value)

    @_builtins.property
    @pulumi.getter(name="scaleDownUtilizationThreshold")
    def scale_down_utilization_threshold(self) -> Optional[_builtins.float]:
        return pulumi.get(self, "scale_down_utilization_threshold")

    @scale_down_utilization_threshold.setter
    def scale_down_utilization_threshold(self, value: Optional[_builtins.float]):
        pulumi.set(self, "scale_down_utilization_threshold", value)


if not MYPY:
    class GetKubernetesClusterRoutingAgentArgsDict(TypedDict):
        enabled: _builtins.bool
elif False:
    GetKubernetesClusterRoutingAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetKubernetesClusterRoutingAgentArgs:
    def __init__(__self__, *,
                 enabled: _builtins.bool):
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: _builtins.bool):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class GetPartnerAttachmentBgpArgsDict(TypedDict):
        local_router_ip: NotRequired[_builtins.str]
        peer_router_asn: NotRequired[_builtins.int]
        peer_router_ip: NotRequired[_builtins.str]
elif False:
    GetPartnerAttachmentBgpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetPartnerAttachmentBgpArgs:
    def __init__(__self__, *,
                 local_router_ip: Optional[_builtins.str] = None,
                 peer_router_asn: Optional[_builtins.int] = None,
                 peer_router_ip: Optional[_builtins.str] = None):
        if local_router_ip is not None:
            pulumi.set(__self__, "local_router_ip", local_router_ip)
        if peer_router_asn is not None:
            pulumi.set(__self__, "peer_router_asn", peer_router_asn)
        if peer_router_ip is not None:
            pulumi.set(__self__, "peer_router_ip", peer_router_ip)

    @_builtins.property
    @pulumi.getter(name="localRouterIp")
    def local_router_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "local_router_ip")

    @local_router_ip.setter
    def local_router_ip(self, value: Optional[_builtins.str]):
        pulumi.set(self, "local_router_ip", value)

    @_builtins.property
    @pulumi.getter(name="peerRouterAsn")
    def peer_router_asn(self) -> Optional[_builtins.int]:
        return pulumi.get(self, "peer_router_asn")

    @peer_router_asn.setter
    def peer_router_asn(self, value: Optional[_builtins.int]):
        pulumi.set(self, "peer_router_asn", value)

    @_builtins.property
    @pulumi.getter(name="peerRouterIp")
    def peer_router_ip(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "peer_router_ip")

    @peer_router_ip.setter
    def peer_router_ip(self, value: Optional[_builtins.str]):
        pulumi.set(self, "peer_router_ip", value)


if not MYPY:
    class GetProjectsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the projects by this key. This may be one of `name`,
        `purpose`, `description`, `environment`, or `is_default`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values to match against the `key` field. Only retrieves projects
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetProjectsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the projects by this key. This may be one of `name`,
               `purpose`, `description`, `environment`, or `is_default`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves projects
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the projects by this key. This may be one of `name`,
        `purpose`, `description`, `environment`, or `is_default`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves projects
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetProjectsSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the projects by this key. This may be one of `name`,
        `purpose`, `description`, or `environment`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetProjectsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the projects by this key. This may be one of `name`,
               `purpose`, `description`, or `environment`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the projects by this key. This may be one of `name`,
        `purpose`, `description`, or `environment`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetRecordsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values to match against the `key` field. Only retrieves DNS records
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRecordsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
               `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves DNS records
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves DNS records
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetRecordsSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetRecordsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRecordsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
               `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetRegionsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the regions by this key. This may be one of `slug`,
        `name`, `available`, `features`, or `sizes`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values to match against the `key` field. Only retrieves regions
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetRegionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegionsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the regions by this key. This may be one of `slug`,
               `name`, `available`, `features`, or `sizes`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves regions
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the regions by this key. This may be one of `slug`,
        `name`, `available`, `features`, or `sizes`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves regions
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetRegionsSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the regions by this key. This may be one of `slug`,
        `name`, or `available`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetRegionsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegionsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the regions by this key. This may be one of `slug`,
               `name`, or `available`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the regions by this key. This may be one of `slug`,
        `name`, or `available`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetSizesFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the sizes by this key. This may be one of `slug`,
        `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
        `price_hourly`, or `available`.
        """
        values: Sequence[_builtins.str]
        """
        Only retrieves sizes which keys has value that matches
        one of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetSizesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSizesFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the sizes by this key. This may be one of `slug`,
               `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
               `price_hourly`, or `available`.
        :param Sequence[_builtins.str] values: Only retrieves sizes which keys has value that matches
               one of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the sizes by this key. This may be one of `slug`,
        `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
        `price_hourly`, or `available`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Only retrieves sizes which keys has value that matches
        one of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetSizesSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the sizes by this key. This may be one of `slug`,
        `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetSizesSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSizesSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the sizes by this key. This may be one of `slug`,
               `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the sizes by this key. This may be one of `slug`,
        `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetSpacesBucketsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values to match against the `key` field. Only retrieves Spaces buckets
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetSpacesBucketsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSpacesBucketsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        :param Sequence[_builtins.str] values: A list of values to match against the `key` field. Only retrieves Spaces buckets
               where the `key` field takes on one or more of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the `key` field. Only retrieves Spaces buckets
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetSpacesBucketsSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetSpacesBucketsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSpacesBucketsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetSshKeysFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        values: Sequence[_builtins.str]
        """
        A list of values to match against the key field. Only retrieves SSH keys where the key field matches one or more of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        match_by: NotRequired[_builtins.str]
elif False:
    GetSshKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSshKeysFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        :param Sequence[_builtins.str] values: A list of values to match against the key field. Only retrieves SSH keys where the key field matches one or more of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        A list of values to match against the key field. Only retrieves SSH keys where the key field matches one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetSshKeysSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetSshKeysSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSshKeysSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetTagsFilterArgsDict(TypedDict):
        key: _builtins.str
        """
        Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        values: Sequence[_builtins.str]
        """
        Only retrieves tags which keys has value that matches
        one of the values provided here.
        """
        all: NotRequired[_builtins.bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[_builtins.str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetTagsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 values: Sequence[_builtins.str],
                 all: Optional[_builtins.bool] = None,
                 match_by: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        :param Sequence[_builtins.str] values: Only retrieves tags which keys has value that matches
               one of the values provided here.
        :param _builtins.bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param _builtins.str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def values(self) -> Sequence[_builtins.str]:
        """
        Only retrieves tags which keys has value that matches
        one of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[_builtins.str]):
        pulumi.set(self, "values", value)

    @_builtins.property
    @pulumi.getter
    def all(self) -> Optional[_builtins.bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[_builtins.bool]):
        pulumi.set(self, "all", value)

    @_builtins.property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[_builtins.str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[_builtins.str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetTagsSortArgsDict(TypedDict):
        key: _builtins.str
        """
        Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        direction: NotRequired[_builtins.str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetTagsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsSortArgs:
    def __init__(__self__, *,
                 key: _builtins.str,
                 direction: Optional[_builtins.str] = None):
        """
        :param _builtins.str key: Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        :param _builtins.str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @_builtins.property
    @pulumi.getter
    def key(self) -> _builtins.str:
        """
        Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: _builtins.str):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def direction(self) -> Optional[_builtins.str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[_builtins.str]):
        pulumi.set(self, "direction", value)


