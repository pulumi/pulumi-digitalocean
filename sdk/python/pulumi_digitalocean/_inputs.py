# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import warnings
import pulumi
import pulumi.runtime
from typing import Any, Dict, List, Mapping, Optional, Tuple, Union
from . import _utilities, _tables

__all__ = [
    'DatabaseClusterMaintenanceWindowArgs',
    'DatabaseFirewallRuleArgs',
    'FirewallInboundRuleArgs',
    'FirewallOutboundRuleArgs',
    'FirewallPendingChangeArgs',
    'KubernetesClusterKubeConfigArgs',
    'KubernetesClusterNodePoolArgs',
    'KubernetesClusterNodePoolNodeArgs',
    'KubernetesNodePoolNodeArgs',
    'LoadBalancerForwardingRuleArgs',
    'LoadBalancerHealthcheckArgs',
    'LoadBalancerStickySessionsArgs',
    'SpacesBucketCorsRuleArgs',
    'SpacesBucketLifecycleRuleArgs',
    'SpacesBucketLifecycleRuleExpirationArgs',
    'SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs',
    'SpacesBucketVersioningArgs',
    'GetDropletsFilterArgs',
    'GetDropletsSortArgs',
    'GetImagesFilterArgs',
    'GetImagesSortArgs',
    'GetProjectsFilterArgs',
    'GetProjectsSortArgs',
    'GetRegionsFilterArgs',
    'GetRegionsSortArgs',
    'GetSizesFilterArgs',
    'GetSizesSortArgs',
    'GetSpacesBucketsFilterArgs',
    'GetSpacesBucketsSortArgs',
    'GetTagsFilterArgs',
    'GetTagsSortArgs',
]

@pulumi.input_type
class DatabaseClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[str],
                 hour: pulumi.Input[str]):
        """
        :param pulumi.Input[str] day: The day of the week on which to apply maintenance updates.
        :param pulumi.Input[str] hour: The hour in UTC at which maintenance updates will be applied in 24 hour format.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def day(self) -> pulumi.Input[str]:
        """
        The day of the week on which to apply maintenance updates.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[str]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> pulumi.Input[str]:
        """
        The hour in UTC at which maintenance updates will be applied in 24 hour format.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: pulumi.Input[str]):
        pulumi.set(self, "hour", value)


@pulumi.input_type
class DatabaseFirewallRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str],
                 created_at: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, or `tag`.
        :param pulumi.Input[str] value: The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        :param pulumi.Input[str] created_at: The date and time when the firewall rule was created.
        :param pulumi.Input[str] uuid: A unique identifier for the firewall rule.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, or `tag`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the firewall rule was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        A unique identifier for the firewall rule.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


@pulumi.input_type
class FirewallInboundRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 port_range: Optional[pulumi.Input[str]] = None,
                 source_addresses: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 source_droplet_ids: Optional[pulumi.Input[List[pulumi.Input[float]]]] = None,
                 source_load_balancer_uids: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 source_tags: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param pulumi.Input[str] port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        :param pulumi.Input[List[pulumi.Input[str]]] source_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
               inbound traffic will be accepted.
        :param pulumi.Input[List[pulumi.Input[float]]] source_droplet_ids: An array containing the IDs of
               the Droplets from which the inbound traffic will be accepted.
        :param pulumi.Input[List[pulumi.Input[str]]] source_load_balancer_uids: An array containing the IDs
               of the Load Balancers from which the inbound traffic will be accepted.
        :param pulumi.Input[List[pulumi.Input[str]]] source_tags: An array containing the names of Tags
               corresponding to groups of Droplets from which the inbound traffic
               will be accepted.
        """
        pulumi.set(__self__, "protocol", protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_droplet_ids is not None:
            pulumi.set(__self__, "source_droplet_ids", source_droplet_ids)
        if source_load_balancer_uids is not None:
            pulumi.set(__self__, "source_load_balancer_uids", source_load_balancer_uids)
        if source_tags is not None:
            pulumi.set(__self__, "source_tags", source_tags)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "source_addresses", value)

    @property
    @pulumi.getter(name="sourceDropletIds")
    def source_droplet_ids(self) -> Optional[pulumi.Input[List[pulumi.Input[float]]]]:
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_droplet_ids")

    @source_droplet_ids.setter
    def source_droplet_ids(self, value: Optional[pulumi.Input[List[pulumi.Input[float]]]]):
        pulumi.set(self, "source_droplet_ids", value)

    @property
    @pulumi.getter(name="sourceLoadBalancerUids")
    def source_load_balancer_uids(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_load_balancer_uids")

    @source_load_balancer_uids.setter
    def source_load_balancer_uids(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "source_load_balancer_uids", value)

    @property
    @pulumi.getter(name="sourceTags")
    def source_tags(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets from which the inbound traffic
        will be accepted.
        """
        return pulumi.get(self, "source_tags")

    @source_tags.setter
    def source_tags(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "source_tags", value)


@pulumi.input_type
class FirewallOutboundRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 destination_addresses: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 destination_droplet_ids: Optional[pulumi.Input[List[pulumi.Input[float]]]] = None,
                 destination_load_balancer_uids: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 destination_tags: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 port_range: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param pulumi.Input[List[pulumi.Input[str]]] destination_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
               outbound traffic will be allowed.
        :param pulumi.Input[List[pulumi.Input[float]]] destination_droplet_ids: An array containing the IDs of
               the Droplets to which the outbound traffic will be allowed.
        :param pulumi.Input[List[pulumi.Input[str]]] destination_load_balancer_uids: An array containing the IDs
               of the Load Balancers to which the outbound traffic will be allowed.
        :param pulumi.Input[List[pulumi.Input[str]]] destination_tags: An array containing the names of Tags
               corresponding to groups of Droplets to which the outbound traffic will
               be allowed.
               traffic.
        :param pulumi.Input[str] port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        """
        pulumi.set(__self__, "protocol", protocol)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_droplet_ids is not None:
            pulumi.set(__self__, "destination_droplet_ids", destination_droplet_ids)
        if destination_load_balancer_uids is not None:
            pulumi.set(__self__, "destination_load_balancer_uids", destination_load_balancer_uids)
        if destination_tags is not None:
            pulumi.set(__self__, "destination_tags", destination_tags)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_addresses", value)

    @property
    @pulumi.getter(name="destinationDropletIds")
    def destination_droplet_ids(self) -> Optional[pulumi.Input[List[pulumi.Input[float]]]]:
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_droplet_ids")

    @destination_droplet_ids.setter
    def destination_droplet_ids(self, value: Optional[pulumi.Input[List[pulumi.Input[float]]]]):
        pulumi.set(self, "destination_droplet_ids", value)

    @property
    @pulumi.getter(name="destinationLoadBalancerUids")
    def destination_load_balancer_uids(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_load_balancer_uids")

    @destination_load_balancer_uids.setter
    def destination_load_balancer_uids(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_load_balancer_uids", value)

    @property
    @pulumi.getter(name="destinationTags")
    def destination_tags(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        traffic.
        """
        return pulumi.get(self, "destination_tags")

    @destination_tags.setter
    def destination_tags(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_tags", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)


@pulumi.input_type
class FirewallPendingChangeArgs:
    def __init__(__self__, *,
                 droplet_id: Optional[pulumi.Input[float]] = None,
                 removing: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: A status string indicating the current state of the Firewall.
               This can be "waiting", "succeeded", or "failed".
        """
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if removing is not None:
            pulumi.set(__self__, "removing", removing)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[float]]:
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "droplet_id", value)

    @property
    @pulumi.getter
    def removing(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "removing")

    @removing.setter
    def removing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "removing", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        A status string indicating the current state of the Firewall.
        This can be "waiting", "succeeded", or "failed".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


@pulumi.input_type
class KubernetesClusterKubeConfigArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None,
                 expires_at: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 raw_config: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate: The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param pulumi.Input[str] client_key: The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param pulumi.Input[str] cluster_ca_certificate: The base64 encoded public certificate for the cluster's certificate authority.
        :param pulumi.Input[str] expires_at: The date and time when the credentials will expire and need to be regenerated.
        :param pulumi.Input[str] host: The URL of the API server on the Kubernetes master node.
        :param pulumi.Input[str] raw_config: The full contents of the Kubernetes cluster's kubeconfig file.
        :param pulumi.Input[str] token: The DigitalOcean API access token used by clients to access the cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if raw_config is not None:
            pulumi.set(__self__, "raw_config", raw_config)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded public certificate for the cluster's certificate authority.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the credentials will expire and need to be regenerated.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the API server on the Kubernetes master node.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="rawConfig")
    def raw_config(self) -> Optional[pulumi.Input[str]]:
        """
        The full contents of the Kubernetes cluster's kubeconfig file.
        """
        return pulumi.get(self, "raw_config")

    @raw_config.setter
    def raw_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_config", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The DigitalOcean API access token used by clients to access the cluster.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)


@pulumi.input_type
class KubernetesClusterNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 size: pulumi.Input[str],
                 actual_node_count: Optional[pulumi.Input[float]] = None,
                 auto_scale: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 max_nodes: Optional[pulumi.Input[float]] = None,
                 min_nodes: Optional[pulumi.Input[float]] = None,
                 node_count: Optional[pulumi.Input[float]] = None,
                 nodes: Optional[pulumi.Input[List[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]] = None,
                 tags: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: A name for the node pool.
        :param pulumi.Input[str] size: The slug identifier for the type of Droplet to be used as workers in the node pool.
        :param pulumi.Input[float] actual_node_count: A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        :param pulumi.Input[bool] auto_scale: Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        :param pulumi.Input[str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        :param pulumi.Input[float] max_nodes: If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        :param pulumi.Input[float] min_nodes: If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        :param pulumi.Input[float] node_count: The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        :param pulumi.Input[List[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]] nodes: A list of nodes in the pool. Each node exports the following attributes:
        :param pulumi.Input[List[pulumi.Input[str]]] tags: A list of tag names to be applied to the Kubernetes cluster.
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if actual_node_count is not None:
            pulumi.set(__self__, "actual_node_count", actual_node_count)
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_nodes is not None:
            pulumi.set(__self__, "max_nodes", max_nodes)
        if min_nodes is not None:
            pulumi.set(__self__, "min_nodes", min_nodes)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        The slug identifier for the type of Droplet to be used as workers in the node pool.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="actualNodeCount")
    def actual_node_count(self) -> Optional[pulumi.Input[float]]:
        """
        A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        """
        return pulumi.get(self, "actual_node_count")

    @actual_node_count.setter
    def actual_node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "actual_node_count", value)

    @property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        """
        return pulumi.get(self, "auto_scale")

    @auto_scale.setter
    def auto_scale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_scale", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[pulumi.Input[float]]:
        """
        If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        """
        return pulumi.get(self, "max_nodes")

    @max_nodes.setter
    def max_nodes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_nodes", value)

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[pulumi.Input[float]]:
        """
        If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        """
        return pulumi.get(self, "min_nodes")

    @min_nodes.setter
    def min_nodes(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_nodes", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[float]]:
        """
        The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[List[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]]:
        """
        A list of nodes in the pool. Each node exports the following attributes:
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[List[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        A list of tag names to be applied to the Kubernetes cluster.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class KubernetesClusterNodePoolNodeArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 droplet_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] created_at: The date and time when the node was created.
        :param pulumi.Input[str] droplet_id: The id of the node's droplet
        :param pulumi.Input[str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[str] name: A name for the node pool.
        :param pulumi.Input[str] status: A string indicating the current status of the individual node.
        :param pulumi.Input[str] updated_at: The date and time when the node was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the node's droplet
        """
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "droplet_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


@pulumi.input_type
class KubernetesNodePoolNodeArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 droplet_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] created_at: The date and time when the node was created.
        :param pulumi.Input[str] droplet_id: The id of the node's droplet
        :param pulumi.Input[str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[str] name: A name for the node pool.
        :param pulumi.Input[str] status: A string indicating the current status of the individual node.
        :param pulumi.Input[str] updated_at: The date and time when the node was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the node's droplet
        """
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "droplet_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


@pulumi.input_type
class LoadBalancerForwardingRuleArgs:
    def __init__(__self__, *,
                 entry_port: pulumi.Input[float],
                 entry_protocol: pulumi.Input[str],
                 target_port: pulumi.Input[float],
                 target_protocol: pulumi.Input[str],
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 tls_passthrough: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[float] entry_port: An integer representing the port on which the Load Balancer instance will listen.
        :param pulumi.Input[str] entry_protocol: The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2` or `tcp`.
        :param pulumi.Input[float] target_port: An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        :param pulumi.Input[str] target_protocol: The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2` or `tcp`.
        :param pulumi.Input[str] certificate_id: The ID of the TLS certificate to be used for SSL termination.
        :param pulumi.Input[bool] tls_passthrough: A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
        pulumi.set(__self__, "entry_port", entry_port)
        pulumi.set(__self__, "entry_protocol", entry_protocol)
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if tls_passthrough is not None:
            pulumi.set(__self__, "tls_passthrough", tls_passthrough)

    @property
    @pulumi.getter(name="entryPort")
    def entry_port(self) -> pulumi.Input[float]:
        """
        An integer representing the port on which the Load Balancer instance will listen.
        """
        return pulumi.get(self, "entry_port")

    @entry_port.setter
    def entry_port(self, value: pulumi.Input[float]):
        pulumi.set(self, "entry_port", value)

    @property
    @pulumi.getter(name="entryProtocol")
    def entry_protocol(self) -> pulumi.Input[str]:
        """
        The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2` or `tcp`.
        """
        return pulumi.get(self, "entry_protocol")

    @entry_protocol.setter
    def entry_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[float]:
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[float]):
        pulumi.set(self, "target_port", value)

    @property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> pulumi.Input[str]:
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2` or `tcp`.
        """
        return pulumi.get(self, "target_protocol")

    @target_protocol.setter
    def target_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_protocol", value)

    @property
    @pulumi.getter(name="certificateId")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the TLS certificate to be used for SSL termination.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="tlsPassthrough")
    def tls_passthrough(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
        return pulumi.get(self, "tls_passthrough")

    @tls_passthrough.setter
    def tls_passthrough(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_passthrough", value)


@pulumi.input_type
class LoadBalancerHealthcheckArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[float],
                 protocol: pulumi.Input[str],
                 check_interval_seconds: Optional[pulumi.Input[float]] = None,
                 healthy_threshold: Optional[pulumi.Input[float]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 response_timeout_seconds: Optional[pulumi.Input[float]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] port: An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        :param pulumi.Input[str] protocol: The protocol used for health checks sent to the backend Droplets. The possible values are `http` or `tcp`.
        :param pulumi.Input[float] check_interval_seconds: The number of seconds between between two consecutive health checks. If not specified, the default value is `10`.
        :param pulumi.Input[float] healthy_threshold: The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        :param pulumi.Input[str] path: The path on the backend Droplets to which the Load Balancer instance will send a request.
        :param pulumi.Input[float] response_timeout_seconds: The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        :param pulumi.Input[float] unhealthy_threshold: The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if check_interval_seconds is not None:
            pulumi.set(__self__, "check_interval_seconds", check_interval_seconds)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if response_timeout_seconds is not None:
            pulumi.set(__self__, "response_timeout_seconds", response_timeout_seconds)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[float]:
        """
        An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[float]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol used for health checks sent to the backend Droplets. The possible values are `http` or `tcp`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="checkIntervalSeconds")
    def check_interval_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        The number of seconds between between two consecutive health checks. If not specified, the default value is `10`.
        """
        return pulumi.get(self, "check_interval_seconds")

    @check_interval_seconds.setter
    def check_interval_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "check_interval_seconds", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path on the backend Droplets to which the Load Balancer instance will send a request.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="responseTimeoutSeconds")
    def response_timeout_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        """
        return pulumi.get(self, "response_timeout_seconds")

    @response_timeout_seconds.setter
    def response_timeout_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "response_timeout_seconds", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[float]]:
        """
        The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "unhealthy_threshold", value)


@pulumi.input_type
class LoadBalancerStickySessionsArgs:
    def __init__(__self__, *,
                 cookie_name: Optional[pulumi.Input[str]] = None,
                 cookie_ttl_seconds: Optional[pulumi.Input[float]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cookie_name: The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        :param pulumi.Input[float] cookie_ttl_seconds: The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        :param pulumi.Input[str] type: An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if cookie_ttl_seconds is not None:
            pulumi.set(__self__, "cookie_ttl_seconds", cookie_ttl_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="cookieTtlSeconds")
    def cookie_ttl_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_ttl_seconds")

    @cookie_ttl_seconds.setter
    def cookie_ttl_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cookie_ttl_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class SpacesBucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[List[pulumi.Input[str]]],
                 allowed_origins: pulumi.Input[List[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[List[pulumi.Input[str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[List[pulumi.Input[str]]] allowed_methods: A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        :param pulumi.Input[List[pulumi.Input[str]]] allowed_origins: A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        :param pulumi.Input[List[pulumi.Input[str]]] allowed_headers: A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        :param pulumi.Input[float] max_age_seconds: The time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[List[pulumi.Input[str]]]:
        """
        A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[List[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[List[pulumi.Input[str]]]]:
        """
        A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[List[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[float]]:
        """
        The time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "max_age_seconds", value)


@pulumi.input_type
class SpacesBucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 abort_incomplete_multipart_upload_days: Optional[pulumi.Input[float]] = None,
                 expiration: Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies lifecycle rule status.
        :param pulumi.Input[float] abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart
               upload when the multipart upload must be completed or else Spaces will abort the upload.
        :param pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs'] expiration: Specifies a time period after which applicable objects expire (documented below).
        :param pulumi.Input[str] id: Unique identifier for the rule.
        :param pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs'] noncurrent_version_expiration: Specifies when non-current object versions expire (documented below).
        :param pulumi.Input[str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the number of days after initiating a multipart
        upload when the multipart upload must be completed or else Spaces will abort the upload.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @abort_incomplete_multipart_upload_days.setter
    def abort_incomplete_multipart_upload_days(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "abort_incomplete_multipart_upload_days", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']]:
        """
        Specifies a time period after which applicable objects expire (documented below).
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']]:
        """
        Specifies when non-current object versions expire (documented below).
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


@pulumi.input_type
class SpacesBucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[str]] = None,
                 days: Optional[pulumi.Input[float]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] date: Specifies the date/time after which you want applicable objects to expire. The argument uses
               RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        :param pulumi.Input[float] days: Specifies the number of days after object creation when the applicable objects will expire.
        :param pulumi.Input[bool] expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended
               bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the date/time after which you want applicable objects to expire. The argument uses
        RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the number of days after object creation when the applicable objects will expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[bool]]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended
        bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


@pulumi.input_type
class SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] days: Specifies the number of days after which an object's non-current versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[float]]:
        """
        Specifies the number of days after which an object's non-current versions expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "days", value)


@pulumi.input_type
class SpacesBucketVersioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
               state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
        state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class GetDropletsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: List[str]):
        """
        :param str key: Filter the Droplets by this key. This may be one of '`backups`, `created_at`, `disk`, `id`,
               `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
               `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
               `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`'.
        :param List[str] values: A list of values to match against the `key` field. Only retrieves Droplets
               where the `key` field takes on one or more of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the Droplets by this key. This may be one of '`backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`'.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        A list of values to match against the `key` field. Only retrieves Droplets
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: List[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetDropletsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
               `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
               `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
               `status`, `urn`, `vcpus`, or `vpc_uuid`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `urn`, `vcpus`, or `vpc_uuid`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


@pulumi.input_type
class GetImagesFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: List[str]):
        """
        :param str key: Filter the images by this key. This may be one of `distribution`, `error_message`,
               `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
               `tags`, or `type`.
        :param List[str] values: A list of values to match against the `key` field. Only retrieves images
               where the `key` field takes on one or more of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the images by this key. This may be one of `distribution`, `error_message`,
        `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
        `tags`, or `type`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        A list of values to match against the `key` field. Only retrieves images
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: List[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetImagesSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
               `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
        `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


@pulumi.input_type
class GetProjectsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: List[str]):
        """
        :param str key: Filter the projects by this key. This may be one of `name`,
               `purpose`, `description`, `environment`, or `is_default`.
        :param List[str] values: A list of values to match against the `key` field. Only retrieves projects
               where the `key` field takes on one or more of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the projects by this key. This may be one of `name`,
        `purpose`, `description`, `environment`, or `is_default`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        A list of values to match against the `key` field. Only retrieves projects
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: List[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetProjectsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the projects by this key. This may be one of `name`,
               `purpose`, `description`, or `environment`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the projects by this key. This may be one of `name`,
        `purpose`, `description`, or `environment`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


@pulumi.input_type
class GetRegionsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: List[str]):
        """
        :param str key: Filter the regions by this key. This may be one of `slug`,
               `name`, `available`, `features`, or `sizes`.
        :param List[str] values: A list of values to match against the `key` field. Only retrieves regions
               where the `key` field takes on one or more of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the regions by this key. This may be one of `slug`,
        `name`, `available`, `features`, or `sizes`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        A list of values to match against the `key` field. Only retrieves regions
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: List[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetRegionsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the regions by this key. This may be one of `slug`,
               `name`, or `available`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the regions by this key. This may be one of `slug`,
        `name`, or `available`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


@pulumi.input_type
class GetSizesFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: List[str]):
        """
        :param str key: Filter the sizes by this key. This may be one of `slug`,
               `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
               `price_hourly`, or `available`.
        :param List[str] values: Only retrieves images which keys has value that matches
               one of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the sizes by this key. This may be one of `slug`,
        `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
        `price_hourly`, or `available`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Only retrieves images which keys has value that matches
        one of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: List[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetSizesSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the sizes by this key. This may be one of `slug`,
               `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the sizes by this key. This may be one of `slug`,
        `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


@pulumi.input_type
class GetSpacesBucketsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: List[str]):
        """
        :param str key: Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        :param List[str] values: A list of values to match against the `key` field. Only retrieves images
               where the `key` field takes on one or more of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        A list of values to match against the `key` field. Only retrieves images
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: List[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetSpacesBucketsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


@pulumi.input_type
class GetTagsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: List[str]):
        """
        :param str key: Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        :param List[str] values: Only retrieves tags which keys has value that matches
               one of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> List[str]:
        """
        Only retrieves tags which keys has value that matches
        one of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: List[str]):
        pulumi.set(self, "values", value)


@pulumi.input_type
class GetTagsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


