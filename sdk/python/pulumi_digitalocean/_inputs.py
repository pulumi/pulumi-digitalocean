# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from . import _utilities
from ._enums import *

__all__ = [
    'AppDedicatedIpArgs',
    'AppDedicatedIpArgsDict',
    'AppSpecArgs',
    'AppSpecArgsDict',
    'AppSpecAlertArgs',
    'AppSpecAlertArgsDict',
    'AppSpecDatabaseArgs',
    'AppSpecDatabaseArgsDict',
    'AppSpecDomainNameArgs',
    'AppSpecDomainNameArgsDict',
    'AppSpecEgressArgs',
    'AppSpecEgressArgsDict',
    'AppSpecEnvArgs',
    'AppSpecEnvArgsDict',
    'AppSpecFunctionArgs',
    'AppSpecFunctionArgsDict',
    'AppSpecFunctionAlertArgs',
    'AppSpecFunctionAlertArgsDict',
    'AppSpecFunctionCorsArgs',
    'AppSpecFunctionCorsArgsDict',
    'AppSpecFunctionCorsAllowOriginsArgs',
    'AppSpecFunctionCorsAllowOriginsArgsDict',
    'AppSpecFunctionEnvArgs',
    'AppSpecFunctionEnvArgsDict',
    'AppSpecFunctionGitArgs',
    'AppSpecFunctionGitArgsDict',
    'AppSpecFunctionGithubArgs',
    'AppSpecFunctionGithubArgsDict',
    'AppSpecFunctionGitlabArgs',
    'AppSpecFunctionGitlabArgsDict',
    'AppSpecFunctionLogDestinationArgs',
    'AppSpecFunctionLogDestinationArgsDict',
    'AppSpecFunctionLogDestinationDatadogArgs',
    'AppSpecFunctionLogDestinationDatadogArgsDict',
    'AppSpecFunctionLogDestinationLogtailArgs',
    'AppSpecFunctionLogDestinationLogtailArgsDict',
    'AppSpecFunctionLogDestinationOpenSearchArgs',
    'AppSpecFunctionLogDestinationOpenSearchArgsDict',
    'AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs',
    'AppSpecFunctionLogDestinationOpenSearchBasicAuthArgsDict',
    'AppSpecFunctionLogDestinationPapertrailArgs',
    'AppSpecFunctionLogDestinationPapertrailArgsDict',
    'AppSpecFunctionRouteArgs',
    'AppSpecFunctionRouteArgsDict',
    'AppSpecIngressArgs',
    'AppSpecIngressArgsDict',
    'AppSpecIngressRuleArgs',
    'AppSpecIngressRuleArgsDict',
    'AppSpecIngressRuleComponentArgs',
    'AppSpecIngressRuleComponentArgsDict',
    'AppSpecIngressRuleCorsArgs',
    'AppSpecIngressRuleCorsArgsDict',
    'AppSpecIngressRuleCorsAllowOriginsArgs',
    'AppSpecIngressRuleCorsAllowOriginsArgsDict',
    'AppSpecIngressRuleMatchArgs',
    'AppSpecIngressRuleMatchArgsDict',
    'AppSpecIngressRuleMatchPathArgs',
    'AppSpecIngressRuleMatchPathArgsDict',
    'AppSpecIngressRuleRedirectArgs',
    'AppSpecIngressRuleRedirectArgsDict',
    'AppSpecJobArgs',
    'AppSpecJobArgsDict',
    'AppSpecJobAlertArgs',
    'AppSpecJobAlertArgsDict',
    'AppSpecJobEnvArgs',
    'AppSpecJobEnvArgsDict',
    'AppSpecJobGitArgs',
    'AppSpecJobGitArgsDict',
    'AppSpecJobGithubArgs',
    'AppSpecJobGithubArgsDict',
    'AppSpecJobGitlabArgs',
    'AppSpecJobGitlabArgsDict',
    'AppSpecJobImageArgs',
    'AppSpecJobImageArgsDict',
    'AppSpecJobImageDeployOnPushArgs',
    'AppSpecJobImageDeployOnPushArgsDict',
    'AppSpecJobLogDestinationArgs',
    'AppSpecJobLogDestinationArgsDict',
    'AppSpecJobLogDestinationDatadogArgs',
    'AppSpecJobLogDestinationDatadogArgsDict',
    'AppSpecJobLogDestinationLogtailArgs',
    'AppSpecJobLogDestinationLogtailArgsDict',
    'AppSpecJobLogDestinationOpenSearchArgs',
    'AppSpecJobLogDestinationOpenSearchArgsDict',
    'AppSpecJobLogDestinationOpenSearchBasicAuthArgs',
    'AppSpecJobLogDestinationOpenSearchBasicAuthArgsDict',
    'AppSpecJobLogDestinationPapertrailArgs',
    'AppSpecJobLogDestinationPapertrailArgsDict',
    'AppSpecServiceArgs',
    'AppSpecServiceArgsDict',
    'AppSpecServiceAlertArgs',
    'AppSpecServiceAlertArgsDict',
    'AppSpecServiceAutoscalingArgs',
    'AppSpecServiceAutoscalingArgsDict',
    'AppSpecServiceAutoscalingMetricsArgs',
    'AppSpecServiceAutoscalingMetricsArgsDict',
    'AppSpecServiceAutoscalingMetricsCpuArgs',
    'AppSpecServiceAutoscalingMetricsCpuArgsDict',
    'AppSpecServiceCorsArgs',
    'AppSpecServiceCorsArgsDict',
    'AppSpecServiceCorsAllowOriginsArgs',
    'AppSpecServiceCorsAllowOriginsArgsDict',
    'AppSpecServiceEnvArgs',
    'AppSpecServiceEnvArgsDict',
    'AppSpecServiceGitArgs',
    'AppSpecServiceGitArgsDict',
    'AppSpecServiceGithubArgs',
    'AppSpecServiceGithubArgsDict',
    'AppSpecServiceGitlabArgs',
    'AppSpecServiceGitlabArgsDict',
    'AppSpecServiceHealthCheckArgs',
    'AppSpecServiceHealthCheckArgsDict',
    'AppSpecServiceImageArgs',
    'AppSpecServiceImageArgsDict',
    'AppSpecServiceImageDeployOnPushArgs',
    'AppSpecServiceImageDeployOnPushArgsDict',
    'AppSpecServiceLogDestinationArgs',
    'AppSpecServiceLogDestinationArgsDict',
    'AppSpecServiceLogDestinationDatadogArgs',
    'AppSpecServiceLogDestinationDatadogArgsDict',
    'AppSpecServiceLogDestinationLogtailArgs',
    'AppSpecServiceLogDestinationLogtailArgsDict',
    'AppSpecServiceLogDestinationOpenSearchArgs',
    'AppSpecServiceLogDestinationOpenSearchArgsDict',
    'AppSpecServiceLogDestinationOpenSearchBasicAuthArgs',
    'AppSpecServiceLogDestinationOpenSearchBasicAuthArgsDict',
    'AppSpecServiceLogDestinationPapertrailArgs',
    'AppSpecServiceLogDestinationPapertrailArgsDict',
    'AppSpecServiceRouteArgs',
    'AppSpecServiceRouteArgsDict',
    'AppSpecStaticSiteArgs',
    'AppSpecStaticSiteArgsDict',
    'AppSpecStaticSiteCorsArgs',
    'AppSpecStaticSiteCorsArgsDict',
    'AppSpecStaticSiteCorsAllowOriginsArgs',
    'AppSpecStaticSiteCorsAllowOriginsArgsDict',
    'AppSpecStaticSiteEnvArgs',
    'AppSpecStaticSiteEnvArgsDict',
    'AppSpecStaticSiteGitArgs',
    'AppSpecStaticSiteGitArgsDict',
    'AppSpecStaticSiteGithubArgs',
    'AppSpecStaticSiteGithubArgsDict',
    'AppSpecStaticSiteGitlabArgs',
    'AppSpecStaticSiteGitlabArgsDict',
    'AppSpecStaticSiteRouteArgs',
    'AppSpecStaticSiteRouteArgsDict',
    'AppSpecWorkerArgs',
    'AppSpecWorkerArgsDict',
    'AppSpecWorkerAlertArgs',
    'AppSpecWorkerAlertArgsDict',
    'AppSpecWorkerEnvArgs',
    'AppSpecWorkerEnvArgsDict',
    'AppSpecWorkerGitArgs',
    'AppSpecWorkerGitArgsDict',
    'AppSpecWorkerGithubArgs',
    'AppSpecWorkerGithubArgsDict',
    'AppSpecWorkerGitlabArgs',
    'AppSpecWorkerGitlabArgsDict',
    'AppSpecWorkerImageArgs',
    'AppSpecWorkerImageArgsDict',
    'AppSpecWorkerImageDeployOnPushArgs',
    'AppSpecWorkerImageDeployOnPushArgsDict',
    'AppSpecWorkerLogDestinationArgs',
    'AppSpecWorkerLogDestinationArgsDict',
    'AppSpecWorkerLogDestinationDatadogArgs',
    'AppSpecWorkerLogDestinationDatadogArgsDict',
    'AppSpecWorkerLogDestinationLogtailArgs',
    'AppSpecWorkerLogDestinationLogtailArgsDict',
    'AppSpecWorkerLogDestinationOpenSearchArgs',
    'AppSpecWorkerLogDestinationOpenSearchArgsDict',
    'AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs',
    'AppSpecWorkerLogDestinationOpenSearchBasicAuthArgsDict',
    'AppSpecWorkerLogDestinationPapertrailArgs',
    'AppSpecWorkerLogDestinationPapertrailArgsDict',
    'DatabaseClusterBackupRestoreArgs',
    'DatabaseClusterBackupRestoreArgsDict',
    'DatabaseClusterMaintenanceWindowArgs',
    'DatabaseClusterMaintenanceWindowArgsDict',
    'DatabaseFirewallRuleArgs',
    'DatabaseFirewallRuleArgsDict',
    'DatabaseKafkaTopicConfigArgs',
    'DatabaseKafkaTopicConfigArgsDict',
    'DatabasePostgresqlConfigPgbouncerArgs',
    'DatabasePostgresqlConfigPgbouncerArgsDict',
    'DatabasePostgresqlConfigTimescaledbArgs',
    'DatabasePostgresqlConfigTimescaledbArgsDict',
    'DatabaseUserSettingArgs',
    'DatabaseUserSettingArgsDict',
    'DatabaseUserSettingAclArgs',
    'DatabaseUserSettingAclArgsDict',
    'DatabaseUserSettingOpensearchAclArgs',
    'DatabaseUserSettingOpensearchAclArgsDict',
    'DropletAutoscaleConfigArgs',
    'DropletAutoscaleConfigArgsDict',
    'DropletAutoscaleCurrentUtilizationArgs',
    'DropletAutoscaleCurrentUtilizationArgsDict',
    'DropletAutoscaleDropletTemplateArgs',
    'DropletAutoscaleDropletTemplateArgsDict',
    'DropletBackupPolicyArgs',
    'DropletBackupPolicyArgsDict',
    'FirewallInboundRuleArgs',
    'FirewallInboundRuleArgsDict',
    'FirewallOutboundRuleArgs',
    'FirewallOutboundRuleArgsDict',
    'FirewallPendingChangeArgs',
    'FirewallPendingChangeArgsDict',
    'KubernetesClusterKubeConfigArgs',
    'KubernetesClusterKubeConfigArgsDict',
    'KubernetesClusterMaintenancePolicyArgs',
    'KubernetesClusterMaintenancePolicyArgsDict',
    'KubernetesClusterNodePoolArgs',
    'KubernetesClusterNodePoolArgsDict',
    'KubernetesClusterNodePoolNodeArgs',
    'KubernetesClusterNodePoolNodeArgsDict',
    'KubernetesClusterNodePoolTaintArgs',
    'KubernetesClusterNodePoolTaintArgsDict',
    'KubernetesNodePoolNodeArgs',
    'KubernetesNodePoolNodeArgsDict',
    'KubernetesNodePoolTaintArgs',
    'KubernetesNodePoolTaintArgsDict',
    'LoadBalancerDomainArgs',
    'LoadBalancerDomainArgsDict',
    'LoadBalancerFirewallArgs',
    'LoadBalancerFirewallArgsDict',
    'LoadBalancerForwardingRuleArgs',
    'LoadBalancerForwardingRuleArgsDict',
    'LoadBalancerGlbSettingsArgs',
    'LoadBalancerGlbSettingsArgsDict',
    'LoadBalancerGlbSettingsCdnArgs',
    'LoadBalancerGlbSettingsCdnArgsDict',
    'LoadBalancerHealthcheckArgs',
    'LoadBalancerHealthcheckArgsDict',
    'LoadBalancerStickySessionsArgs',
    'LoadBalancerStickySessionsArgsDict',
    'MonitorAlertAlertsArgs',
    'MonitorAlertAlertsArgsDict',
    'MonitorAlertAlertsSlackArgs',
    'MonitorAlertAlertsSlackArgsDict',
    'SpacesBucketCorsConfigurationCorsRuleArgs',
    'SpacesBucketCorsConfigurationCorsRuleArgsDict',
    'SpacesBucketCorsRuleArgs',
    'SpacesBucketCorsRuleArgsDict',
    'SpacesBucketLifecycleRuleArgs',
    'SpacesBucketLifecycleRuleArgsDict',
    'SpacesBucketLifecycleRuleExpirationArgs',
    'SpacesBucketLifecycleRuleExpirationArgsDict',
    'SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs',
    'SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgsDict',
    'SpacesBucketVersioningArgs',
    'SpacesBucketVersioningArgsDict',
    'UptimeAlertNotificationArgs',
    'UptimeAlertNotificationArgsDict',
    'UptimeAlertNotificationSlackArgs',
    'UptimeAlertNotificationSlackArgsDict',
    'GetAppDedicatedIpArgs',
    'GetAppDedicatedIpArgsDict',
    'GetDomainsFilterArgs',
    'GetDomainsFilterArgsDict',
    'GetDomainsSortArgs',
    'GetDomainsSortArgsDict',
    'GetDropletsFilterArgs',
    'GetDropletsFilterArgsDict',
    'GetDropletsSortArgs',
    'GetDropletsSortArgsDict',
    'GetFirewallInboundRuleArgs',
    'GetFirewallInboundRuleArgsDict',
    'GetFirewallOutboundRuleArgs',
    'GetFirewallOutboundRuleArgsDict',
    'GetImagesFilterArgs',
    'GetImagesFilterArgsDict',
    'GetImagesSortArgs',
    'GetImagesSortArgsDict',
    'GetProjectsFilterArgs',
    'GetProjectsFilterArgsDict',
    'GetProjectsSortArgs',
    'GetProjectsSortArgsDict',
    'GetRecordsFilterArgs',
    'GetRecordsFilterArgsDict',
    'GetRecordsSortArgs',
    'GetRecordsSortArgsDict',
    'GetRegionsFilterArgs',
    'GetRegionsFilterArgsDict',
    'GetRegionsSortArgs',
    'GetRegionsSortArgsDict',
    'GetSizesFilterArgs',
    'GetSizesFilterArgsDict',
    'GetSizesSortArgs',
    'GetSizesSortArgsDict',
    'GetSpacesBucketsFilterArgs',
    'GetSpacesBucketsFilterArgsDict',
    'GetSpacesBucketsSortArgs',
    'GetSpacesBucketsSortArgsDict',
    'GetSshKeysFilterArgs',
    'GetSshKeysFilterArgsDict',
    'GetSshKeysSortArgs',
    'GetSshKeysSortArgsDict',
    'GetTagsFilterArgs',
    'GetTagsFilterArgsDict',
    'GetTagsSortArgs',
    'GetTagsSortArgsDict',
]

MYPY = False

if not MYPY:
    class AppDedicatedIpArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[str]]
        """
        The ID of the app.
        """
        ip: NotRequired[pulumi.Input[str]]
        """
        The IP address of the dedicated egress IP.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
        """
elif False:
    AppDedicatedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDedicatedIpArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] id: The ID of the app.
        :param pulumi.Input[str] ip: The IP address of the dedicated egress IP.
        :param pulumi.Input[str] status: The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the app.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        The IP address of the dedicated egress IP.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        The status of the dedicated egress IP: 'UNKNOWN', 'ASSIGNING', 'ASSIGNED', or 'REMOVED'
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class AppSpecArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        databases: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecDatabaseArgsDict']]]]
        domain_names: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgsDict']]]]
        """
        Describes a domain where the application will be made available.
        """
        domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        egresses: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgsDict']]]]
        """
        Specification for app egress configurations.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        features: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/reference/apps/list-buildpacks/)
        """
        functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionArgsDict']]]]
        ingress: NotRequired[pulumi.Input['AppSpecIngressArgsDict']]
        """
        Specification for component routing, rewrites, and redirects.
        """
        jobs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobArgsDict']]]]
        region: NotRequired[pulumi.Input[str]]
        """
        The slug for the DigitalOcean data center region hosting the app.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceArgsDict']]]]
        static_sites: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteArgsDict']]]]
        workers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerArgsDict']]]]
elif False:
    AppSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgs']]]] = None,
                 databases: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDatabaseArgs']]]] = None,
                 domain_names: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgs']]]] = None,
                 domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 egresses: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgs']]]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgs']]]] = None,
                 features: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 functions: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionArgs']]]] = None,
                 ingress: Optional[pulumi.Input['AppSpecIngressArgs']] = None,
                 jobs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobArgs']]]] = None,
                 region: Optional[pulumi.Input[str]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceArgs']]]] = None,
                 static_sites: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteArgs']]]] = None,
                 workers: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerArgs']]]] = None):
        """
        :param pulumi.Input[str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgs']]] domain_names: Describes a domain where the application will be made available.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgs']]] egresses: Specification for app egress configurations.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] features: A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/reference/apps/list-buildpacks/)
        :param pulumi.Input['AppSpecIngressArgs'] ingress: Specification for component routing, rewrites, and redirects.
        :param pulumi.Input[str] region: The slug for the DigitalOcean data center region hosting the app.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if databases is not None:
            pulumi.set(__self__, "databases", databases)
        if domain_names is not None:
            pulumi.set(__self__, "domain_names", domain_names)
        if domains is not None:
            warnings.warn("""This attribute has been replaced by `domain` which supports additional functionality.""", DeprecationWarning)
            pulumi.log.warn("""domains is deprecated: This attribute has been replaced by `domain` which supports additional functionality.""")
        if domains is not None:
            pulumi.set(__self__, "domains", domains)
        if egresses is not None:
            pulumi.set(__self__, "egresses", egresses)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if features is not None:
            pulumi.set(__self__, "features", features)
        if functions is not None:
            pulumi.set(__self__, "functions", functions)
        if ingress is not None:
            pulumi.set(__self__, "ingress", ingress)
        if jobs is not None:
            pulumi.set(__self__, "jobs", jobs)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if static_sites is not None:
            pulumi.set(__self__, "static_sites", static_sites)
        if workers is not None:
            pulumi.set(__self__, "workers", workers)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter
    def databases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDatabaseArgs']]]]:
        return pulumi.get(self, "databases")

    @databases.setter
    def databases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDatabaseArgs']]]]):
        pulumi.set(self, "databases", value)

    @property
    @pulumi.getter(name="domainNames")
    def domain_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgs']]]]:
        """
        Describes a domain where the application will be made available.
        """
        return pulumi.get(self, "domain_names")

    @domain_names.setter
    def domain_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecDomainNameArgs']]]]):
        pulumi.set(self, "domain_names", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""This attribute has been replaced by `domain` which supports additional functionality.""")
    def domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "domains")

    @domains.setter
    def domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "domains", value)

    @property
    @pulumi.getter
    def egresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgs']]]]:
        """
        Specification for app egress configurations.
        """
        return pulumi.get(self, "egresses")

    @egresses.setter
    def egresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEgressArgs']]]]):
        pulumi.set(self, "egresses", value)

    @property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @property
    @pulumi.getter
    def features(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of the features applied to the app. The default buildpack can be overridden here. List of available buildpacks can be found using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/reference/apps/list-buildpacks/)
        """
        return pulumi.get(self, "features")

    @features.setter
    def features(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "features", value)

    @property
    @pulumi.getter
    def functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionArgs']]]]:
        return pulumi.get(self, "functions")

    @functions.setter
    def functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionArgs']]]]):
        pulumi.set(self, "functions", value)

    @property
    @pulumi.getter
    def ingress(self) -> Optional[pulumi.Input['AppSpecIngressArgs']]:
        """
        Specification for component routing, rewrites, and redirects.
        """
        return pulumi.get(self, "ingress")

    @ingress.setter
    def ingress(self, value: Optional[pulumi.Input['AppSpecIngressArgs']]):
        pulumi.set(self, "ingress", value)

    @property
    @pulumi.getter
    def jobs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobArgs']]]]:
        return pulumi.get(self, "jobs")

    @jobs.setter
    def jobs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobArgs']]]]):
        pulumi.set(self, "jobs", value)

    @property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[str]]:
        """
        The slug for the DigitalOcean data center region hosting the app.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceArgs']]]]:
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceArgs']]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter(name="staticSites")
    def static_sites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteArgs']]]]:
        return pulumi.get(self, "static_sites")

    @static_sites.setter
    def static_sites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteArgs']]]]):
        pulumi.set(self, "static_sites", value)

    @property
    @pulumi.getter
    def workers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerArgs']]]]:
        return pulumi.get(self, "workers")

    @workers.setter
    def workers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerArgs']]]]):
        pulumi.set(self, "workers", value)


if not MYPY:
    class AppSpecAlertArgsDict(TypedDict):
        rule: pulumi.Input[str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecAlertArgs:
    def __init__(__self__, *,
                 rule: pulumi.Input[str],
                 disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "rule", rule)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input[str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecDatabaseArgsDict(TypedDict):
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        db_name: NotRequired[pulumi.Input[str]]
        """
        The name of the MySQL or PostgreSQL database to configure.
        """
        db_user: NotRequired[pulumi.Input[str]]
        """
        The name of the MySQL or PostgreSQL user to configure.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        engine: NotRequired[pulumi.Input[str]]
        """
        The database engine to use (`MYSQL`, `PG`, `REDIS`, `MONGODB`, `KAFKA`, or `OPENSEARCH`).
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the component.
        """
        production: NotRequired[pulumi.Input[bool]]
        """
        Whether this is a production or dev database.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        The version of the database engine.
        """
elif False:
    AppSpecDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecDatabaseArgs:
    def __init__(__self__, *,
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 db_name: Optional[pulumi.Input[str]] = None,
                 db_user: Optional[pulumi.Input[str]] = None,
                 engine: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 production: Optional[pulumi.Input[bool]] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[str] db_name: The name of the MySQL or PostgreSQL database to configure.
        :param pulumi.Input[str] db_user: The name of the MySQL or PostgreSQL user to configure.
               
               This resource supports customized create timeouts. The default timeout is 30 minutes.
        :param pulumi.Input[str] engine: The database engine to use (`MYSQL`, `PG`, `REDIS`, `MONGODB`, `KAFKA`, or `OPENSEARCH`).
        :param pulumi.Input[str] name: The name of the component.
        :param pulumi.Input[bool] production: Whether this is a production or dev database.
        :param pulumi.Input[str] version: The version of the database engine.
        """
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if db_name is not None:
            pulumi.set(__self__, "db_name", db_name)
        if db_user is not None:
            pulumi.set(__self__, "db_user", db_user)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if production is not None:
            pulumi.set(__self__, "production", production)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter(name="dbName")
    def db_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the MySQL or PostgreSQL database to configure.
        """
        return pulumi.get(self, "db_name")

    @db_name.setter
    def db_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_name", value)

    @property
    @pulumi.getter(name="dbUser")
    def db_user(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the MySQL or PostgreSQL user to configure.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        return pulumi.get(self, "db_user")

    @db_user.setter
    def db_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "db_user", value)

    @property
    @pulumi.getter
    def engine(self) -> Optional[pulumi.Input[str]]:
        """
        The database engine to use (`MYSQL`, `PG`, `REDIS`, `MONGODB`, `KAFKA`, or `OPENSEARCH`).
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "engine", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def production(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this is a production or dev database.
        """
        return pulumi.get(self, "production")

    @production.setter
    def production(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "production", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the database engine.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class AppSpecDomainNameArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The hostname for the domain.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The domain type, which can be one of the following:
        - `DEFAULT`: The default .ondigitalocean.app domain assigned to this app.
        - `PRIMARY`: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
        - `ALIAS`: A non-primary domain.
        """
        wildcard: NotRequired[pulumi.Input[bool]]
        """
        A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
        """
        zone: NotRequired[pulumi.Input[str]]
        """
        If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
elif False:
    AppSpecDomainNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecDomainNameArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 type: Optional[pulumi.Input[str]] = None,
                 wildcard: Optional[pulumi.Input[bool]] = None,
                 zone: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The hostname for the domain.
        :param pulumi.Input[str] type: The domain type, which can be one of the following:
               - `DEFAULT`: The default .ondigitalocean.app domain assigned to this app.
               - `PRIMARY`: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
               - `ALIAS`: A non-primary domain.
        :param pulumi.Input[bool] wildcard: A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
        :param pulumi.Input[str] zone: If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
        pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if wildcard is not None:
            pulumi.set(__self__, "wildcard", wildcard)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The hostname for the domain.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The domain type, which can be one of the following:
        - `DEFAULT`: The default .ondigitalocean.app domain assigned to this app.
        - `PRIMARY`: The primary domain for this app that is displayed as the default in the control panel, used in bindable environment variables, and any other places that reference an app's live URL. Only one domain may be set as primary.
        - `ALIAS`: A non-primary domain.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def wildcard(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean indicating whether the domain includes all sub-domains, in addition to the given domain.
        """
        return pulumi.get(self, "wildcard")

    @wildcard.setter
    def wildcard(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "wildcard", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[str]]:
        """
        If the domain uses DigitalOcean DNS and you would like App Platform to automatically manage it for you, set this to the name of the domain on your account.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class AppSpecEgressArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[str]]
        """
        The app egress type: `AUTOASSIGN`, `DEDICATED_IP`
        """
elif False:
    AppSpecEgressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecEgressArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The app egress type: `AUTOASSIGN`, `DEDICATED_IP`
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The app egress type: `AUTOASSIGN`, `DEDICATED_IP`
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppSpecEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The name of the environment variable.
        :param pulumi.Input[str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecFunctionArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        cors: NotRequired[pulumi.Input['AppSpecFunctionCorsArgsDict']]
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        git: NotRequired[pulumi.Input['AppSpecFunctionGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecFunctionGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecFunctionGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        log_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgsDict']]]]
        """
        Describes a log forwarding destination.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgsDict']]]]
        """
        An HTTP paths that should be routed to this component.
        """
        source_dir: NotRequired[pulumi.Input[str]]
        """
        An optional path to the working directory to use for the build.
        """
elif False:
    AppSpecFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgs']]]] = None,
                 cors: Optional[pulumi.Input['AppSpecFunctionCorsArgs']] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgs']]]] = None,
                 git: Optional[pulumi.Input['AppSpecFunctionGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecFunctionGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecFunctionGitlabArgs']] = None,
                 log_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgs']]]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgs']]]] = None,
                 source_dir: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input['AppSpecFunctionCorsArgs'] cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input['AppSpecFunctionGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecFunctionGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecFunctionGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgs']]] log_destinations: Describes a log forwarding destination.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgs']]] routes: An HTTP paths that should be routed to this component.
        :param pulumi.Input[str] source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if cors is not None:
            warnings.warn("""Service level CORS rules are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""cors is deprecated: Service level CORS rules are deprecated in favor of ingresses""")
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if routes is not None:
            warnings.warn("""Service level routes are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""routes is deprecated: Service level routes are deprecated in favor of ingresses""")
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional[pulumi.Input['AppSpecFunctionCorsArgs']]:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppSpecFunctionCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecFunctionGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecFunctionGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecFunctionGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecFunctionGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecFunctionGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecFunctionGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgs']]]]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @log_destinations.setter
    def log_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionLogDestinationArgs']]]]):
        pulumi.set(self, "log_destinations", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgs']]]]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecFunctionRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_dir", value)


if not MYPY:
    class AppSpecFunctionAlertArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        rule: pulumi.Input[str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        value: pulumi.Input[float]
        """
        The threshold for the type of the warning.
        """
        window: pulumi.Input[str]
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecFunctionAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionAlertArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 rule: pulumi.Input[str],
                 value: pulumi.Input[float],
                 window: pulumi.Input[str],
                 disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param pulumi.Input[str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[float] value: The threshold for the type of the warning.
        :param pulumi.Input[str] window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param pulumi.Input[bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input[str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def window(self) -> pulumi.Input[str]:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[str]):
        pulumi.set(self, "window", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecFunctionCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        allow_origins: NotRequired[pulumi.Input['AppSpecFunctionCorsAllowOriginsArgsDict']]
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        max_age: NotRequired[pulumi.Input[str]]
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
elif False:
    AppSpecFunctionCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input['AppSpecFunctionCorsAllowOriginsArgs']] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param pulumi.Input['AppSpecFunctionCorsAllowOriginsArgs'] allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param pulumi.Input[str] max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input['AppSpecFunctionCorsAllowOriginsArgs']]:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input['AppSpecFunctionCorsAllowOriginsArgs']]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[str]]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AppSpecFunctionCorsAllowOriginsArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Exact string match.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix-based match.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        RE2 style regex-based match.
        """
elif False:
    AppSpecFunctionCorsAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionCorsAllowOriginsArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Exact string match.
        :param pulumi.Input[str] prefix: Prefix-based match.
        :param pulumi.Input[str] regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            warnings.warn("""Prefix-based matching has been deprecated in favor of regex-based matching.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Prefix-based matching has been deprecated in favor of regex-based matching.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AppSpecFunctionEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecFunctionEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The name of the environment variable.
        :param pulumi.Input[str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecFunctionGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecFunctionGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 repo_clone_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecFunctionGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecFunctionGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecFunctionGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecFunctionGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecFunctionLogDestinationArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        datadog: NotRequired[pulumi.Input['AppSpecFunctionLogDestinationDatadogArgsDict']]
        """
        Datadog configuration.
        """
        logtail: NotRequired[pulumi.Input['AppSpecFunctionLogDestinationLogtailArgsDict']]
        """
        Logtail configuration.
        """
        open_search: NotRequired[pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgsDict']]
        """
        OpenSearch configuration.
        """
        papertrail: NotRequired[pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgsDict']]
        """
        Papertrail configuration.
        """
elif False:
    AppSpecFunctionLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 datadog: Optional[pulumi.Input['AppSpecFunctionLogDestinationDatadogArgs']] = None,
                 logtail: Optional[pulumi.Input['AppSpecFunctionLogDestinationLogtailArgs']] = None,
                 open_search: Optional[pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgs']] = None,
                 papertrail: Optional[pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param pulumi.Input['AppSpecFunctionLogDestinationDatadogArgs'] datadog: Datadog configuration.
        :param pulumi.Input['AppSpecFunctionLogDestinationLogtailArgs'] logtail: Logtail configuration.
        :param pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgs'] open_search: OpenSearch configuration.
        :param pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgs'] papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def datadog(self) -> Optional[pulumi.Input['AppSpecFunctionLogDestinationDatadogArgs']]:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @datadog.setter
    def datadog(self, value: Optional[pulumi.Input['AppSpecFunctionLogDestinationDatadogArgs']]):
        pulumi.set(self, "datadog", value)

    @property
    @pulumi.getter
    def logtail(self) -> Optional[pulumi.Input['AppSpecFunctionLogDestinationLogtailArgs']]:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @logtail.setter
    def logtail(self, value: Optional[pulumi.Input['AppSpecFunctionLogDestinationLogtailArgs']]):
        pulumi.set(self, "logtail", value)

    @property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgs']]:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['AppSpecFunctionLogDestinationOpenSearchArgs']]):
        pulumi.set(self, "open_search", value)

    @property
    @pulumi.getter
    def papertrail(self) -> Optional[pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgs']]:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")

    @papertrail.setter
    def papertrail(self, value: Optional[pulumi.Input['AppSpecFunctionLogDestinationPapertrailArgs']]):
        pulumi.set(self, "papertrail", value)


if not MYPY:
    class AppSpecFunctionLogDestinationDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        """
        Datadog API key.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        Datadog HTTP log intake endpoint.
        """
elif False:
    AppSpecFunctionLogDestinationDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Datadog API key.
        :param pulumi.Input[str] endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecFunctionLogDestinationLogtailArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Logtail token.
        """
elif False:
    AppSpecFunctionLogDestinationLogtailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationLogtailArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppSpecFunctionLogDestinationOpenSearchArgsDict(TypedDict):
        basic_auth: pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgsDict']
        """
        Basic authentication details.
        """
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        OpenSearch endpoint.
        """
        index_name: NotRequired[pulumi.Input[str]]
        """
        OpenSearch index name.
        """
elif False:
    AppSpecFunctionLogDestinationOpenSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationOpenSearchArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs'],
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 index_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs'] basic_auth: Basic authentication details.
        :param pulumi.Input[str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[str] endpoint: OpenSearch endpoint.
        :param pulumi.Input[str] index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs']:
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input['AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class AppSpecFunctionLogDestinationOpenSearchBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        Password for basic authentication.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        user for basic authentication.
        """
elif False:
    AppSpecFunctionLogDestinationOpenSearchBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationOpenSearchBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Password for basic authentication.
        :param pulumi.Input[str] user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AppSpecFunctionLogDestinationPapertrailArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        Papertrail syslog endpoint.
        """
elif False:
    AppSpecFunctionLogDestinationPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionLogDestinationPapertrailArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecFunctionRouteArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
        """
        Paths must start with `/` and must be unique within the app.
        """
        preserve_path_prefix: NotRequired[pulumi.Input[bool]]
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
elif False:
    AppSpecFunctionRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecFunctionRouteArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 preserve_path_prefix: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] path: Paths must start with `/` and must be unique within the app.
        :param pulumi.Input[bool] preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[pulumi.Input[bool]]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @preserve_path_prefix.setter
    def preserve_path_prefix(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_path_prefix", value)


if not MYPY:
    class AppSpecIngressArgsDict(TypedDict):
        rules: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgsDict']]]]
        """
        Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
elif False:
    AppSpecIngressArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressArgs:
    def __init__(__self__, *,
                 rules: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgs']]] rules: Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
        if rules is not None:
            pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter
    def rules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgs']]]]:
        """
        Rules for configuring HTTP ingress for component routes, CORS, rewrites, and redirects.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecIngressRuleArgs']]]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class AppSpecIngressRuleArgsDict(TypedDict):
        component: NotRequired[pulumi.Input['AppSpecIngressRuleComponentArgsDict']]
        """
        The component to route to. Only one of `component` or `redirect` may be set.
        """
        cors: NotRequired[pulumi.Input['AppSpecIngressRuleCorsArgsDict']]
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        match: NotRequired[pulumi.Input['AppSpecIngressRuleMatchArgsDict']]
        """
        The match configuration for the rule
        """
        redirect: NotRequired[pulumi.Input['AppSpecIngressRuleRedirectArgsDict']]
        """
        The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
elif False:
    AppSpecIngressRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleArgs:
    def __init__(__self__, *,
                 component: Optional[pulumi.Input['AppSpecIngressRuleComponentArgs']] = None,
                 cors: Optional[pulumi.Input['AppSpecIngressRuleCorsArgs']] = None,
                 match: Optional[pulumi.Input['AppSpecIngressRuleMatchArgs']] = None,
                 redirect: Optional[pulumi.Input['AppSpecIngressRuleRedirectArgs']] = None):
        """
        :param pulumi.Input['AppSpecIngressRuleComponentArgs'] component: The component to route to. Only one of `component` or `redirect` may be set.
        :param pulumi.Input['AppSpecIngressRuleCorsArgs'] cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param pulumi.Input['AppSpecIngressRuleMatchArgs'] match: The match configuration for the rule
        :param pulumi.Input['AppSpecIngressRuleRedirectArgs'] redirect: The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
        if component is not None:
            pulumi.set(__self__, "component", component)
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if match is not None:
            pulumi.set(__self__, "match", match)
        if redirect is not None:
            pulumi.set(__self__, "redirect", redirect)

    @property
    @pulumi.getter
    def component(self) -> Optional[pulumi.Input['AppSpecIngressRuleComponentArgs']]:
        """
        The component to route to. Only one of `component` or `redirect` may be set.
        """
        return pulumi.get(self, "component")

    @component.setter
    def component(self, value: Optional[pulumi.Input['AppSpecIngressRuleComponentArgs']]):
        pulumi.set(self, "component", value)

    @property
    @pulumi.getter
    def cors(self) -> Optional[pulumi.Input['AppSpecIngressRuleCorsArgs']]:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppSpecIngressRuleCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter
    def match(self) -> Optional[pulumi.Input['AppSpecIngressRuleMatchArgs']]:
        """
        The match configuration for the rule
        """
        return pulumi.get(self, "match")

    @match.setter
    def match(self, value: Optional[pulumi.Input['AppSpecIngressRuleMatchArgs']]):
        pulumi.set(self, "match", value)

    @property
    @pulumi.getter
    def redirect(self) -> Optional[pulumi.Input['AppSpecIngressRuleRedirectArgs']]:
        """
        The redirect configuration for the rule. Only one of `component` or `redirect` may be set.
        """
        return pulumi.get(self, "redirect")

    @redirect.setter
    def redirect(self, value: Optional[pulumi.Input['AppSpecIngressRuleRedirectArgs']]):
        pulumi.set(self, "redirect", value)


if not MYPY:
    class AppSpecIngressRuleComponentArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        The name of the component to route to.
        """
        preserve_path_prefix: NotRequired[pulumi.Input[bool]]
        """
        An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
        """
        rewrite: NotRequired[pulumi.Input[str]]
        """
        An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with `preserve_path_prefix`.
        """
elif False:
    AppSpecIngressRuleComponentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleComponentArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 preserve_path_prefix: Optional[pulumi.Input[bool]] = None,
                 rewrite: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the component to route to.
        :param pulumi.Input[bool] preserve_path_prefix: An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
        :param pulumi.Input[str] rewrite: An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with `preserve_path_prefix`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)
        if rewrite is not None:
            pulumi.set(__self__, "rewrite", rewrite)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the component to route to.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[pulumi.Input[bool]]:
        """
        An optional boolean flag to preserve the path that is forwarded to the backend service. By default, the HTTP request path will be trimmed from the left when forwarded to the component.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @preserve_path_prefix.setter
    def preserve_path_prefix(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_path_prefix", value)

    @property
    @pulumi.getter
    def rewrite(self) -> Optional[pulumi.Input[str]]:
        """
        An optional field that will rewrite the path of the component to be what is specified here. This is mutually exclusive with `preserve_path_prefix`.
        """
        return pulumi.get(self, "rewrite")

    @rewrite.setter
    def rewrite(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "rewrite", value)


if not MYPY:
    class AppSpecIngressRuleCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        allow_origins: NotRequired[pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgsDict']]
        """
        The `Access-Control-Allow-Origin` can be
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        max_age: NotRequired[pulumi.Input[str]]
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
elif False:
    AppSpecIngressRuleCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgs']] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_headers: The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_methods: The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        :param pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgs'] allow_origins: The `Access-Control-Allow-Origin` can be
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        :param pulumi.Input[str] max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the request's credentials mode is `include`. This configures the `Access-Control-Allow-Credentials` header.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of allowed HTTP request headers. This configures the `Access-Control-Allow-Headers` header.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of allowed HTTP methods. This configures the `Access-Control-Allow-Methods` header.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgs']]:
        """
        The `Access-Control-Allow-Origin` can be
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input['AppSpecIngressRuleCorsAllowOriginsArgs']]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the `Access-Control-Expose-Headers` header.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[str]]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AppSpecIngressRuleCorsAllowOriginsArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
elif False:
    AppSpecIngressRuleCorsAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleCorsAllowOriginsArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        :param pulumi.Input[str] prefix: The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        :param pulumi.Input[str] regex: The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            warnings.warn("""Prefix-based matching has been deprecated in favor of regex-based matching.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Prefix-based matching has been deprecated in favor of regex-based matching.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin only if the client's origin exactly matches the value you provide.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the beginning of the client's origin matches the value you provide.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        The `Access-Control-Allow-Origin` header will be set to the client's origin if the clients origin matches the regex you provide, in [RE2 style syntax](https://github.com/google/re2/wiki/Syntax).
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AppSpecIngressRuleMatchArgsDict(TypedDict):
        path: NotRequired[pulumi.Input['AppSpecIngressRuleMatchPathArgsDict']]
        """
        The path to match on.
        """
elif False:
    AppSpecIngressRuleMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleMatchArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input['AppSpecIngressRuleMatchPathArgs']] = None):
        """
        :param pulumi.Input['AppSpecIngressRuleMatchPathArgs'] path: The path to match on.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input['AppSpecIngressRuleMatchPathArgs']]:
        """
        The path to match on.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input['AppSpecIngressRuleMatchPathArgs']]):
        pulumi.set(self, "path", value)


if not MYPY:
    class AppSpecIngressRuleMatchPathArgsDict(TypedDict):
        prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix-based match.
        """
elif False:
    AppSpecIngressRuleMatchPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleMatchPathArgs:
    def __init__(__self__, *,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] prefix: Prefix-based match.
        """
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AppSpecIngressRuleRedirectArgsDict(TypedDict):
        authority: NotRequired[pulumi.Input[str]]
        """
        The authority/host to redirect to. This can be a hostname or IP address.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The port to redirect to.
        """
        redirect_code: NotRequired[pulumi.Input[int]]
        """
        The redirect code to use. Supported values are `300`, `301`, `302`, `303`, `304`, `307`, `308`.
        """
        scheme: NotRequired[pulumi.Input[str]]
        """
        The scheme to redirect to. Supported values are `http` or `https`
        """
        uri: NotRequired[pulumi.Input[str]]
        """
        An optional URI path to redirect to.
        """
elif False:
    AppSpecIngressRuleRedirectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecIngressRuleRedirectArgs:
    def __init__(__self__, *,
                 authority: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 redirect_code: Optional[pulumi.Input[int]] = None,
                 scheme: Optional[pulumi.Input[str]] = None,
                 uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] authority: The authority/host to redirect to. This can be a hostname or IP address.
        :param pulumi.Input[int] port: The port to redirect to.
        :param pulumi.Input[int] redirect_code: The redirect code to use. Supported values are `300`, `301`, `302`, `303`, `304`, `307`, `308`.
        :param pulumi.Input[str] scheme: The scheme to redirect to. Supported values are `http` or `https`
        :param pulumi.Input[str] uri: An optional URI path to redirect to.
        """
        if authority is not None:
            pulumi.set(__self__, "authority", authority)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if redirect_code is not None:
            pulumi.set(__self__, "redirect_code", redirect_code)
        if scheme is not None:
            pulumi.set(__self__, "scheme", scheme)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def authority(self) -> Optional[pulumi.Input[str]]:
        """
        The authority/host to redirect to. This can be a hostname or IP address.
        """
        return pulumi.get(self, "authority")

    @authority.setter
    def authority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "authority", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The port to redirect to.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="redirectCode")
    def redirect_code(self) -> Optional[pulumi.Input[int]]:
        """
        The redirect code to use. Supported values are `300`, `301`, `302`, `303`, `304`, `307`, `308`.
        """
        return pulumi.get(self, "redirect_code")

    @redirect_code.setter
    def redirect_code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "redirect_code", value)

    @property
    @pulumi.getter
    def scheme(self) -> Optional[pulumi.Input[str]]:
        """
        The scheme to redirect to. Supported values are `http` or `https`
        """
        return pulumi.get(self, "scheme")

    @scheme.setter
    def scheme(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scheme", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[str]]:
        """
        An optional URI path to redirect to.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class AppSpecJobArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        build_command: NotRequired[pulumi.Input[str]]
        """
        An optional build command to run while building this component from source.
        """
        dockerfile_path: NotRequired[pulumi.Input[str]]
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        environment_slug: NotRequired[pulumi.Input[str]]
        """
        An environment slug describing the type of this app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        git: NotRequired[pulumi.Input['AppSpecJobGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecJobGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecJobGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        image: NotRequired[pulumi.Input['AppSpecJobImageArgsDict']]
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        instance_count: NotRequired[pulumi.Input[int]]
        """
        The amount of instances that this component should be scaled to.
        """
        instance_size_slug: NotRequired[pulumi.Input[str]]
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        kind: NotRequired[pulumi.Input[str]]
        """
        The type of job and when it will be run during the deployment process. It may be one of:
        - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
        - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
        - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
        - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        """
        log_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgsDict']]]]
        """
        Describes a log forwarding destination.
        """
        run_command: NotRequired[pulumi.Input[str]]
        """
        An optional run command to override the component's default.
        """
        source_dir: NotRequired[pulumi.Input[str]]
        """
        An optional path to the working directory to use for the build.
        """
elif False:
    AppSpecJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgs']]]] = None,
                 build_command: Optional[pulumi.Input[str]] = None,
                 dockerfile_path: Optional[pulumi.Input[str]] = None,
                 environment_slug: Optional[pulumi.Input[str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgs']]]] = None,
                 git: Optional[pulumi.Input['AppSpecJobGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecJobGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecJobGitlabArgs']] = None,
                 image: Optional[pulumi.Input['AppSpecJobImageArgs']] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 instance_size_slug: Optional[pulumi.Input[str]] = None,
                 kind: Optional[pulumi.Input[str]] = None,
                 log_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgs']]]] = None,
                 run_command: Optional[pulumi.Input[str]] = None,
                 source_dir: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input[str] build_command: An optional build command to run while building this component from source.
        :param pulumi.Input[str] dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param pulumi.Input[str] environment_slug: An environment slug describing the type of this app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input['AppSpecJobGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecJobGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecJobGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecJobImageArgs'] image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[int] instance_count: The amount of instances that this component should be scaled to.
        :param pulumi.Input[str] instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param pulumi.Input[str] kind: The type of job and when it will be run during the deployment process. It may be one of:
               - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
               - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
               - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
               - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgs']]] log_destinations: Describes a log forwarding destination.
        :param pulumi.Input[str] run_command: An optional run command to override the component's default.
        :param pulumi.Input[str] source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if kind is not None:
            pulumi.set(__self__, "kind", kind)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dockerfile_path", value)

    @property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[pulumi.Input[str]]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @environment_slug.setter
    def environment_slug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment_slug", value)

    @property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecJobGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecJobGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecJobGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecJobGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecJobGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecJobGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['AppSpecJobImageArgs']]:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['AppSpecJobImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[pulumi.Input[str]]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @instance_size_slug.setter
    def instance_size_slug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_size_slug", value)

    @property
    @pulumi.getter
    def kind(self) -> Optional[pulumi.Input[str]]:
        """
        The type of job and when it will be run during the deployment process. It may be one of:
        - `UNSPECIFIED`: Default job type, will auto-complete to POST_DEPLOY kind.
        - `PRE_DEPLOY`: Indicates a job that runs before an app deployment.
        - `POST_DEPLOY`: Indicates a job that runs after an app deployment.
        - `FAILED_DEPLOY`: Indicates a job that runs after a component fails to deploy.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgs']]]]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @log_destinations.setter
    def log_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobLogDestinationArgs']]]]):
        pulumi.set(self, "log_destinations", value)

    @property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[pulumi.Input[str]]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @run_command.setter
    def run_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_command", value)

    @property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_dir", value)


if not MYPY:
    class AppSpecJobAlertArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        rule: pulumi.Input[str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        value: pulumi.Input[float]
        """
        The threshold for the type of the warning.
        """
        window: pulumi.Input[str]
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecJobAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobAlertArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 rule: pulumi.Input[str],
                 value: pulumi.Input[float],
                 window: pulumi.Input[str],
                 disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param pulumi.Input[str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[float] value: The threshold for the type of the warning.
        :param pulumi.Input[str] window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param pulumi.Input[bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input[str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def window(self) -> pulumi.Input[str]:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[str]):
        pulumi.set(self, "window", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecJobEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecJobEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The name of the environment variable.
        :param pulumi.Input[str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecJobGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecJobGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 repo_clone_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecJobGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecJobGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecJobGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecJobGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecJobImageArgsDict(TypedDict):
        registry_type: pulumi.Input[str]
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        repository: pulumi.Input[str]
        """
        The repository name.
        """
        deploy_on_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgsDict']]]]
        """
        Configures automatically deploying images pushed to DOCR.
        """
        registry: NotRequired[pulumi.Input[str]]
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        registry_credentials: NotRequired[pulumi.Input[str]]
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        tag: NotRequired[pulumi.Input[str]]
        """
        The repository tag. Defaults to `latest` if not provided.
        """
elif False:
    AppSpecJobImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobImageArgs:
    def __init__(__self__, *,
                 registry_type: pulumi.Input[str],
                 repository: pulumi.Input[str],
                 deploy_on_pushes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgs']]]] = None,
                 registry: Optional[pulumi.Input[str]] = None,
                 registry_credentials: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param pulumi.Input[str] repository: The repository name.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgs']]] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param pulumi.Input[str] registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param pulumi.Input[str] registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param pulumi.Input[str] tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> pulumi.Input[str]:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @registry_type.setter
    def registry_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_type", value)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[str]:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgs']]]]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @deploy_on_pushes.setter
    def deploy_on_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecJobImageDeployOnPushArgs']]]]):
        pulumi.set(self, "deploy_on_pushes", value)

    @property
    @pulumi.getter
    def registry(self) -> Optional[pulumi.Input[str]]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry", value)

    @property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @registry_credentials.setter
    def registry_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_credentials", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class AppSpecJobImageDeployOnPushArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy images pushed to DOCR.
        """
elif False:
    AppSpecJobImageDeployOnPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobImageDeployOnPushArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AppSpecJobLogDestinationArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        datadog: NotRequired[pulumi.Input['AppSpecJobLogDestinationDatadogArgsDict']]
        """
        Datadog configuration.
        """
        logtail: NotRequired[pulumi.Input['AppSpecJobLogDestinationLogtailArgsDict']]
        """
        Logtail configuration.
        """
        open_search: NotRequired[pulumi.Input['AppSpecJobLogDestinationOpenSearchArgsDict']]
        """
        OpenSearch configuration.
        """
        papertrail: NotRequired[pulumi.Input['AppSpecJobLogDestinationPapertrailArgsDict']]
        """
        Papertrail configuration.
        """
elif False:
    AppSpecJobLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 datadog: Optional[pulumi.Input['AppSpecJobLogDestinationDatadogArgs']] = None,
                 logtail: Optional[pulumi.Input['AppSpecJobLogDestinationLogtailArgs']] = None,
                 open_search: Optional[pulumi.Input['AppSpecJobLogDestinationOpenSearchArgs']] = None,
                 papertrail: Optional[pulumi.Input['AppSpecJobLogDestinationPapertrailArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param pulumi.Input['AppSpecJobLogDestinationDatadogArgs'] datadog: Datadog configuration.
        :param pulumi.Input['AppSpecJobLogDestinationLogtailArgs'] logtail: Logtail configuration.
        :param pulumi.Input['AppSpecJobLogDestinationOpenSearchArgs'] open_search: OpenSearch configuration.
        :param pulumi.Input['AppSpecJobLogDestinationPapertrailArgs'] papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def datadog(self) -> Optional[pulumi.Input['AppSpecJobLogDestinationDatadogArgs']]:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @datadog.setter
    def datadog(self, value: Optional[pulumi.Input['AppSpecJobLogDestinationDatadogArgs']]):
        pulumi.set(self, "datadog", value)

    @property
    @pulumi.getter
    def logtail(self) -> Optional[pulumi.Input['AppSpecJobLogDestinationLogtailArgs']]:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @logtail.setter
    def logtail(self, value: Optional[pulumi.Input['AppSpecJobLogDestinationLogtailArgs']]):
        pulumi.set(self, "logtail", value)

    @property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['AppSpecJobLogDestinationOpenSearchArgs']]:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['AppSpecJobLogDestinationOpenSearchArgs']]):
        pulumi.set(self, "open_search", value)

    @property
    @pulumi.getter
    def papertrail(self) -> Optional[pulumi.Input['AppSpecJobLogDestinationPapertrailArgs']]:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")

    @papertrail.setter
    def papertrail(self, value: Optional[pulumi.Input['AppSpecJobLogDestinationPapertrailArgs']]):
        pulumi.set(self, "papertrail", value)


if not MYPY:
    class AppSpecJobLogDestinationDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        """
        Datadog API key.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        Datadog HTTP log intake endpoint.
        """
elif False:
    AppSpecJobLogDestinationDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Datadog API key.
        :param pulumi.Input[str] endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecJobLogDestinationLogtailArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Logtail token.
        """
elif False:
    AppSpecJobLogDestinationLogtailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationLogtailArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppSpecJobLogDestinationOpenSearchArgsDict(TypedDict):
        basic_auth: pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgsDict']
        """
        Basic authentication details.
        """
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        OpenSearch endpoint.
        """
        index_name: NotRequired[pulumi.Input[str]]
        """
        OpenSearch index name.
        """
elif False:
    AppSpecJobLogDestinationOpenSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationOpenSearchArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgs'],
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 index_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgs'] basic_auth: Basic authentication details.
        :param pulumi.Input[str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[str] endpoint: OpenSearch endpoint.
        :param pulumi.Input[str] index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgs']:
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input['AppSpecJobLogDestinationOpenSearchBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class AppSpecJobLogDestinationOpenSearchBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        Password for basic authentication.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        user for basic authentication.
        """
elif False:
    AppSpecJobLogDestinationOpenSearchBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationOpenSearchBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Password for basic authentication.
        :param pulumi.Input[str] user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AppSpecJobLogDestinationPapertrailArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        Papertrail syslog endpoint.
        """
elif False:
    AppSpecJobLogDestinationPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecJobLogDestinationPapertrailArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecServiceArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        autoscaling: NotRequired[pulumi.Input['AppSpecServiceAutoscalingArgsDict']]
        """
        Configuration for automatically scaling this component based on metrics.
        """
        build_command: NotRequired[pulumi.Input[str]]
        """
        An optional build command to run while building this component from source.
        """
        cors: NotRequired[pulumi.Input['AppSpecServiceCorsArgsDict']]
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        dockerfile_path: NotRequired[pulumi.Input[str]]
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        environment_slug: NotRequired[pulumi.Input[str]]
        """
        An environment slug describing the type of this app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        git: NotRequired[pulumi.Input['AppSpecServiceGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecServiceGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecServiceGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        health_check: NotRequired[pulumi.Input['AppSpecServiceHealthCheckArgsDict']]
        """
        A health check to determine the availability of this component.
        """
        http_port: NotRequired[pulumi.Input[int]]
        """
        The internal port on which this service's run command will listen.
        """
        image: NotRequired[pulumi.Input['AppSpecServiceImageArgsDict']]
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        instance_count: NotRequired[pulumi.Input[int]]
        """
        The amount of instances that this component should be scaled to.
        """
        instance_size_slug: NotRequired[pulumi.Input[str]]
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        internal_ports: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        A list of ports on which this service will listen for internal traffic.
        """
        log_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgsDict']]]]
        """
        Describes a log forwarding destination.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgsDict']]]]
        """
        An HTTP paths that should be routed to this component.
        """
        run_command: NotRequired[pulumi.Input[str]]
        """
        An optional run command to override the component's default.
        """
        source_dir: NotRequired[pulumi.Input[str]]
        """
        An optional path to the working directory to use for the build.
        """
elif False:
    AppSpecServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgs']]]] = None,
                 autoscaling: Optional[pulumi.Input['AppSpecServiceAutoscalingArgs']] = None,
                 build_command: Optional[pulumi.Input[str]] = None,
                 cors: Optional[pulumi.Input['AppSpecServiceCorsArgs']] = None,
                 dockerfile_path: Optional[pulumi.Input[str]] = None,
                 environment_slug: Optional[pulumi.Input[str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgs']]]] = None,
                 git: Optional[pulumi.Input['AppSpecServiceGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecServiceGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecServiceGitlabArgs']] = None,
                 health_check: Optional[pulumi.Input['AppSpecServiceHealthCheckArgs']] = None,
                 http_port: Optional[pulumi.Input[int]] = None,
                 image: Optional[pulumi.Input['AppSpecServiceImageArgs']] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 instance_size_slug: Optional[pulumi.Input[str]] = None,
                 internal_ports: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 log_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgs']]]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgs']]]] = None,
                 run_command: Optional[pulumi.Input[str]] = None,
                 source_dir: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input['AppSpecServiceAutoscalingArgs'] autoscaling: Configuration for automatically scaling this component based on metrics.
        :param pulumi.Input[str] build_command: An optional build command to run while building this component from source.
        :param pulumi.Input['AppSpecServiceCorsArgs'] cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param pulumi.Input[str] dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param pulumi.Input[str] environment_slug: An environment slug describing the type of this app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input['AppSpecServiceGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecServiceGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecServiceGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecServiceHealthCheckArgs'] health_check: A health check to determine the availability of this component.
        :param pulumi.Input[int] http_port: The internal port on which this service's run command will listen.
        :param pulumi.Input['AppSpecServiceImageArgs'] image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[int] instance_count: The amount of instances that this component should be scaled to.
        :param pulumi.Input[str] instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param pulumi.Input[Sequence[pulumi.Input[int]]] internal_ports: A list of ports on which this service will listen for internal traffic.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgs']]] log_destinations: Describes a log forwarding destination.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgs']]] routes: An HTTP paths that should be routed to this component.
        :param pulumi.Input[str] run_command: An optional run command to override the component's default.
        :param pulumi.Input[str] source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if autoscaling is not None:
            pulumi.set(__self__, "autoscaling", autoscaling)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if cors is not None:
            warnings.warn("""Service level CORS rules are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""cors is deprecated: Service level CORS rules are deprecated in favor of ingresses""")
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if health_check is not None:
            pulumi.set(__self__, "health_check", health_check)
        if http_port is not None:
            pulumi.set(__self__, "http_port", http_port)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if internal_ports is not None:
            pulumi.set(__self__, "internal_ports", internal_ports)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if routes is not None:
            warnings.warn("""Service level routes are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""routes is deprecated: Service level routes are deprecated in favor of ingresses""")
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter
    def autoscaling(self) -> Optional[pulumi.Input['AppSpecServiceAutoscalingArgs']]:
        """
        Configuration for automatically scaling this component based on metrics.
        """
        return pulumi.get(self, "autoscaling")

    @autoscaling.setter
    def autoscaling(self, value: Optional[pulumi.Input['AppSpecServiceAutoscalingArgs']]):
        pulumi.set(self, "autoscaling", value)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional[pulumi.Input['AppSpecServiceCorsArgs']]:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppSpecServiceCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dockerfile_path", value)

    @property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[pulumi.Input[str]]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @environment_slug.setter
    def environment_slug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment_slug", value)

    @property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecServiceGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecServiceGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecServiceGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecServiceGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecServiceGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecServiceGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @property
    @pulumi.getter(name="healthCheck")
    def health_check(self) -> Optional[pulumi.Input['AppSpecServiceHealthCheckArgs']]:
        """
        A health check to determine the availability of this component.
        """
        return pulumi.get(self, "health_check")

    @health_check.setter
    def health_check(self, value: Optional[pulumi.Input['AppSpecServiceHealthCheckArgs']]):
        pulumi.set(self, "health_check", value)

    @property
    @pulumi.getter(name="httpPort")
    def http_port(self) -> Optional[pulumi.Input[int]]:
        """
        The internal port on which this service's run command will listen.
        """
        return pulumi.get(self, "http_port")

    @http_port.setter
    def http_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "http_port", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['AppSpecServiceImageArgs']]:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['AppSpecServiceImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[pulumi.Input[str]]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @instance_size_slug.setter
    def instance_size_slug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_size_slug", value)

    @property
    @pulumi.getter(name="internalPorts")
    def internal_ports(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        A list of ports on which this service will listen for internal traffic.
        """
        return pulumi.get(self, "internal_ports")

    @internal_ports.setter
    def internal_ports(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "internal_ports", value)

    @property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgs']]]]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @log_destinations.setter
    def log_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceLogDestinationArgs']]]]):
        pulumi.set(self, "log_destinations", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgs']]]]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[pulumi.Input[str]]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @run_command.setter
    def run_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_command", value)

    @property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_dir", value)


if not MYPY:
    class AppSpecServiceAlertArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        rule: pulumi.Input[str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        value: pulumi.Input[float]
        """
        The threshold for the type of the warning.
        """
        window: pulumi.Input[str]
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecServiceAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAlertArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 rule: pulumi.Input[str],
                 value: pulumi.Input[float],
                 window: pulumi.Input[str],
                 disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param pulumi.Input[str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[float] value: The threshold for the type of the warning.
        :param pulumi.Input[str] window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param pulumi.Input[bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input[str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def window(self) -> pulumi.Input[str]:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[str]):
        pulumi.set(self, "window", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecServiceAutoscalingArgsDict(TypedDict):
        max_instance_count: pulumi.Input[int]
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        metrics: pulumi.Input['AppSpecServiceAutoscalingMetricsArgsDict']
        """
        The metrics that the component is scaled on.
        """
        min_instance_count: pulumi.Input[int]
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
elif False:
    AppSpecServiceAutoscalingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAutoscalingArgs:
    def __init__(__self__, *,
                 max_instance_count: pulumi.Input[int],
                 metrics: pulumi.Input['AppSpecServiceAutoscalingMetricsArgs'],
                 min_instance_count: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_instance_count: The maximum amount of instances for this component. Must be more than min_instance_count.
        :param pulumi.Input['AppSpecServiceAutoscalingMetricsArgs'] metrics: The metrics that the component is scaled on.
        :param pulumi.Input[int] min_instance_count: The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        pulumi.set(__self__, "max_instance_count", max_instance_count)
        pulumi.set(__self__, "metrics", metrics)
        pulumi.set(__self__, "min_instance_count", min_instance_count)

    @property
    @pulumi.getter(name="maxInstanceCount")
    def max_instance_count(self) -> pulumi.Input[int]:
        """
        The maximum amount of instances for this component. Must be more than min_instance_count.
        """
        return pulumi.get(self, "max_instance_count")

    @max_instance_count.setter
    def max_instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_instance_count", value)

    @property
    @pulumi.getter
    def metrics(self) -> pulumi.Input['AppSpecServiceAutoscalingMetricsArgs']:
        """
        The metrics that the component is scaled on.
        """
        return pulumi.get(self, "metrics")

    @metrics.setter
    def metrics(self, value: pulumi.Input['AppSpecServiceAutoscalingMetricsArgs']):
        pulumi.set(self, "metrics", value)

    @property
    @pulumi.getter(name="minInstanceCount")
    def min_instance_count(self) -> pulumi.Input[int]:
        """
        The minimum amount of instances for this component. Must be less than max_instance_count.
        """
        return pulumi.get(self, "min_instance_count")

    @min_instance_count.setter
    def min_instance_count(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_instance_count", value)


if not MYPY:
    class AppSpecServiceAutoscalingMetricsArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgsDict']]
        """
        Settings for scaling the component based on CPU utilization.
        """
elif False:
    AppSpecServiceAutoscalingMetricsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAutoscalingMetricsArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgs']] = None):
        """
        :param pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgs'] cpu: Settings for scaling the component based on CPU utilization.
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgs']]:
        """
        Settings for scaling the component based on CPU utilization.
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input['AppSpecServiceAutoscalingMetricsCpuArgs']]):
        pulumi.set(self, "cpu", value)


if not MYPY:
    class AppSpecServiceAutoscalingMetricsCpuArgsDict(TypedDict):
        percent: pulumi.Input[int]
        """
        The average target CPU utilization for the component.

        A `static_site` can contain:
        """
elif False:
    AppSpecServiceAutoscalingMetricsCpuArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceAutoscalingMetricsCpuArgs:
    def __init__(__self__, *,
                 percent: pulumi.Input[int]):
        """
        :param pulumi.Input[int] percent: The average target CPU utilization for the component.
               
               A `static_site` can contain:
        """
        pulumi.set(__self__, "percent", percent)

    @property
    @pulumi.getter
    def percent(self) -> pulumi.Input[int]:
        """
        The average target CPU utilization for the component.

        A `static_site` can contain:
        """
        return pulumi.get(self, "percent")

    @percent.setter
    def percent(self, value: pulumi.Input[int]):
        pulumi.set(self, "percent", value)


if not MYPY:
    class AppSpecServiceCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        allow_origins: NotRequired[pulumi.Input['AppSpecServiceCorsAllowOriginsArgsDict']]
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        max_age: NotRequired[pulumi.Input[str]]
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
elif False:
    AppSpecServiceCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input['AppSpecServiceCorsAllowOriginsArgs']] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param pulumi.Input['AppSpecServiceCorsAllowOriginsArgs'] allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param pulumi.Input[str] max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input['AppSpecServiceCorsAllowOriginsArgs']]:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input['AppSpecServiceCorsAllowOriginsArgs']]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[str]]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AppSpecServiceCorsAllowOriginsArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Exact string match.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix-based match.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        RE2 style regex-based match.
        """
elif False:
    AppSpecServiceCorsAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceCorsAllowOriginsArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Exact string match.
        :param pulumi.Input[str] prefix: Prefix-based match.
        :param pulumi.Input[str] regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            warnings.warn("""Prefix-based matching has been deprecated in favor of regex-based matching.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Prefix-based matching has been deprecated in favor of regex-based matching.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AppSpecServiceEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecServiceEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The name of the environment variable.
        :param pulumi.Input[str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecServiceGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecServiceGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 repo_clone_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecServiceGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecServiceGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecServiceGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecServiceGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecServiceHealthCheckArgsDict(TypedDict):
        failure_threshold: NotRequired[pulumi.Input[int]]
        """
        The number of failed health checks before considered unhealthy.
        """
        http_path: NotRequired[pulumi.Input[str]]
        """
        The route path used for the HTTP health check ping.
        """
        initial_delay_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait before beginning health checks.
        """
        period_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds to wait between health checks.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        The health check will be performed on this port instead of component's HTTP port.
        """
        success_threshold: NotRequired[pulumi.Input[int]]
        """
        The number of successful health checks before considered healthy.
        """
        timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds after which the check times out.
        """
elif False:
    AppSpecServiceHealthCheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceHealthCheckArgs:
    def __init__(__self__, *,
                 failure_threshold: Optional[pulumi.Input[int]] = None,
                 http_path: Optional[pulumi.Input[str]] = None,
                 initial_delay_seconds: Optional[pulumi.Input[int]] = None,
                 period_seconds: Optional[pulumi.Input[int]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 success_threshold: Optional[pulumi.Input[int]] = None,
                 timeout_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] failure_threshold: The number of failed health checks before considered unhealthy.
        :param pulumi.Input[str] http_path: The route path used for the HTTP health check ping.
        :param pulumi.Input[int] initial_delay_seconds: The number of seconds to wait before beginning health checks.
        :param pulumi.Input[int] period_seconds: The number of seconds to wait between health checks.
        :param pulumi.Input[int] port: The health check will be performed on this port instead of component's HTTP port.
        :param pulumi.Input[int] success_threshold: The number of successful health checks before considered healthy.
        :param pulumi.Input[int] timeout_seconds: The number of seconds after which the check times out.
        """
        if failure_threshold is not None:
            pulumi.set(__self__, "failure_threshold", failure_threshold)
        if http_path is not None:
            pulumi.set(__self__, "http_path", http_path)
        if initial_delay_seconds is not None:
            pulumi.set(__self__, "initial_delay_seconds", initial_delay_seconds)
        if period_seconds is not None:
            pulumi.set(__self__, "period_seconds", period_seconds)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if success_threshold is not None:
            pulumi.set(__self__, "success_threshold", success_threshold)
        if timeout_seconds is not None:
            pulumi.set(__self__, "timeout_seconds", timeout_seconds)

    @property
    @pulumi.getter(name="failureThreshold")
    def failure_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of failed health checks before considered unhealthy.
        """
        return pulumi.get(self, "failure_threshold")

    @failure_threshold.setter
    def failure_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failure_threshold", value)

    @property
    @pulumi.getter(name="httpPath")
    def http_path(self) -> Optional[pulumi.Input[str]]:
        """
        The route path used for the HTTP health check ping.
        """
        return pulumi.get(self, "http_path")

    @http_path.setter
    def http_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "http_path", value)

    @property
    @pulumi.getter(name="initialDelaySeconds")
    def initial_delay_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait before beginning health checks.
        """
        return pulumi.get(self, "initial_delay_seconds")

    @initial_delay_seconds.setter
    def initial_delay_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "initial_delay_seconds", value)

    @property
    @pulumi.getter(name="periodSeconds")
    def period_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds to wait between health checks.
        """
        return pulumi.get(self, "period_seconds")

    @period_seconds.setter
    def period_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "period_seconds", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        The health check will be performed on this port instead of component's HTTP port.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="successThreshold")
    def success_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of successful health checks before considered healthy.
        """
        return pulumi.get(self, "success_threshold")

    @success_threshold.setter
    def success_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "success_threshold", value)

    @property
    @pulumi.getter(name="timeoutSeconds")
    def timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds after which the check times out.
        """
        return pulumi.get(self, "timeout_seconds")

    @timeout_seconds.setter
    def timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "timeout_seconds", value)


if not MYPY:
    class AppSpecServiceImageArgsDict(TypedDict):
        registry_type: pulumi.Input[str]
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        repository: pulumi.Input[str]
        """
        The repository name.
        """
        deploy_on_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgsDict']]]]
        """
        Configures automatically deploying images pushed to DOCR.
        """
        registry: NotRequired[pulumi.Input[str]]
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        registry_credentials: NotRequired[pulumi.Input[str]]
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        tag: NotRequired[pulumi.Input[str]]
        """
        The repository tag. Defaults to `latest` if not provided.
        """
elif False:
    AppSpecServiceImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceImageArgs:
    def __init__(__self__, *,
                 registry_type: pulumi.Input[str],
                 repository: pulumi.Input[str],
                 deploy_on_pushes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgs']]]] = None,
                 registry: Optional[pulumi.Input[str]] = None,
                 registry_credentials: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param pulumi.Input[str] repository: The repository name.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgs']]] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param pulumi.Input[str] registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param pulumi.Input[str] registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param pulumi.Input[str] tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> pulumi.Input[str]:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @registry_type.setter
    def registry_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_type", value)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[str]:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgs']]]]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @deploy_on_pushes.setter
    def deploy_on_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecServiceImageDeployOnPushArgs']]]]):
        pulumi.set(self, "deploy_on_pushes", value)

    @property
    @pulumi.getter
    def registry(self) -> Optional[pulumi.Input[str]]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry", value)

    @property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @registry_credentials.setter
    def registry_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_credentials", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class AppSpecServiceImageDeployOnPushArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy images pushed to DOCR.
        """
elif False:
    AppSpecServiceImageDeployOnPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceImageDeployOnPushArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AppSpecServiceLogDestinationArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        datadog: NotRequired[pulumi.Input['AppSpecServiceLogDestinationDatadogArgsDict']]
        """
        Datadog configuration.
        """
        logtail: NotRequired[pulumi.Input['AppSpecServiceLogDestinationLogtailArgsDict']]
        """
        Logtail configuration.
        """
        open_search: NotRequired[pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgsDict']]
        """
        OpenSearch configuration.
        """
        papertrail: NotRequired[pulumi.Input['AppSpecServiceLogDestinationPapertrailArgsDict']]
        """
        Papertrail configuration.
        """
elif False:
    AppSpecServiceLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 datadog: Optional[pulumi.Input['AppSpecServiceLogDestinationDatadogArgs']] = None,
                 logtail: Optional[pulumi.Input['AppSpecServiceLogDestinationLogtailArgs']] = None,
                 open_search: Optional[pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgs']] = None,
                 papertrail: Optional[pulumi.Input['AppSpecServiceLogDestinationPapertrailArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param pulumi.Input['AppSpecServiceLogDestinationDatadogArgs'] datadog: Datadog configuration.
        :param pulumi.Input['AppSpecServiceLogDestinationLogtailArgs'] logtail: Logtail configuration.
        :param pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgs'] open_search: OpenSearch configuration.
        :param pulumi.Input['AppSpecServiceLogDestinationPapertrailArgs'] papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def datadog(self) -> Optional[pulumi.Input['AppSpecServiceLogDestinationDatadogArgs']]:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @datadog.setter
    def datadog(self, value: Optional[pulumi.Input['AppSpecServiceLogDestinationDatadogArgs']]):
        pulumi.set(self, "datadog", value)

    @property
    @pulumi.getter
    def logtail(self) -> Optional[pulumi.Input['AppSpecServiceLogDestinationLogtailArgs']]:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @logtail.setter
    def logtail(self, value: Optional[pulumi.Input['AppSpecServiceLogDestinationLogtailArgs']]):
        pulumi.set(self, "logtail", value)

    @property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgs']]:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['AppSpecServiceLogDestinationOpenSearchArgs']]):
        pulumi.set(self, "open_search", value)

    @property
    @pulumi.getter
    def papertrail(self) -> Optional[pulumi.Input['AppSpecServiceLogDestinationPapertrailArgs']]:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")

    @papertrail.setter
    def papertrail(self, value: Optional[pulumi.Input['AppSpecServiceLogDestinationPapertrailArgs']]):
        pulumi.set(self, "papertrail", value)


if not MYPY:
    class AppSpecServiceLogDestinationDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        """
        Datadog API key.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        Datadog HTTP log intake endpoint.
        """
elif False:
    AppSpecServiceLogDestinationDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Datadog API key.
        :param pulumi.Input[str] endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecServiceLogDestinationLogtailArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Logtail token.
        """
elif False:
    AppSpecServiceLogDestinationLogtailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationLogtailArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppSpecServiceLogDestinationOpenSearchArgsDict(TypedDict):
        basic_auth: pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgsDict']
        """
        Basic authentication details.
        """
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        OpenSearch endpoint.
        """
        index_name: NotRequired[pulumi.Input[str]]
        """
        OpenSearch index name.
        """
elif False:
    AppSpecServiceLogDestinationOpenSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationOpenSearchArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgs'],
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 index_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgs'] basic_auth: Basic authentication details.
        :param pulumi.Input[str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[str] endpoint: OpenSearch endpoint.
        :param pulumi.Input[str] index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgs']:
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input['AppSpecServiceLogDestinationOpenSearchBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class AppSpecServiceLogDestinationOpenSearchBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        Password for basic authentication.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        user for basic authentication.
        """
elif False:
    AppSpecServiceLogDestinationOpenSearchBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationOpenSearchBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Password for basic authentication.
        :param pulumi.Input[str] user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AppSpecServiceLogDestinationPapertrailArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        Papertrail syslog endpoint.
        """
elif False:
    AppSpecServiceLogDestinationPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceLogDestinationPapertrailArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecServiceRouteArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
        """
        Paths must start with `/` and must be unique within the app.
        """
        preserve_path_prefix: NotRequired[pulumi.Input[bool]]
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
elif False:
    AppSpecServiceRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecServiceRouteArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 preserve_path_prefix: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] path: Paths must start with `/` and must be unique within the app.
        :param pulumi.Input[bool] preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[pulumi.Input[bool]]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @preserve_path_prefix.setter
    def preserve_path_prefix(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_path_prefix", value)


if not MYPY:
    class AppSpecStaticSiteArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the component.
        """
        build_command: NotRequired[pulumi.Input[str]]
        """
        An optional build command to run while building this component from source.
        """
        catchall_document: NotRequired[pulumi.Input[str]]
        """
        The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        """
        cors: NotRequired[pulumi.Input['AppSpecStaticSiteCorsArgsDict']]
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        dockerfile_path: NotRequired[pulumi.Input[str]]
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        environment_slug: NotRequired[pulumi.Input[str]]
        """
        An environment slug describing the type of this app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        error_document: NotRequired[pulumi.Input[str]]
        """
        The name of the error document to use when serving this static site.
        """
        git: NotRequired[pulumi.Input['AppSpecStaticSiteGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecStaticSiteGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecStaticSiteGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        index_document: NotRequired[pulumi.Input[str]]
        """
        The name of the index document to use when serving this static site.
        """
        output_dir: NotRequired[pulumi.Input[str]]
        """
        An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        """
        routes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgsDict']]]]
        """
        An HTTP paths that should be routed to this component.
        """
        source_dir: NotRequired[pulumi.Input[str]]
        """
        An optional path to the working directory to use for the build.
        """
elif False:
    AppSpecStaticSiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 build_command: Optional[pulumi.Input[str]] = None,
                 catchall_document: Optional[pulumi.Input[str]] = None,
                 cors: Optional[pulumi.Input['AppSpecStaticSiteCorsArgs']] = None,
                 dockerfile_path: Optional[pulumi.Input[str]] = None,
                 environment_slug: Optional[pulumi.Input[str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgs']]]] = None,
                 error_document: Optional[pulumi.Input[str]] = None,
                 git: Optional[pulumi.Input['AppSpecStaticSiteGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecStaticSiteGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecStaticSiteGitlabArgs']] = None,
                 index_document: Optional[pulumi.Input[str]] = None,
                 output_dir: Optional[pulumi.Input[str]] = None,
                 routes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgs']]]] = None,
                 source_dir: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the component.
        :param pulumi.Input[str] build_command: An optional build command to run while building this component from source.
        :param pulumi.Input[str] catchall_document: The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        :param pulumi.Input['AppSpecStaticSiteCorsArgs'] cors: The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        :param pulumi.Input[str] dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param pulumi.Input[str] environment_slug: An environment slug describing the type of this app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input[str] error_document: The name of the error document to use when serving this static site.
        :param pulumi.Input['AppSpecStaticSiteGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecStaticSiteGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecStaticSiteGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[str] index_document: The name of the index document to use when serving this static site.
        :param pulumi.Input[str] output_dir: An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgs']]] routes: An HTTP paths that should be routed to this component.
        :param pulumi.Input[str] source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if catchall_document is not None:
            pulumi.set(__self__, "catchall_document", catchall_document)
        if cors is not None:
            warnings.warn("""Service level CORS rules are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""cors is deprecated: Service level CORS rules are deprecated in favor of ingresses""")
        if cors is not None:
            pulumi.set(__self__, "cors", cors)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if error_document is not None:
            pulumi.set(__self__, "error_document", error_document)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if index_document is not None:
            pulumi.set(__self__, "index_document", index_document)
        if output_dir is not None:
            pulumi.set(__self__, "output_dir", output_dir)
        if routes is not None:
            warnings.warn("""Service level routes are deprecated in favor of ingresses""", DeprecationWarning)
            pulumi.log.warn("""routes is deprecated: Service level routes are deprecated in favor of ingresses""")
        if routes is not None:
            pulumi.set(__self__, "routes", routes)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter(name="catchallDocument")
    def catchall_document(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the document to use as the fallback for any requests to documents that are not found when serving this static site.
        """
        return pulumi.get(self, "catchall_document")

    @catchall_document.setter
    def catchall_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "catchall_document", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Service level CORS rules are deprecated in favor of ingresses""")
    def cors(self) -> Optional[pulumi.Input['AppSpecStaticSiteCorsArgs']]:
        """
        The [CORS](https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS) policies of the app.
        """
        return pulumi.get(self, "cors")

    @cors.setter
    def cors(self, value: Optional[pulumi.Input['AppSpecStaticSiteCorsArgs']]):
        pulumi.set(self, "cors", value)

    @property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dockerfile_path", value)

    @property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[pulumi.Input[str]]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @environment_slug.setter
    def environment_slug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment_slug", value)

    @property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @property
    @pulumi.getter(name="errorDocument")
    def error_document(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the error document to use when serving this static site.
        """
        return pulumi.get(self, "error_document")

    @error_document.setter
    def error_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_document", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecStaticSiteGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecStaticSiteGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecStaticSiteGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecStaticSiteGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecStaticSiteGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecStaticSiteGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @property
    @pulumi.getter(name="indexDocument")
    def index_document(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the index document to use when serving this static site.
        """
        return pulumi.get(self, "index_document")

    @index_document.setter
    def index_document(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_document", value)

    @property
    @pulumi.getter(name="outputDir")
    def output_dir(self) -> Optional[pulumi.Input[str]]:
        """
        An optional path to where the built assets will be located, relative to the build context. If not set, App Platform will automatically scan for these directory names: `_static`, `dist`, `public`.
        """
        return pulumi.get(self, "output_dir")

    @output_dir.setter
    def output_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_dir", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Service level routes are deprecated in favor of ingresses""")
    def routes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgs']]]]:
        """
        An HTTP paths that should be routed to this component.
        """
        return pulumi.get(self, "routes")

    @routes.setter
    def routes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecStaticSiteRouteArgs']]]]):
        pulumi.set(self, "routes", value)

    @property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_dir", value)


if not MYPY:
    class AppSpecStaticSiteCorsArgsDict(TypedDict):
        allow_credentials: NotRequired[pulumi.Input[bool]]
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        allow_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        allow_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        allow_origins: NotRequired[pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgsDict']]
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        max_age: NotRequired[pulumi.Input[str]]
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
elif False:
    AppSpecStaticSiteCorsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteCorsArgs:
    def __init__(__self__, *,
                 allow_credentials: Optional[pulumi.Input[bool]] = None,
                 allow_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_methods: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 allow_origins: Optional[pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgs']] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_credentials: Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_headers: The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allow_methods: The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        :param pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgs'] allow_origins: The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        :param pulumi.Input[str] max_age: An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        if allow_credentials is not None:
            pulumi.set(__self__, "allow_credentials", allow_credentials)
        if allow_headers is not None:
            pulumi.set(__self__, "allow_headers", allow_headers)
        if allow_methods is not None:
            pulumi.set(__self__, "allow_methods", allow_methods)
        if allow_origins is not None:
            pulumi.set(__self__, "allow_origins", allow_origins)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if max_age is not None:
            pulumi.set(__self__, "max_age", max_age)

    @property
    @pulumi.getter(name="allowCredentials")
    def allow_credentials(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether browsers should expose the response to the client-side JavaScript code when the requests credentials mode is `include`. This configures the Access-Control-Allow-Credentials header.
        """
        return pulumi.get(self, "allow_credentials")

    @allow_credentials.setter
    def allow_credentials(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_credentials", value)

    @property
    @pulumi.getter(name="allowHeaders")
    def allow_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of allowed HTTP request headers. This configures the Access-Control-Allow-Headers header.
        """
        return pulumi.get(self, "allow_headers")

    @allow_headers.setter
    def allow_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_headers", value)

    @property
    @pulumi.getter(name="allowMethods")
    def allow_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of allowed HTTP methods. This configures the Access-Control-Allow-Methods header.
        """
        return pulumi.get(self, "allow_methods")

    @allow_methods.setter
    def allow_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allow_methods", value)

    @property
    @pulumi.getter(name="allowOrigins")
    def allow_origins(self) -> Optional[pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgs']]:
        """
        The set of allowed CORS origins. This configures the Access-Control-Allow-Origin header.
        """
        return pulumi.get(self, "allow_origins")

    @allow_origins.setter
    def allow_origins(self, value: Optional[pulumi.Input['AppSpecStaticSiteCorsAllowOriginsArgs']]):
        pulumi.set(self, "allow_origins", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The set of HTTP response headers that browsers are allowed to access. This configures the Access-Control-Expose-Headers header.
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter(name="maxAge")
    def max_age(self) -> Optional[pulumi.Input[str]]:
        """
        An optional duration specifying how long browsers can cache the results of a preflight request. This configures the Access-Control-Max-Age header. Example: `5h30m`.
        """
        return pulumi.get(self, "max_age")

    @max_age.setter
    def max_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_age", value)


if not MYPY:
    class AppSpecStaticSiteCorsAllowOriginsArgsDict(TypedDict):
        exact: NotRequired[pulumi.Input[str]]
        """
        Exact string match.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Prefix-based match.
        """
        regex: NotRequired[pulumi.Input[str]]
        """
        RE2 style regex-based match.
        """
elif False:
    AppSpecStaticSiteCorsAllowOriginsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteCorsAllowOriginsArgs:
    def __init__(__self__, *,
                 exact: Optional[pulumi.Input[str]] = None,
                 prefix: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] exact: Exact string match.
        :param pulumi.Input[str] prefix: Prefix-based match.
        :param pulumi.Input[str] regex: RE2 style regex-based match.
        """
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if prefix is not None:
            warnings.warn("""Prefix-based matching has been deprecated in favor of regex-based matching.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: Prefix-based matching has been deprecated in favor of regex-based matching.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[str]]:
        """
        Exact string match.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exact", value)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Prefix-based matching has been deprecated in favor of regex-based matching.""")
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Prefix-based match.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input[str]]:
        """
        RE2 style regex-based match.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class AppSpecStaticSiteEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecStaticSiteEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The name of the environment variable.
        :param pulumi.Input[str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecStaticSiteGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecStaticSiteGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 repo_clone_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecStaticSiteGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecStaticSiteGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecStaticSiteGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecStaticSiteGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecStaticSiteRouteArgsDict(TypedDict):
        path: NotRequired[pulumi.Input[str]]
        """
        Paths must start with `/` and must be unique within the app.
        """
        preserve_path_prefix: NotRequired[pulumi.Input[bool]]
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
elif False:
    AppSpecStaticSiteRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecStaticSiteRouteArgs:
    def __init__(__self__, *,
                 path: Optional[pulumi.Input[str]] = None,
                 preserve_path_prefix: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] path: Paths must start with `/` and must be unique within the app.
        :param pulumi.Input[bool] preserve_path_prefix: An optional flag to preserve the path that is forwarded to the backend service.
        """
        if path is not None:
            pulumi.set(__self__, "path", path)
        if preserve_path_prefix is not None:
            pulumi.set(__self__, "preserve_path_prefix", preserve_path_prefix)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Paths must start with `/` and must be unique within the app.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="preservePathPrefix")
    def preserve_path_prefix(self) -> Optional[pulumi.Input[bool]]:
        """
        An optional flag to preserve the path that is forwarded to the backend service.
        """
        return pulumi.get(self, "preserve_path_prefix")

    @preserve_path_prefix.setter
    def preserve_path_prefix(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preserve_path_prefix", value)


if not MYPY:
    class AppSpecWorkerArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the component.
        """
        alerts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgsDict']]]]
        """
        Describes an alert policy for the component.
        """
        build_command: NotRequired[pulumi.Input[str]]
        """
        An optional build command to run while building this component from source.
        """
        dockerfile_path: NotRequired[pulumi.Input[str]]
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        environment_slug: NotRequired[pulumi.Input[str]]
        """
        An environment slug describing the type of this app.
        """
        envs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgsDict']]]]
        """
        Describes an environment variable made available to an app competent.
        """
        git: NotRequired[pulumi.Input['AppSpecWorkerGitArgsDict']]
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        github: NotRequired[pulumi.Input['AppSpecWorkerGithubArgsDict']]
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        gitlab: NotRequired[pulumi.Input['AppSpecWorkerGitlabArgsDict']]
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        image: NotRequired[pulumi.Input['AppSpecWorkerImageArgsDict']]
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        instance_count: NotRequired[pulumi.Input[int]]
        """
        The amount of instances that this component should be scaled to.
        """
        instance_size_slug: NotRequired[pulumi.Input[str]]
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        log_destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgsDict']]]]
        """
        Describes a log forwarding destination.
        """
        run_command: NotRequired[pulumi.Input[str]]
        """
        An optional run command to override the component's default.
        """
        source_dir: NotRequired[pulumi.Input[str]]
        """
        An optional path to the working directory to use for the build.
        """
elif False:
    AppSpecWorkerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 alerts: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgs']]]] = None,
                 build_command: Optional[pulumi.Input[str]] = None,
                 dockerfile_path: Optional[pulumi.Input[str]] = None,
                 environment_slug: Optional[pulumi.Input[str]] = None,
                 envs: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgs']]]] = None,
                 git: Optional[pulumi.Input['AppSpecWorkerGitArgs']] = None,
                 github: Optional[pulumi.Input['AppSpecWorkerGithubArgs']] = None,
                 gitlab: Optional[pulumi.Input['AppSpecWorkerGitlabArgs']] = None,
                 image: Optional[pulumi.Input['AppSpecWorkerImageArgs']] = None,
                 instance_count: Optional[pulumi.Input[int]] = None,
                 instance_size_slug: Optional[pulumi.Input[str]] = None,
                 log_destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgs']]]] = None,
                 run_command: Optional[pulumi.Input[str]] = None,
                 source_dir: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: The name of the component.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgs']]] alerts: Describes an alert policy for the component.
        :param pulumi.Input[str] build_command: An optional build command to run while building this component from source.
        :param pulumi.Input[str] dockerfile_path: The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        :param pulumi.Input[str] environment_slug: An environment slug describing the type of this app.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgs']]] envs: Describes an environment variable made available to an app competent.
        :param pulumi.Input['AppSpecWorkerGitArgs'] git: A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        :param pulumi.Input['AppSpecWorkerGithubArgs'] github: A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecWorkerGitlabArgs'] gitlab: A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input['AppSpecWorkerImageArgs'] image: An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        :param pulumi.Input[int] instance_count: The amount of instances that this component should be scaled to.
        :param pulumi.Input[str] instance_size_slug: The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgs']]] log_destinations: Describes a log forwarding destination.
        :param pulumi.Input[str] run_command: An optional run command to override the component's default.
        :param pulumi.Input[str] source_dir: An optional path to the working directory to use for the build.
        """
        pulumi.set(__self__, "name", name)
        if alerts is not None:
            pulumi.set(__self__, "alerts", alerts)
        if build_command is not None:
            pulumi.set(__self__, "build_command", build_command)
        if dockerfile_path is not None:
            pulumi.set(__self__, "dockerfile_path", dockerfile_path)
        if environment_slug is not None:
            pulumi.set(__self__, "environment_slug", environment_slug)
        if envs is not None:
            pulumi.set(__self__, "envs", envs)
        if git is not None:
            pulumi.set(__self__, "git", git)
        if github is not None:
            pulumi.set(__self__, "github", github)
        if gitlab is not None:
            pulumi.set(__self__, "gitlab", gitlab)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if instance_count is not None:
            pulumi.set(__self__, "instance_count", instance_count)
        if instance_size_slug is not None:
            pulumi.set(__self__, "instance_size_slug", instance_size_slug)
        if log_destinations is not None:
            pulumi.set(__self__, "log_destinations", log_destinations)
        if run_command is not None:
            pulumi.set(__self__, "run_command", run_command)
        if source_dir is not None:
            pulumi.set(__self__, "source_dir", source_dir)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the component.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def alerts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgs']]]]:
        """
        Describes an alert policy for the component.
        """
        return pulumi.get(self, "alerts")

    @alerts.setter
    def alerts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerAlertArgs']]]]):
        pulumi.set(self, "alerts", value)

    @property
    @pulumi.getter(name="buildCommand")
    def build_command(self) -> Optional[pulumi.Input[str]]:
        """
        An optional build command to run while building this component from source.
        """
        return pulumi.get(self, "build_command")

    @build_command.setter
    def build_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "build_command", value)

    @property
    @pulumi.getter(name="dockerfilePath")
    def dockerfile_path(self) -> Optional[pulumi.Input[str]]:
        """
        The path to a Dockerfile relative to the root of the repo. If set, overrides usage of buildpacks.
        """
        return pulumi.get(self, "dockerfile_path")

    @dockerfile_path.setter
    def dockerfile_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dockerfile_path", value)

    @property
    @pulumi.getter(name="environmentSlug")
    def environment_slug(self) -> Optional[pulumi.Input[str]]:
        """
        An environment slug describing the type of this app.
        """
        return pulumi.get(self, "environment_slug")

    @environment_slug.setter
    def environment_slug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "environment_slug", value)

    @property
    @pulumi.getter
    def envs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgs']]]]:
        """
        Describes an environment variable made available to an app competent.
        """
        return pulumi.get(self, "envs")

    @envs.setter
    def envs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerEnvArgs']]]]):
        pulumi.set(self, "envs", value)

    @property
    @pulumi.getter
    def git(self) -> Optional[pulumi.Input['AppSpecWorkerGitArgs']]:
        """
        A Git repo to use as the component's source. The repository must be able to be cloned without authentication. Only one of `git`, `github` or `gitlab` may be set.
        """
        return pulumi.get(self, "git")

    @git.setter
    def git(self, value: Optional[pulumi.Input['AppSpecWorkerGitArgs']]):
        pulumi.set(self, "git", value)

    @property
    @pulumi.getter
    def github(self) -> Optional[pulumi.Input['AppSpecWorkerGithubArgs']]:
        """
        A GitHub repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/github/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "github")

    @github.setter
    def github(self, value: Optional[pulumi.Input['AppSpecWorkerGithubArgs']]):
        pulumi.set(self, "github", value)

    @property
    @pulumi.getter
    def gitlab(self) -> Optional[pulumi.Input['AppSpecWorkerGitlabArgs']]:
        """
        A Gitlab repo to use as the component's source. DigitalOcean App Platform must have [access to the repository](https://cloud.digitalocean.com/apps/gitlab/install). Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "gitlab")

    @gitlab.setter
    def gitlab(self, value: Optional[pulumi.Input['AppSpecWorkerGitlabArgs']]):
        pulumi.set(self, "gitlab", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['AppSpecWorkerImageArgs']]:
        """
        An image to use as the component's source. Only one of `git`, `github`, `gitlab`, or `image` may be set.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['AppSpecWorkerImageArgs']]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter(name="instanceCount")
    def instance_count(self) -> Optional[pulumi.Input[int]]:
        """
        The amount of instances that this component should be scaled to.
        """
        return pulumi.get(self, "instance_count")

    @instance_count.setter
    def instance_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "instance_count", value)

    @property
    @pulumi.getter(name="instanceSizeSlug")
    def instance_size_slug(self) -> Optional[pulumi.Input[str]]:
        """
        The instance size to use for this component. This determines the plan (basic or professional) and the available CPU and memory. The list of available instance sizes can be [found with the API](https://docs.digitalocean.com/reference/api/api-reference/#operation/list_instance_sizes) or using the [doctl CLI](https://docs.digitalocean.com/reference/doctl/) (`doctl apps tier instance-size list`). Default: `basic-xxs`
        """
        return pulumi.get(self, "instance_size_slug")

    @instance_size_slug.setter
    def instance_size_slug(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_size_slug", value)

    @property
    @pulumi.getter(name="logDestinations")
    def log_destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgs']]]]:
        """
        Describes a log forwarding destination.
        """
        return pulumi.get(self, "log_destinations")

    @log_destinations.setter
    def log_destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerLogDestinationArgs']]]]):
        pulumi.set(self, "log_destinations", value)

    @property
    @pulumi.getter(name="runCommand")
    def run_command(self) -> Optional[pulumi.Input[str]]:
        """
        An optional run command to override the component's default.
        """
        return pulumi.get(self, "run_command")

    @run_command.setter
    def run_command(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "run_command", value)

    @property
    @pulumi.getter(name="sourceDir")
    def source_dir(self) -> Optional[pulumi.Input[str]]:
        """
        An optional path to the working directory to use for the build.
        """
        return pulumi.get(self, "source_dir")

    @source_dir.setter
    def source_dir(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_dir", value)


if not MYPY:
    class AppSpecWorkerAlertArgsDict(TypedDict):
        operator: pulumi.Input[str]
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        rule: pulumi.Input[str]
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        value: pulumi.Input[float]
        """
        The threshold for the type of the warning.
        """
        window: pulumi.Input[str]
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        disabled: NotRequired[pulumi.Input[bool]]
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
elif False:
    AppSpecWorkerAlertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerAlertArgs:
    def __init__(__self__, *,
                 operator: pulumi.Input[str],
                 rule: pulumi.Input[str],
                 value: pulumi.Input[float],
                 window: pulumi.Input[str],
                 disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] operator: The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        :param pulumi.Input[str] rule: The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        :param pulumi.Input[float] value: The threshold for the type of the warning.
        :param pulumi.Input[str] window: The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        :param pulumi.Input[bool] disabled: Determines whether or not the alert is disabled (default: `false`).
        """
        pulumi.set(__self__, "operator", operator)
        pulumi.set(__self__, "rule", rule)
        pulumi.set(__self__, "value", value)
        pulumi.set(__self__, "window", window)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        The operator to use. This is either of `GREATER_THAN` or `LESS_THAN`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def rule(self) -> pulumi.Input[str]:
        """
        The type of the alert to configure. Component app alert policies can be: `CPU_UTILIZATION`, `MEM_UTILIZATION`, or `RESTART_COUNT`.
        """
        return pulumi.get(self, "rule")

    @rule.setter
    def rule(self, value: pulumi.Input[str]):
        pulumi.set(self, "rule", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[float]:
        """
        The threshold for the type of the warning.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[float]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def window(self) -> pulumi.Input[str]:
        """
        The time before alerts should be triggered. This is may be one of: `FIVE_MINUTES`, `TEN_MINUTES`, `THIRTY_MINUTES`, `ONE_HOUR`.
        """
        return pulumi.get(self, "window")

    @window.setter
    def window(self, value: pulumi.Input[str]):
        pulumi.set(self, "window", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether or not the alert is disabled (default: `false`).
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AppSpecWorkerEnvArgsDict(TypedDict):
        key: NotRequired[pulumi.Input[str]]
        """
        The name of the environment variable.
        """
        scope: NotRequired[pulumi.Input[str]]
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        value: NotRequired[pulumi.Input[str]]
        """
        The value of the environment variable.
        """
elif False:
    AppSpecWorkerEnvArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerEnvArgs:
    def __init__(__self__, *,
                 key: Optional[pulumi.Input[str]] = None,
                 scope: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: The name of the environment variable.
        :param pulumi.Input[str] scope: The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        :param pulumi.Input[str] type: The type of the environment variable, `GENERAL` or `SECRET`.
        :param pulumi.Input[str] value: The value of the environment variable.
        """
        if key is not None:
            pulumi.set(__self__, "key", key)
        if scope is not None:
            pulumi.set(__self__, "scope", scope)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def scope(self) -> Optional[pulumi.Input[str]]:
        """
        The visibility scope of the environment variable. One of `RUN_TIME`, `BUILD_TIME`, or `RUN_AND_BUILD_TIME` (default).
        """
        return pulumi.get(self, "scope")

    @scope.setter
    def scope(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scope", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type of the environment variable, `GENERAL` or `SECRET`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        The value of the environment variable.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AppSpecWorkerGitArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        repo_clone_url: NotRequired[pulumi.Input[str]]
        """
        The clone URL of the repo.
        """
elif False:
    AppSpecWorkerGitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerGitArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 repo_clone_url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[str] repo_clone_url: The clone URL of the repo.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if repo_clone_url is not None:
            pulumi.set(__self__, "repo_clone_url", repo_clone_url)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="repoCloneUrl")
    def repo_clone_url(self) -> Optional[pulumi.Input[str]]:
        """
        The clone URL of the repo.
        """
        return pulumi.get(self, "repo_clone_url")

    @repo_clone_url.setter
    def repo_clone_url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo_clone_url", value)


if not MYPY:
    class AppSpecWorkerGithubArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecWorkerGithubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerGithubArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecWorkerGitlabArgsDict(TypedDict):
        branch: NotRequired[pulumi.Input[str]]
        """
        The name of the branch to use.
        """
        deploy_on_push: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy new commits made to the repo.
        """
        repo: NotRequired[pulumi.Input[str]]
        """
        The name of the repo in the format `owner/repo`.
        """
elif False:
    AppSpecWorkerGitlabArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerGitlabArgs:
    def __init__(__self__, *,
                 branch: Optional[pulumi.Input[str]] = None,
                 deploy_on_push: Optional[pulumi.Input[bool]] = None,
                 repo: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] branch: The name of the branch to use.
        :param pulumi.Input[bool] deploy_on_push: Whether to automatically deploy new commits made to the repo.
        :param pulumi.Input[str] repo: The name of the repo in the format `owner/repo`.
        """
        if branch is not None:
            pulumi.set(__self__, "branch", branch)
        if deploy_on_push is not None:
            pulumi.set(__self__, "deploy_on_push", deploy_on_push)
        if repo is not None:
            pulumi.set(__self__, "repo", repo)

    @property
    @pulumi.getter
    def branch(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the branch to use.
        """
        return pulumi.get(self, "branch")

    @branch.setter
    def branch(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "branch", value)

    @property
    @pulumi.getter(name="deployOnPush")
    def deploy_on_push(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy new commits made to the repo.
        """
        return pulumi.get(self, "deploy_on_push")

    @deploy_on_push.setter
    def deploy_on_push(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "deploy_on_push", value)

    @property
    @pulumi.getter
    def repo(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the repo in the format `owner/repo`.
        """
        return pulumi.get(self, "repo")

    @repo.setter
    def repo(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "repo", value)


if not MYPY:
    class AppSpecWorkerImageArgsDict(TypedDict):
        registry_type: pulumi.Input[str]
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        repository: pulumi.Input[str]
        """
        The repository name.
        """
        deploy_on_pushes: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgsDict']]]]
        """
        Configures automatically deploying images pushed to DOCR.
        """
        registry: NotRequired[pulumi.Input[str]]
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        registry_credentials: NotRequired[pulumi.Input[str]]
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        tag: NotRequired[pulumi.Input[str]]
        """
        The repository tag. Defaults to `latest` if not provided.
        """
elif False:
    AppSpecWorkerImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerImageArgs:
    def __init__(__self__, *,
                 registry_type: pulumi.Input[str],
                 repository: pulumi.Input[str],
                 deploy_on_pushes: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgs']]]] = None,
                 registry: Optional[pulumi.Input[str]] = None,
                 registry_credentials: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] registry_type: The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        :param pulumi.Input[str] repository: The repository name.
        :param pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgs']]] deploy_on_pushes: Configures automatically deploying images pushed to DOCR.
        :param pulumi.Input[str] registry: The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        :param pulumi.Input[str] registry_credentials: The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        :param pulumi.Input[str] tag: The repository tag. Defaults to `latest` if not provided.
        """
        pulumi.set(__self__, "registry_type", registry_type)
        pulumi.set(__self__, "repository", repository)
        if deploy_on_pushes is not None:
            pulumi.set(__self__, "deploy_on_pushes", deploy_on_pushes)
        if registry is not None:
            pulumi.set(__self__, "registry", registry)
        if registry_credentials is not None:
            pulumi.set(__self__, "registry_credentials", registry_credentials)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="registryType")
    def registry_type(self) -> pulumi.Input[str]:
        """
        The registry type. One of `DOCR` (DigitalOcean container registry) or `DOCKER_HUB`.
        """
        return pulumi.get(self, "registry_type")

    @registry_type.setter
    def registry_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "registry_type", value)

    @property
    @pulumi.getter
    def repository(self) -> pulumi.Input[str]:
        """
        The repository name.
        """
        return pulumi.get(self, "repository")

    @repository.setter
    def repository(self, value: pulumi.Input[str]):
        pulumi.set(self, "repository", value)

    @property
    @pulumi.getter(name="deployOnPushes")
    def deploy_on_pushes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgs']]]]:
        """
        Configures automatically deploying images pushed to DOCR.
        """
        return pulumi.get(self, "deploy_on_pushes")

    @deploy_on_pushes.setter
    def deploy_on_pushes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppSpecWorkerImageDeployOnPushArgs']]]]):
        pulumi.set(self, "deploy_on_pushes", value)

    @property
    @pulumi.getter
    def registry(self) -> Optional[pulumi.Input[str]]:
        """
        The registry name. Must be left empty for the `DOCR` registry type. Required for the `DOCKER_HUB` registry type.
        """
        return pulumi.get(self, "registry")

    @registry.setter
    def registry(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry", value)

    @property
    @pulumi.getter(name="registryCredentials")
    def registry_credentials(self) -> Optional[pulumi.Input[str]]:
        """
        The credentials required to access a private Docker Hub or GitHub registry, in the following syntax `<username>:<token>`.
        """
        return pulumi.get(self, "registry_credentials")

    @registry_credentials.setter
    def registry_credentials(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "registry_credentials", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        The repository tag. Defaults to `latest` if not provided.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class AppSpecWorkerImageDeployOnPushArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Whether to automatically deploy images pushed to DOCR.
        """
elif False:
    AppSpecWorkerImageDeployOnPushArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerImageDeployOnPushArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to automatically deploy images pushed to DOCR.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to automatically deploy images pushed to DOCR.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AppSpecWorkerLogDestinationArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        datadog: NotRequired[pulumi.Input['AppSpecWorkerLogDestinationDatadogArgsDict']]
        """
        Datadog configuration.
        """
        logtail: NotRequired[pulumi.Input['AppSpecWorkerLogDestinationLogtailArgsDict']]
        """
        Logtail configuration.
        """
        open_search: NotRequired[pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgsDict']]
        """
        OpenSearch configuration.
        """
        papertrail: NotRequired[pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgsDict']]
        """
        Papertrail configuration.
        """
elif False:
    AppSpecWorkerLogDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 datadog: Optional[pulumi.Input['AppSpecWorkerLogDestinationDatadogArgs']] = None,
                 logtail: Optional[pulumi.Input['AppSpecWorkerLogDestinationLogtailArgs']] = None,
                 open_search: Optional[pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgs']] = None,
                 papertrail: Optional[pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgs']] = None):
        """
        :param pulumi.Input[str] name: Name of the log destination. Minimum length: 2. Maximum length: 42.
        :param pulumi.Input['AppSpecWorkerLogDestinationDatadogArgs'] datadog: Datadog configuration.
        :param pulumi.Input['AppSpecWorkerLogDestinationLogtailArgs'] logtail: Logtail configuration.
        :param pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgs'] open_search: OpenSearch configuration.
        :param pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgs'] papertrail: Papertrail configuration.
        """
        pulumi.set(__self__, "name", name)
        if datadog is not None:
            pulumi.set(__self__, "datadog", datadog)
        if logtail is not None:
            pulumi.set(__self__, "logtail", logtail)
        if open_search is not None:
            pulumi.set(__self__, "open_search", open_search)
        if papertrail is not None:
            pulumi.set(__self__, "papertrail", papertrail)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the log destination. Minimum length: 2. Maximum length: 42.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def datadog(self) -> Optional[pulumi.Input['AppSpecWorkerLogDestinationDatadogArgs']]:
        """
        Datadog configuration.
        """
        return pulumi.get(self, "datadog")

    @datadog.setter
    def datadog(self, value: Optional[pulumi.Input['AppSpecWorkerLogDestinationDatadogArgs']]):
        pulumi.set(self, "datadog", value)

    @property
    @pulumi.getter
    def logtail(self) -> Optional[pulumi.Input['AppSpecWorkerLogDestinationLogtailArgs']]:
        """
        Logtail configuration.
        """
        return pulumi.get(self, "logtail")

    @logtail.setter
    def logtail(self, value: Optional[pulumi.Input['AppSpecWorkerLogDestinationLogtailArgs']]):
        pulumi.set(self, "logtail", value)

    @property
    @pulumi.getter(name="openSearch")
    def open_search(self) -> Optional[pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgs']]:
        """
        OpenSearch configuration.
        """
        return pulumi.get(self, "open_search")

    @open_search.setter
    def open_search(self, value: Optional[pulumi.Input['AppSpecWorkerLogDestinationOpenSearchArgs']]):
        pulumi.set(self, "open_search", value)

    @property
    @pulumi.getter
    def papertrail(self) -> Optional[pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgs']]:
        """
        Papertrail configuration.
        """
        return pulumi.get(self, "papertrail")

    @papertrail.setter
    def papertrail(self, value: Optional[pulumi.Input['AppSpecWorkerLogDestinationPapertrailArgs']]):
        pulumi.set(self, "papertrail", value)


if not MYPY:
    class AppSpecWorkerLogDestinationDatadogArgsDict(TypedDict):
        api_key: pulumi.Input[str]
        """
        Datadog API key.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        Datadog HTTP log intake endpoint.
        """
elif False:
    AppSpecWorkerLogDestinationDatadogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationDatadogArgs:
    def __init__(__self__, *,
                 api_key: pulumi.Input[str],
                 endpoint: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] api_key: Datadog API key.
        :param pulumi.Input[str] endpoint: Datadog HTTP log intake endpoint.
        """
        pulumi.set(__self__, "api_key", api_key)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> pulumi.Input[str]:
        """
        Datadog API key.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Datadog HTTP log intake endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class AppSpecWorkerLogDestinationLogtailArgsDict(TypedDict):
        token: pulumi.Input[str]
        """
        Logtail token.
        """
elif False:
    AppSpecWorkerLogDestinationLogtailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationLogtailArgs:
    def __init__(__self__, *,
                 token: pulumi.Input[str]):
        """
        :param pulumi.Input[str] token: Logtail token.
        """
        pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter
    def token(self) -> pulumi.Input[str]:
        """
        Logtail token.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: pulumi.Input[str]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppSpecWorkerLogDestinationOpenSearchArgsDict(TypedDict):
        basic_auth: pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgsDict']
        """
        Basic authentication details.
        """
        cluster_name: NotRequired[pulumi.Input[str]]
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        OpenSearch endpoint.
        """
        index_name: NotRequired[pulumi.Input[str]]
        """
        OpenSearch index name.
        """
elif False:
    AppSpecWorkerLogDestinationOpenSearchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationOpenSearchArgs:
    def __init__(__self__, *,
                 basic_auth: pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs'],
                 cluster_name: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 index_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs'] basic_auth: Basic authentication details.
        :param pulumi.Input[str] cluster_name: The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        :param pulumi.Input[str] endpoint: OpenSearch endpoint.
        :param pulumi.Input[str] index_name: OpenSearch index name.
        """
        pulumi.set(__self__, "basic_auth", basic_auth)
        if cluster_name is not None:
            pulumi.set(__self__, "cluster_name", cluster_name)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if index_name is not None:
            pulumi.set(__self__, "index_name", index_name)

    @property
    @pulumi.getter(name="basicAuth")
    def basic_auth(self) -> pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs']:
        """
        Basic authentication details.
        """
        return pulumi.get(self, "basic_auth")

    @basic_auth.setter
    def basic_auth(self, value: pulumi.Input['AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs']):
        pulumi.set(self, "basic_auth", value)

    @property
    @pulumi.getter(name="clusterName")
    def cluster_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the underlying DigitalOcean DBaaS cluster. This is required for production databases. For dev databases, if `cluster_name` is not set, a new cluster will be provisioned.
        """
        return pulumi.get(self, "cluster_name")

    @cluster_name.setter
    def cluster_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_name", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="indexName")
    def index_name(self) -> Optional[pulumi.Input[str]]:
        """
        OpenSearch index name.
        """
        return pulumi.get(self, "index_name")

    @index_name.setter
    def index_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_name", value)


if not MYPY:
    class AppSpecWorkerLogDestinationOpenSearchBasicAuthArgsDict(TypedDict):
        password: NotRequired[pulumi.Input[str]]
        """
        Password for basic authentication.
        """
        user: NotRequired[pulumi.Input[str]]
        """
        user for basic authentication.
        """
elif False:
    AppSpecWorkerLogDestinationOpenSearchBasicAuthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationOpenSearchBasicAuthArgs:
    def __init__(__self__, *,
                 password: Optional[pulumi.Input[str]] = None,
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: Password for basic authentication.
        :param pulumi.Input[str] user: user for basic authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        Password for basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        user for basic authentication.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class AppSpecWorkerLogDestinationPapertrailArgsDict(TypedDict):
        endpoint: pulumi.Input[str]
        """
        Papertrail syslog endpoint.
        """
elif False:
    AppSpecWorkerLogDestinationPapertrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppSpecWorkerLogDestinationPapertrailArgs:
    def __init__(__self__, *,
                 endpoint: pulumi.Input[str]):
        """
        :param pulumi.Input[str] endpoint: Papertrail syslog endpoint.
        """
        pulumi.set(__self__, "endpoint", endpoint)

    @property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[str]:
        """
        Papertrail syslog endpoint.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[str]):
        pulumi.set(self, "endpoint", value)


if not MYPY:
    class DatabaseClusterBackupRestoreArgsDict(TypedDict):
        database_name: pulumi.Input[str]
        """
        The name of an existing database cluster from which the backup will be restored.
        """
        backup_created_at: NotRequired[pulumi.Input[str]]
        """
        The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
elif False:
    DatabaseClusterBackupRestoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseClusterBackupRestoreArgs:
    def __init__(__self__, *,
                 database_name: pulumi.Input[str],
                 backup_created_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_name: The name of an existing database cluster from which the backup will be restored.
        :param pulumi.Input[str] backup_created_at: The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.
               
               This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        pulumi.set(__self__, "database_name", database_name)
        if backup_created_at is not None:
            pulumi.set(__self__, "backup_created_at", backup_created_at)

    @property
    @pulumi.getter(name="databaseName")
    def database_name(self) -> pulumi.Input[str]:
        """
        The name of an existing database cluster from which the backup will be restored.
        """
        return pulumi.get(self, "database_name")

    @database_name.setter
    def database_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_name", value)

    @property
    @pulumi.getter(name="backupCreatedAt")
    def backup_created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The timestamp of an existing database cluster backup in ISO8601 combined date and time format. The most recent backup will be used if excluded.

        This resource supports customized create timeouts. The default timeout is 30 minutes.
        """
        return pulumi.get(self, "backup_created_at")

    @backup_created_at.setter
    def backup_created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_created_at", value)


if not MYPY:
    class DatabaseClusterMaintenanceWindowArgsDict(TypedDict):
        day: pulumi.Input[str]
        """
        The day of the week on which to apply maintenance updates.
        """
        hour: pulumi.Input[str]
        """
        The hour in UTC at which maintenance updates will be applied in 24 hour format.
        """
elif False:
    DatabaseClusterMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseClusterMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[str],
                 hour: pulumi.Input[str]):
        """
        :param pulumi.Input[str] day: The day of the week on which to apply maintenance updates.
        :param pulumi.Input[str] hour: The hour in UTC at which maintenance updates will be applied in 24 hour format.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "hour", hour)

    @property
    @pulumi.getter
    def day(self) -> pulumi.Input[str]:
        """
        The day of the week on which to apply maintenance updates.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[str]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def hour(self) -> pulumi.Input[str]:
        """
        The hour in UTC at which maintenance updates will be applied in 24 hour format.
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: pulumi.Input[str]):
        pulumi.set(self, "hour", value)


if not MYPY:
    class DatabaseFirewallRuleArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, `tag`, or `app`.
        """
        value: pulumi.Input[str]
        """
        The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        """
        created_at: NotRequired[pulumi.Input[str]]
        """
        The date and time when the firewall rule was created.
        """
        uuid: NotRequired[pulumi.Input[str]]
        """
        A unique identifier for the firewall rule.
        """
elif False:
    DatabaseFirewallRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseFirewallRuleArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 value: pulumi.Input[str],
                 created_at: Optional[pulumi.Input[str]] = None,
                 uuid: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, `tag`, or `app`.
        :param pulumi.Input[str] value: The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        :param pulumi.Input[str] created_at: The date and time when the firewall rule was created.
        :param pulumi.Input[str] uuid: A unique identifier for the firewall rule.
        """
        pulumi.set(__self__, "type", type)
        pulumi.set(__self__, "value", value)
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if uuid is not None:
            pulumi.set(__self__, "uuid", uuid)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The type of resource that the firewall rule allows to access the database cluster. The possible values are: `droplet`, `k8s`, `ip_addr`, `tag`, or `app`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The ID of the specific resource, the name of a tag applied to a group of resources, or the IP address that the firewall rule allows to access the database cluster.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the firewall rule was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter
    def uuid(self) -> Optional[pulumi.Input[str]]:
        """
        A unique identifier for the firewall rule.
        """
        return pulumi.get(self, "uuid")

    @uuid.setter
    def uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uuid", value)


if not MYPY:
    class DatabaseKafkaTopicConfigArgsDict(TypedDict):
        cleanup_policy: NotRequired[pulumi.Input[str]]
        """
        The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
        This may be one of "delete", "compact", or "compact_delete".
        """
        compression_type: NotRequired[pulumi.Input[str]]
        """
        The topic compression codecs used for a given topic.
        This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        """
        delete_retention_ms: NotRequired[pulumi.Input[str]]
        """
        The amount of time, in ms, that deleted records are retained.
        """
        file_delete_delay_ms: NotRequired[pulumi.Input[str]]
        """
        The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        """
        flush_messages: NotRequired[pulumi.Input[str]]
        """
        The number of messages accumulated on a topic partition before they are flushed to disk.
        """
        flush_ms: NotRequired[pulumi.Input[str]]
        """
        The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        """
        index_interval_bytes: NotRequired[pulumi.Input[str]]
        """
        The interval, in bytes, in which entries are added to the offset index.
        """
        max_compaction_lag_ms: NotRequired[pulumi.Input[str]]
        """
        The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        """
        max_message_bytes: NotRequired[pulumi.Input[str]]
        """
        The maximum size, in bytes, of a message.
        """
        message_down_conversion_enable: NotRequired[pulumi.Input[bool]]
        """
        Determines whether down-conversion of message formats for consumers is enabled.
        """
        message_format_version: NotRequired[pulumi.Input[str]]
        """
        The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        """
        message_timestamp_difference_max_ms: NotRequired[pulumi.Input[str]]
        """
        The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        """
        message_timestamp_type: NotRequired[pulumi.Input[str]]
        """
        Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        """
        min_cleanable_dirty_ratio: NotRequired[pulumi.Input[float]]
        """
        A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        """
        min_compaction_lag_ms: NotRequired[pulumi.Input[str]]
        min_insync_replicas: NotRequired[pulumi.Input[int]]
        """
        The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
        """
        preallocate: NotRequired[pulumi.Input[bool]]
        """
        Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        """
        retention_bytes: NotRequired[pulumi.Input[str]]
        """
        The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        """
        retention_ms: NotRequired[pulumi.Input[str]]
        """
        The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        """
        segment_bytes: NotRequired[pulumi.Input[str]]
        """
        The maximum size, in bytes, of a single topic log file.
        """
        segment_index_bytes: NotRequired[pulumi.Input[str]]
        """
        The maximum size, in bytes, of the offset index.
        """
        segment_jitter_ms: NotRequired[pulumi.Input[str]]
        """
        The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        """
        segment_ms: NotRequired[pulumi.Input[str]]
        """
        The maximum time, in ms, before the topic log will flush to disk.
        """
elif False:
    DatabaseKafkaTopicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseKafkaTopicConfigArgs:
    def __init__(__self__, *,
                 cleanup_policy: Optional[pulumi.Input[str]] = None,
                 compression_type: Optional[pulumi.Input[str]] = None,
                 delete_retention_ms: Optional[pulumi.Input[str]] = None,
                 file_delete_delay_ms: Optional[pulumi.Input[str]] = None,
                 flush_messages: Optional[pulumi.Input[str]] = None,
                 flush_ms: Optional[pulumi.Input[str]] = None,
                 index_interval_bytes: Optional[pulumi.Input[str]] = None,
                 max_compaction_lag_ms: Optional[pulumi.Input[str]] = None,
                 max_message_bytes: Optional[pulumi.Input[str]] = None,
                 message_down_conversion_enable: Optional[pulumi.Input[bool]] = None,
                 message_format_version: Optional[pulumi.Input[str]] = None,
                 message_timestamp_difference_max_ms: Optional[pulumi.Input[str]] = None,
                 message_timestamp_type: Optional[pulumi.Input[str]] = None,
                 min_cleanable_dirty_ratio: Optional[pulumi.Input[float]] = None,
                 min_compaction_lag_ms: Optional[pulumi.Input[str]] = None,
                 min_insync_replicas: Optional[pulumi.Input[int]] = None,
                 preallocate: Optional[pulumi.Input[bool]] = None,
                 retention_bytes: Optional[pulumi.Input[str]] = None,
                 retention_ms: Optional[pulumi.Input[str]] = None,
                 segment_bytes: Optional[pulumi.Input[str]] = None,
                 segment_index_bytes: Optional[pulumi.Input[str]] = None,
                 segment_jitter_ms: Optional[pulumi.Input[str]] = None,
                 segment_ms: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cleanup_policy: The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
               This may be one of "delete", "compact", or "compact_delete".
        :param pulumi.Input[str] compression_type: The topic compression codecs used for a given topic.
               This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        :param pulumi.Input[str] delete_retention_ms: The amount of time, in ms, that deleted records are retained.
        :param pulumi.Input[str] file_delete_delay_ms: The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        :param pulumi.Input[str] flush_messages: The number of messages accumulated on a topic partition before they are flushed to disk.
        :param pulumi.Input[str] flush_ms: The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        :param pulumi.Input[str] index_interval_bytes: The interval, in bytes, in which entries are added to the offset index.
        :param pulumi.Input[str] max_compaction_lag_ms: The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        :param pulumi.Input[str] max_message_bytes: The maximum size, in bytes, of a message.
        :param pulumi.Input[bool] message_down_conversion_enable: Determines whether down-conversion of message formats for consumers is enabled.
        :param pulumi.Input[str] message_format_version: The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        :param pulumi.Input[str] message_timestamp_difference_max_ms: The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        :param pulumi.Input[str] message_timestamp_type: Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        :param pulumi.Input[float] min_cleanable_dirty_ratio: A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        :param pulumi.Input[int] min_insync_replicas: The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
        :param pulumi.Input[bool] preallocate: Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        :param pulumi.Input[str] retention_bytes: The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        :param pulumi.Input[str] retention_ms: The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        :param pulumi.Input[str] segment_bytes: The maximum size, in bytes, of a single topic log file.
        :param pulumi.Input[str] segment_index_bytes: The maximum size, in bytes, of the offset index.
        :param pulumi.Input[str] segment_jitter_ms: The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        :param pulumi.Input[str] segment_ms: The maximum time, in ms, before the topic log will flush to disk.
        """
        if cleanup_policy is not None:
            pulumi.set(__self__, "cleanup_policy", cleanup_policy)
        if compression_type is not None:
            pulumi.set(__self__, "compression_type", compression_type)
        if delete_retention_ms is not None:
            pulumi.set(__self__, "delete_retention_ms", delete_retention_ms)
        if file_delete_delay_ms is not None:
            pulumi.set(__self__, "file_delete_delay_ms", file_delete_delay_ms)
        if flush_messages is not None:
            pulumi.set(__self__, "flush_messages", flush_messages)
        if flush_ms is not None:
            pulumi.set(__self__, "flush_ms", flush_ms)
        if index_interval_bytes is not None:
            pulumi.set(__self__, "index_interval_bytes", index_interval_bytes)
        if max_compaction_lag_ms is not None:
            pulumi.set(__self__, "max_compaction_lag_ms", max_compaction_lag_ms)
        if max_message_bytes is not None:
            pulumi.set(__self__, "max_message_bytes", max_message_bytes)
        if message_down_conversion_enable is not None:
            pulumi.set(__self__, "message_down_conversion_enable", message_down_conversion_enable)
        if message_format_version is not None:
            pulumi.set(__self__, "message_format_version", message_format_version)
        if message_timestamp_difference_max_ms is not None:
            pulumi.set(__self__, "message_timestamp_difference_max_ms", message_timestamp_difference_max_ms)
        if message_timestamp_type is not None:
            pulumi.set(__self__, "message_timestamp_type", message_timestamp_type)
        if min_cleanable_dirty_ratio is not None:
            pulumi.set(__self__, "min_cleanable_dirty_ratio", min_cleanable_dirty_ratio)
        if min_compaction_lag_ms is not None:
            pulumi.set(__self__, "min_compaction_lag_ms", min_compaction_lag_ms)
        if min_insync_replicas is not None:
            pulumi.set(__self__, "min_insync_replicas", min_insync_replicas)
        if preallocate is not None:
            pulumi.set(__self__, "preallocate", preallocate)
        if retention_bytes is not None:
            pulumi.set(__self__, "retention_bytes", retention_bytes)
        if retention_ms is not None:
            pulumi.set(__self__, "retention_ms", retention_ms)
        if segment_bytes is not None:
            pulumi.set(__self__, "segment_bytes", segment_bytes)
        if segment_index_bytes is not None:
            pulumi.set(__self__, "segment_index_bytes", segment_index_bytes)
        if segment_jitter_ms is not None:
            pulumi.set(__self__, "segment_jitter_ms", segment_jitter_ms)
        if segment_ms is not None:
            pulumi.set(__self__, "segment_ms", segment_ms)

    @property
    @pulumi.getter(name="cleanupPolicy")
    def cleanup_policy(self) -> Optional[pulumi.Input[str]]:
        """
        The topic cleanup policy that describes whether messages should be deleted, compacted, or both when retention policies are violated.
        This may be one of "delete", "compact", or "compact_delete".
        """
        return pulumi.get(self, "cleanup_policy")

    @cleanup_policy.setter
    def cleanup_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cleanup_policy", value)

    @property
    @pulumi.getter(name="compressionType")
    def compression_type(self) -> Optional[pulumi.Input[str]]:
        """
        The topic compression codecs used for a given topic.
        This may be one of "uncompressed", "gzip", "snappy", "lz4", "producer", "zstd". "uncompressed" indicates that there is no compression and "producer" retains the original compression codec set by the producer.
        """
        return pulumi.get(self, "compression_type")

    @compression_type.setter
    def compression_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression_type", value)

    @property
    @pulumi.getter(name="deleteRetentionMs")
    def delete_retention_ms(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of time, in ms, that deleted records are retained.
        """
        return pulumi.get(self, "delete_retention_ms")

    @delete_retention_ms.setter
    def delete_retention_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "delete_retention_ms", value)

    @property
    @pulumi.getter(name="fileDeleteDelayMs")
    def file_delete_delay_ms(self) -> Optional[pulumi.Input[str]]:
        """
        The amount of time, in ms, to wait before deleting a topic log segment from the filesystem.
        """
        return pulumi.get(self, "file_delete_delay_ms")

    @file_delete_delay_ms.setter
    def file_delete_delay_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_delete_delay_ms", value)

    @property
    @pulumi.getter(name="flushMessages")
    def flush_messages(self) -> Optional[pulumi.Input[str]]:
        """
        The number of messages accumulated on a topic partition before they are flushed to disk.
        """
        return pulumi.get(self, "flush_messages")

    @flush_messages.setter
    def flush_messages(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flush_messages", value)

    @property
    @pulumi.getter(name="flushMs")
    def flush_ms(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum time, in ms, that a topic is kept in memory before being flushed to disk.
        """
        return pulumi.get(self, "flush_ms")

    @flush_ms.setter
    def flush_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "flush_ms", value)

    @property
    @pulumi.getter(name="indexIntervalBytes")
    def index_interval_bytes(self) -> Optional[pulumi.Input[str]]:
        """
        The interval, in bytes, in which entries are added to the offset index.
        """
        return pulumi.get(self, "index_interval_bytes")

    @index_interval_bytes.setter
    def index_interval_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "index_interval_bytes", value)

    @property
    @pulumi.getter(name="maxCompactionLagMs")
    def max_compaction_lag_ms(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum time, in ms, that a particular message will remain uncompacted. This will not apply if the `compression_type` is set to "uncompressed" or it is set to `producer` and the producer is not using compression.
        """
        return pulumi.get(self, "max_compaction_lag_ms")

    @max_compaction_lag_ms.setter
    def max_compaction_lag_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_compaction_lag_ms", value)

    @property
    @pulumi.getter(name="maxMessageBytes")
    def max_message_bytes(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum size, in bytes, of a message.
        """
        return pulumi.get(self, "max_message_bytes")

    @max_message_bytes.setter
    def max_message_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_message_bytes", value)

    @property
    @pulumi.getter(name="messageDownConversionEnable")
    def message_down_conversion_enable(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether down-conversion of message formats for consumers is enabled.
        """
        return pulumi.get(self, "message_down_conversion_enable")

    @message_down_conversion_enable.setter
    def message_down_conversion_enable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "message_down_conversion_enable", value)

    @property
    @pulumi.getter(name="messageFormatVersion")
    def message_format_version(self) -> Optional[pulumi.Input[str]]:
        """
        The version of the inter-broker protocol that will be used. This may be one of "0.8.0", "0.8.1", "0.8.2", "0.9.0", "0.10.0", "0.10.0-IV0", "0.10.0-IV1", "0.10.1", "0.10.1-IV0", "0.10.1-IV1", "0.10.1-IV2", "0.10.2", "0.10.2-IV0", "0.11.0", "0.11.0-IV0", "0.11.0-IV1", "0.11.0-IV2", "1.0", "1.0-IV0", "1.1", "1.1-IV0", "2.0", "2.0-IV0", "2.0-IV1", "2.1", "2.1-IV0", "2.1-IV1", "2.1-IV2", "2.2", "2.2-IV0", "2.2-IV1", "2.3", "2.3-IV0", "2.3-IV1", "2.4", "2.4-IV0", "2.4-IV1", "2.5", "2.5-IV0", "2.6", "2.6-IV0", "2.7", "2.7-IV0", "2.7-IV1", "2.7-IV2", "2.8", "2.8-IV0", "2.8-IV1", "3.0", "3.0-IV0", "3.0-IV1", "3.1", "3.1-IV0", "3.2", "3.2-IV0", "3.3", "3.3-IV0", "3.3-IV1", "3.3-IV2", "3.3-IV3", "3.4", "3.4-IV0", "3.5", "3.5-IV0", "3.5-IV1", "3.5-IV2", "3.6", "3.6-IV0", "3.6-IV1", "3.6-IV2".
        """
        return pulumi.get(self, "message_format_version")

    @message_format_version.setter
    def message_format_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_format_version", value)

    @property
    @pulumi.getter(name="messageTimestampDifferenceMaxMs")
    def message_timestamp_difference_max_ms(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum difference, in ms, between the timestamp specific in a message and when the broker receives the message.
        """
        return pulumi.get(self, "message_timestamp_difference_max_ms")

    @message_timestamp_difference_max_ms.setter
    def message_timestamp_difference_max_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_timestamp_difference_max_ms", value)

    @property
    @pulumi.getter(name="messageTimestampType")
    def message_timestamp_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which timestamp to use for the message. This may be one of "create_time" or "log_append_time".
        """
        return pulumi.get(self, "message_timestamp_type")

    @message_timestamp_type.setter
    def message_timestamp_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message_timestamp_type", value)

    @property
    @pulumi.getter(name="minCleanableDirtyRatio")
    def min_cleanable_dirty_ratio(self) -> Optional[pulumi.Input[float]]:
        """
        A scale between 0.0 and 1.0 which controls the frequency of the compactor. Larger values mean more frequent compactions. This is often paired with `max_compaction_lag_ms` to control the compactor frequency.
        """
        return pulumi.get(self, "min_cleanable_dirty_ratio")

    @min_cleanable_dirty_ratio.setter
    def min_cleanable_dirty_ratio(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "min_cleanable_dirty_ratio", value)

    @property
    @pulumi.getter(name="minCompactionLagMs")
    def min_compaction_lag_ms(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "min_compaction_lag_ms")

    @min_compaction_lag_ms.setter
    def min_compaction_lag_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_compaction_lag_ms", value)

    @property
    @pulumi.getter(name="minInsyncReplicas")
    def min_insync_replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of replicas that must acknowledge a write before it is considered successful. -1 is a special setting to indicate that all nodes must ack a message before a write is considered successful. Default is 1, indicating at least 1 replica must acknowledge a write to be considered successful.
        """
        return pulumi.get(self, "min_insync_replicas")

    @min_insync_replicas.setter
    def min_insync_replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_insync_replicas", value)

    @property
    @pulumi.getter
    def preallocate(self) -> Optional[pulumi.Input[bool]]:
        """
        Determines whether to preallocate a file on disk when creating a new log segment within a topic.
        """
        return pulumi.get(self, "preallocate")

    @preallocate.setter
    def preallocate(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "preallocate", value)

    @property
    @pulumi.getter(name="retentionBytes")
    def retention_bytes(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum size, in bytes, of a topic before messages are deleted. -1 is a special setting indicating that this setting has no limit.
        """
        return pulumi.get(self, "retention_bytes")

    @retention_bytes.setter
    def retention_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_bytes", value)

    @property
    @pulumi.getter(name="retentionMs")
    def retention_ms(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum time, in ms, that a topic log file is retained before deleting it. -1 is a special setting indicating that this setting has no limit.
        """
        return pulumi.get(self, "retention_ms")

    @retention_ms.setter
    def retention_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_ms", value)

    @property
    @pulumi.getter(name="segmentBytes")
    def segment_bytes(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum size, in bytes, of a single topic log file.
        """
        return pulumi.get(self, "segment_bytes")

    @segment_bytes.setter
    def segment_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_bytes", value)

    @property
    @pulumi.getter(name="segmentIndexBytes")
    def segment_index_bytes(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum size, in bytes, of the offset index.
        """
        return pulumi.get(self, "segment_index_bytes")

    @segment_index_bytes.setter
    def segment_index_bytes(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_index_bytes", value)

    @property
    @pulumi.getter(name="segmentJitterMs")
    def segment_jitter_ms(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum time, in ms, subtracted from the scheduled segment disk flush time to avoid the thundering herd problem for segment flushing.
        """
        return pulumi.get(self, "segment_jitter_ms")

    @segment_jitter_ms.setter
    def segment_jitter_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_jitter_ms", value)

    @property
    @pulumi.getter(name="segmentMs")
    def segment_ms(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum time, in ms, before the topic log will flush to disk.
        """
        return pulumi.get(self, "segment_ms")

    @segment_ms.setter
    def segment_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "segment_ms", value)


if not MYPY:
    class DatabasePostgresqlConfigPgbouncerArgsDict(TypedDict):
        autodb_idle_timeout: NotRequired[pulumi.Input[int]]
        autodb_max_db_connections: NotRequired[pulumi.Input[int]]
        autodb_pool_mode: NotRequired[pulumi.Input[str]]
        autodb_pool_size: NotRequired[pulumi.Input[int]]
        ignore_startup_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        min_pool_size: NotRequired[pulumi.Input[int]]
        server_idle_timeout: NotRequired[pulumi.Input[int]]
        server_lifetime: NotRequired[pulumi.Input[int]]
        server_reset_query_always: NotRequired[pulumi.Input[bool]]
elif False:
    DatabasePostgresqlConfigPgbouncerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabasePostgresqlConfigPgbouncerArgs:
    def __init__(__self__, *,
                 autodb_idle_timeout: Optional[pulumi.Input[int]] = None,
                 autodb_max_db_connections: Optional[pulumi.Input[int]] = None,
                 autodb_pool_mode: Optional[pulumi.Input[str]] = None,
                 autodb_pool_size: Optional[pulumi.Input[int]] = None,
                 ignore_startup_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 min_pool_size: Optional[pulumi.Input[int]] = None,
                 server_idle_timeout: Optional[pulumi.Input[int]] = None,
                 server_lifetime: Optional[pulumi.Input[int]] = None,
                 server_reset_query_always: Optional[pulumi.Input[bool]] = None):
        if autodb_idle_timeout is not None:
            pulumi.set(__self__, "autodb_idle_timeout", autodb_idle_timeout)
        if autodb_max_db_connections is not None:
            pulumi.set(__self__, "autodb_max_db_connections", autodb_max_db_connections)
        if autodb_pool_mode is not None:
            pulumi.set(__self__, "autodb_pool_mode", autodb_pool_mode)
        if autodb_pool_size is not None:
            pulumi.set(__self__, "autodb_pool_size", autodb_pool_size)
        if ignore_startup_parameters is not None:
            pulumi.set(__self__, "ignore_startup_parameters", ignore_startup_parameters)
        if min_pool_size is not None:
            pulumi.set(__self__, "min_pool_size", min_pool_size)
        if server_idle_timeout is not None:
            pulumi.set(__self__, "server_idle_timeout", server_idle_timeout)
        if server_lifetime is not None:
            pulumi.set(__self__, "server_lifetime", server_lifetime)
        if server_reset_query_always is not None:
            pulumi.set(__self__, "server_reset_query_always", server_reset_query_always)

    @property
    @pulumi.getter(name="autodbIdleTimeout")
    def autodb_idle_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autodb_idle_timeout")

    @autodb_idle_timeout.setter
    def autodb_idle_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autodb_idle_timeout", value)

    @property
    @pulumi.getter(name="autodbMaxDbConnections")
    def autodb_max_db_connections(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autodb_max_db_connections")

    @autodb_max_db_connections.setter
    def autodb_max_db_connections(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autodb_max_db_connections", value)

    @property
    @pulumi.getter(name="autodbPoolMode")
    def autodb_pool_mode(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "autodb_pool_mode")

    @autodb_pool_mode.setter
    def autodb_pool_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "autodb_pool_mode", value)

    @property
    @pulumi.getter(name="autodbPoolSize")
    def autodb_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "autodb_pool_size")

    @autodb_pool_size.setter
    def autodb_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "autodb_pool_size", value)

    @property
    @pulumi.getter(name="ignoreStartupParameters")
    def ignore_startup_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        return pulumi.get(self, "ignore_startup_parameters")

    @ignore_startup_parameters.setter
    def ignore_startup_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ignore_startup_parameters", value)

    @property
    @pulumi.getter(name="minPoolSize")
    def min_pool_size(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "min_pool_size")

    @min_pool_size.setter
    def min_pool_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_pool_size", value)

    @property
    @pulumi.getter(name="serverIdleTimeout")
    def server_idle_timeout(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "server_idle_timeout")

    @server_idle_timeout.setter
    def server_idle_timeout(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "server_idle_timeout", value)

    @property
    @pulumi.getter(name="serverLifetime")
    def server_lifetime(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "server_lifetime")

    @server_lifetime.setter
    def server_lifetime(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "server_lifetime", value)

    @property
    @pulumi.getter(name="serverResetQueryAlways")
    def server_reset_query_always(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "server_reset_query_always")

    @server_reset_query_always.setter
    def server_reset_query_always(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "server_reset_query_always", value)


if not MYPY:
    class DatabasePostgresqlConfigTimescaledbArgsDict(TypedDict):
        max_background_workers: NotRequired[pulumi.Input[int]]
elif False:
    DatabasePostgresqlConfigTimescaledbArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabasePostgresqlConfigTimescaledbArgs:
    def __init__(__self__, *,
                 max_background_workers: Optional[pulumi.Input[int]] = None):
        if max_background_workers is not None:
            pulumi.set(__self__, "max_background_workers", max_background_workers)

    @property
    @pulumi.getter(name="maxBackgroundWorkers")
    def max_background_workers(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "max_background_workers")

    @max_background_workers.setter
    def max_background_workers(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_background_workers", value)


if not MYPY:
    class DatabaseUserSettingArgsDict(TypedDict):
        acls: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgsDict']]]]
        """
        A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:

        An individual ACL includes the following:
        """
        opensearch_acls: NotRequired[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingOpensearchAclArgsDict']]]]
elif False:
    DatabaseUserSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserSettingArgs:
    def __init__(__self__, *,
                 acls: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgs']]]] = None,
                 opensearch_acls: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingOpensearchAclArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgs']]] acls: A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:
               
               An individual ACL includes the following:
        """
        if acls is not None:
            pulumi.set(__self__, "acls", acls)
        if opensearch_acls is not None:
            pulumi.set(__self__, "opensearch_acls", opensearch_acls)

    @property
    @pulumi.getter
    def acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgs']]]]:
        """
        A set of ACLs (Access Control Lists) specifying permission on topics with a Kafka cluster. The properties of an individual ACL are described below:

        An individual ACL includes the following:
        """
        return pulumi.get(self, "acls")

    @acls.setter
    def acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingAclArgs']]]]):
        pulumi.set(self, "acls", value)

    @property
    @pulumi.getter(name="opensearchAcls")
    def opensearch_acls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingOpensearchAclArgs']]]]:
        return pulumi.get(self, "opensearch_acls")

    @opensearch_acls.setter
    def opensearch_acls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DatabaseUserSettingOpensearchAclArgs']]]]):
        pulumi.set(self, "opensearch_acls", value)


if not MYPY:
    class DatabaseUserSettingAclArgsDict(TypedDict):
        permission: pulumi.Input[str]
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        topic: pulumi.Input[str]
        """
        A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "*", "<prefix>*", or "<literal>". "*" is a special value indicating a wildcard that matches on all topics. "<prefix>*" defines a regex that matches all topics with the prefix. "<literal>" performs an exact match on a topic name and only applies to that topic.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        An identifier for the ACL, this will be automatically assigned when you create an ACL entry
        """
elif False:
    DatabaseUserSettingAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserSettingAclArgs:
    def __init__(__self__, *,
                 permission: pulumi.Input[str],
                 topic: pulumi.Input[str],
                 id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] permission: The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        :param pulumi.Input[str] topic: A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "*", "<prefix>*", or "<literal>". "*" is a special value indicating a wildcard that matches on all topics. "<prefix>*" defines a regex that matches all topics with the prefix. "<literal>" performs an exact match on a topic name and only applies to that topic.
        :param pulumi.Input[str] id: An identifier for the ACL, this will be automatically assigned when you create an ACL entry
        """
        pulumi.set(__self__, "permission", permission)
        pulumi.set(__self__, "topic", topic)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        A regex for matching the topic(s) that this ACL should apply to. The regex can assume one of 3 patterns: "*", "<prefix>*", or "<literal>". "*" is a special value indicating a wildcard that matches on all topics. "<prefix>*" defines a regex that matches all topics with the prefix. "<literal>" performs an exact match on a topic name and only applies to that topic.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        An identifier for the ACL, this will be automatically assigned when you create an ACL entry
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)


if not MYPY:
    class DatabaseUserSettingOpensearchAclArgsDict(TypedDict):
        index: pulumi.Input[str]
        permission: pulumi.Input[str]
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
elif False:
    DatabaseUserSettingOpensearchAclArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatabaseUserSettingOpensearchAclArgs:
    def __init__(__self__, *,
                 index: pulumi.Input[str],
                 permission: pulumi.Input[str]):
        """
        :param pulumi.Input[str] permission: The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        pulumi.set(__self__, "index", index)
        pulumi.set(__self__, "permission", permission)

    @property
    @pulumi.getter
    def index(self) -> pulumi.Input[str]:
        return pulumi.get(self, "index")

    @index.setter
    def index(self, value: pulumi.Input[str]):
        pulumi.set(self, "index", value)

    @property
    @pulumi.getter
    def permission(self) -> pulumi.Input[str]:
        """
        The permission level applied to the ACL. This includes "admin", "consume", "produce", and "produceconsume". "admin" allows for producing and consuming as well as add/delete/update permission for topics. "consume" allows only for reading topic messages. "produce" allows only for writing topic messages. "produceconsume" allows for both reading and writing topic messages.
        """
        return pulumi.get(self, "permission")

    @permission.setter
    def permission(self, value: pulumi.Input[str]):
        pulumi.set(self, "permission", value)


if not MYPY:
    class DropletAutoscaleConfigArgsDict(TypedDict):
        cooldown_minutes: NotRequired[pulumi.Input[int]]
        """
        The cooldown duration between scaling events for the Droplet Autoscale pool.
        """
        max_instances: NotRequired[pulumi.Input[int]]
        """
        The maximum number of instances to maintain in the Droplet Autoscale pool.
        """
        min_instances: NotRequired[pulumi.Input[int]]
        """
        The minimum number of instances to maintain in the Droplet Autoscale pool.
        """
        target_cpu_utilization: NotRequired[pulumi.Input[float]]
        """
        The target average CPU load (in range `[0, 1]`) to maintain in the Droplet Autoscale pool.
        """
        target_memory_utilization: NotRequired[pulumi.Input[float]]
        """
        The target average Memory load (in range `[0, 1]`) to maintain in the Droplet Autoscale 
        pool.
        """
        target_number_instances: NotRequired[pulumi.Input[int]]
        """
        The static number of instances to maintain in the pool Droplet Autoscale pool. This
        argument cannot be used with any other config options.
        """
elif False:
    DropletAutoscaleConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DropletAutoscaleConfigArgs:
    def __init__(__self__, *,
                 cooldown_minutes: Optional[pulumi.Input[int]] = None,
                 max_instances: Optional[pulumi.Input[int]] = None,
                 min_instances: Optional[pulumi.Input[int]] = None,
                 target_cpu_utilization: Optional[pulumi.Input[float]] = None,
                 target_memory_utilization: Optional[pulumi.Input[float]] = None,
                 target_number_instances: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cooldown_minutes: The cooldown duration between scaling events for the Droplet Autoscale pool.
        :param pulumi.Input[int] max_instances: The maximum number of instances to maintain in the Droplet Autoscale pool.
        :param pulumi.Input[int] min_instances: The minimum number of instances to maintain in the Droplet Autoscale pool.
        :param pulumi.Input[float] target_cpu_utilization: The target average CPU load (in range `[0, 1]`) to maintain in the Droplet Autoscale pool.
        :param pulumi.Input[float] target_memory_utilization: The target average Memory load (in range `[0, 1]`) to maintain in the Droplet Autoscale 
               pool.
        :param pulumi.Input[int] target_number_instances: The static number of instances to maintain in the pool Droplet Autoscale pool. This
               argument cannot be used with any other config options.
        """
        if cooldown_minutes is not None:
            pulumi.set(__self__, "cooldown_minutes", cooldown_minutes)
        if max_instances is not None:
            pulumi.set(__self__, "max_instances", max_instances)
        if min_instances is not None:
            pulumi.set(__self__, "min_instances", min_instances)
        if target_cpu_utilization is not None:
            pulumi.set(__self__, "target_cpu_utilization", target_cpu_utilization)
        if target_memory_utilization is not None:
            pulumi.set(__self__, "target_memory_utilization", target_memory_utilization)
        if target_number_instances is not None:
            pulumi.set(__self__, "target_number_instances", target_number_instances)

    @property
    @pulumi.getter(name="cooldownMinutes")
    def cooldown_minutes(self) -> Optional[pulumi.Input[int]]:
        """
        The cooldown duration between scaling events for the Droplet Autoscale pool.
        """
        return pulumi.get(self, "cooldown_minutes")

    @cooldown_minutes.setter
    def cooldown_minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cooldown_minutes", value)

    @property
    @pulumi.getter(name="maxInstances")
    def max_instances(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of instances to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "max_instances")

    @max_instances.setter
    def max_instances(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_instances", value)

    @property
    @pulumi.getter(name="minInstances")
    def min_instances(self) -> Optional[pulumi.Input[int]]:
        """
        The minimum number of instances to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "min_instances")

    @min_instances.setter
    def min_instances(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_instances", value)

    @property
    @pulumi.getter(name="targetCpuUtilization")
    def target_cpu_utilization(self) -> Optional[pulumi.Input[float]]:
        """
        The target average CPU load (in range `[0, 1]`) to maintain in the Droplet Autoscale pool.
        """
        return pulumi.get(self, "target_cpu_utilization")

    @target_cpu_utilization.setter
    def target_cpu_utilization(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "target_cpu_utilization", value)

    @property
    @pulumi.getter(name="targetMemoryUtilization")
    def target_memory_utilization(self) -> Optional[pulumi.Input[float]]:
        """
        The target average Memory load (in range `[0, 1]`) to maintain in the Droplet Autoscale 
        pool.
        """
        return pulumi.get(self, "target_memory_utilization")

    @target_memory_utilization.setter
    def target_memory_utilization(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "target_memory_utilization", value)

    @property
    @pulumi.getter(name="targetNumberInstances")
    def target_number_instances(self) -> Optional[pulumi.Input[int]]:
        """
        The static number of instances to maintain in the pool Droplet Autoscale pool. This
        argument cannot be used with any other config options.
        """
        return pulumi.get(self, "target_number_instances")

    @target_number_instances.setter
    def target_number_instances(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "target_number_instances", value)


if not MYPY:
    class DropletAutoscaleCurrentUtilizationArgsDict(TypedDict):
        cpu: NotRequired[pulumi.Input[float]]
        """
        Average CPU utilization
        """
        memory: NotRequired[pulumi.Input[float]]
        """
        Average Memory utilization
        """
elif False:
    DropletAutoscaleCurrentUtilizationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DropletAutoscaleCurrentUtilizationArgs:
    def __init__(__self__, *,
                 cpu: Optional[pulumi.Input[float]] = None,
                 memory: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] cpu: Average CPU utilization
        :param pulumi.Input[float] memory: Average Memory utilization
        """
        if cpu is not None:
            pulumi.set(__self__, "cpu", cpu)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)

    @property
    @pulumi.getter
    def cpu(self) -> Optional[pulumi.Input[float]]:
        """
        Average CPU utilization
        """
        return pulumi.get(self, "cpu")

    @cpu.setter
    def cpu(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "cpu", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[float]]:
        """
        Average Memory utilization
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "memory", value)


if not MYPY:
    class DropletAutoscaleDropletTemplateArgsDict(TypedDict):
        image: pulumi.Input[str]
        """
        Image slug of the Droplet Autoscale pool underlying resource(s).
        """
        region: pulumi.Input[str]
        """
        Region slug of the Droplet Autoscale pool underlying resource(s).
        """
        size: pulumi.Input[str]
        """
        Size slug of the Droplet Autoscale pool underlying resource(s).
        """
        ssh_keys: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        SSH fingerprints to add to the Droplet Autoscale pool underlying resource(s).
        """
        ipv6: NotRequired[pulumi.Input[bool]]
        """
        Boolean flag to enable IPv6 networking on the Droplet Autoscale pool underlying resource(s).
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        Project UUID to create the Droplet Autoscale pool underlying resource(s).
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of tags to add to the Droplet Autoscale pool underlying resource(s).
        """
        user_data: NotRequired[pulumi.Input[str]]
        """
        Custom user data that can be added to the Droplet Autoscale pool underlying resource(s). This can be a 
        cloud init script that user may configure to setup their application workload.
        """
        vpc_uuid: NotRequired[pulumi.Input[str]]
        """
        VPC UUID to create the Droplet Autoscale pool underlying resource(s). If not provided, this is inferred
        from the specified `region` (default VPC).
        """
        with_droplet_agent: NotRequired[pulumi.Input[bool]]
        """
        Boolean flag to enable metric agent on the Droplet Autoscale pool underlying resource(s). The
        metric agent enables collecting resource utilization metrics, which allows making resource based scaling decisions.
        """
elif False:
    DropletAutoscaleDropletTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DropletAutoscaleDropletTemplateArgs:
    def __init__(__self__, *,
                 image: pulumi.Input[str],
                 region: pulumi.Input[str],
                 size: pulumi.Input[str],
                 ssh_keys: pulumi.Input[Sequence[pulumi.Input[str]]],
                 ipv6: Optional[pulumi.Input[bool]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 user_data: Optional[pulumi.Input[str]] = None,
                 vpc_uuid: Optional[pulumi.Input[str]] = None,
                 with_droplet_agent: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] image: Image slug of the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[str] region: Region slug of the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[str] size: Size slug of the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssh_keys: SSH fingerprints to add to the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[bool] ipv6: Boolean flag to enable IPv6 networking on the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[str] project_id: Project UUID to create the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: List of tags to add to the Droplet Autoscale pool underlying resource(s).
        :param pulumi.Input[str] user_data: Custom user data that can be added to the Droplet Autoscale pool underlying resource(s). This can be a 
               cloud init script that user may configure to setup their application workload.
        :param pulumi.Input[str] vpc_uuid: VPC UUID to create the Droplet Autoscale pool underlying resource(s). If not provided, this is inferred
               from the specified `region` (default VPC).
        :param pulumi.Input[bool] with_droplet_agent: Boolean flag to enable metric agent on the Droplet Autoscale pool underlying resource(s). The
               metric agent enables collecting resource utilization metrics, which allows making resource based scaling decisions.
        """
        pulumi.set(__self__, "image", image)
        pulumi.set(__self__, "region", region)
        pulumi.set(__self__, "size", size)
        pulumi.set(__self__, "ssh_keys", ssh_keys)
        if ipv6 is not None:
            pulumi.set(__self__, "ipv6", ipv6)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if user_data is not None:
            pulumi.set(__self__, "user_data", user_data)
        if vpc_uuid is not None:
            pulumi.set(__self__, "vpc_uuid", vpc_uuid)
        if with_droplet_agent is not None:
            pulumi.set(__self__, "with_droplet_agent", with_droplet_agent)

    @property
    @pulumi.getter
    def image(self) -> pulumi.Input[str]:
        """
        Image slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: pulumi.Input[str]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def region(self) -> pulumi.Input[str]:
        """
        Region slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[str]):
        pulumi.set(self, "region", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        Size slug of the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="sshKeys")
    def ssh_keys(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        SSH fingerprints to add to the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "ssh_keys")

    @ssh_keys.setter
    def ssh_keys(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "ssh_keys", value)

    @property
    @pulumi.getter
    def ipv6(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag to enable IPv6 networking on the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "ipv6")

    @ipv6.setter
    def ipv6(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ipv6", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        Project UUID to create the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of tags to add to the Droplet Autoscale pool underlying resource(s).
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter(name="userData")
    def user_data(self) -> Optional[pulumi.Input[str]]:
        """
        Custom user data that can be added to the Droplet Autoscale pool underlying resource(s). This can be a 
        cloud init script that user may configure to setup their application workload.
        """
        return pulumi.get(self, "user_data")

    @user_data.setter
    def user_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_data", value)

    @property
    @pulumi.getter(name="vpcUuid")
    def vpc_uuid(self) -> Optional[pulumi.Input[str]]:
        """
        VPC UUID to create the Droplet Autoscale pool underlying resource(s). If not provided, this is inferred
        from the specified `region` (default VPC).
        """
        return pulumi.get(self, "vpc_uuid")

    @vpc_uuid.setter
    def vpc_uuid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vpc_uuid", value)

    @property
    @pulumi.getter(name="withDropletAgent")
    def with_droplet_agent(self) -> Optional[pulumi.Input[bool]]:
        """
        Boolean flag to enable metric agent on the Droplet Autoscale pool underlying resource(s). The
        metric agent enables collecting resource utilization metrics, which allows making resource based scaling decisions.
        """
        return pulumi.get(self, "with_droplet_agent")

    @with_droplet_agent.setter
    def with_droplet_agent(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "with_droplet_agent", value)


if not MYPY:
    class DropletBackupPolicyArgsDict(TypedDict):
        hour: NotRequired[pulumi.Input[int]]
        """
        The hour of the day that the backup window will start (`0`, `4`, `8`, `12`, `16`, `20`).
        """
        plan: NotRequired[pulumi.Input[str]]
        """
        The backup plan used for the Droplet. The plan can be either `daily` or `weekly`.
        """
        weekday: NotRequired[pulumi.Input[str]]
        """
        The day of the week on which the backup will occur (`SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`).
        """
elif False:
    DropletBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DropletBackupPolicyArgs:
    def __init__(__self__, *,
                 hour: Optional[pulumi.Input[int]] = None,
                 plan: Optional[pulumi.Input[str]] = None,
                 weekday: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] hour: The hour of the day that the backup window will start (`0`, `4`, `8`, `12`, `16`, `20`).
        :param pulumi.Input[str] plan: The backup plan used for the Droplet. The plan can be either `daily` or `weekly`.
        :param pulumi.Input[str] weekday: The day of the week on which the backup will occur (`SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`).
        """
        if hour is not None:
            pulumi.set(__self__, "hour", hour)
        if plan is not None:
            pulumi.set(__self__, "plan", plan)
        if weekday is not None:
            pulumi.set(__self__, "weekday", weekday)

    @property
    @pulumi.getter
    def hour(self) -> Optional[pulumi.Input[int]]:
        """
        The hour of the day that the backup window will start (`0`, `4`, `8`, `12`, `16`, `20`).
        """
        return pulumi.get(self, "hour")

    @hour.setter
    def hour(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hour", value)

    @property
    @pulumi.getter
    def plan(self) -> Optional[pulumi.Input[str]]:
        """
        The backup plan used for the Droplet. The plan can be either `daily` or `weekly`.
        """
        return pulumi.get(self, "plan")

    @plan.setter
    def plan(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "plan", value)

    @property
    @pulumi.getter
    def weekday(self) -> Optional[pulumi.Input[str]]:
        """
        The day of the week on which the backup will occur (`SUN`, `MON`, `TUE`, `WED`, `THU`, `FRI`, `SAT`).
        """
        return pulumi.get(self, "weekday")

    @weekday.setter
    def weekday(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "weekday", value)


if not MYPY:
    class FirewallInboundRuleArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        port_range: NotRequired[pulumi.Input[str]]
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        source_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        source_droplet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        source_kubernetes_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array containing the IDs of
        the Kubernetes clusters from which the inbound traffic will be accepted.
        """
        source_load_balancer_uids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        source_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array containing the names of Tags
        corresponding to groups of Droplets from which the inbound traffic
        will be accepted.
        """
elif False:
    FirewallInboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallInboundRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 port_range: Optional[pulumi.Input[str]] = None,
                 source_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_droplet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 source_kubernetes_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_load_balancer_uids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 source_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param pulumi.Input[str] port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
               inbound traffic will be accepted.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] source_droplet_ids: An array containing the IDs of
               the Droplets from which the inbound traffic will be accepted.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_kubernetes_ids: An array containing the IDs of
               the Kubernetes clusters from which the inbound traffic will be accepted.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_load_balancer_uids: An array containing the IDs
               of the Load Balancers from which the inbound traffic will be accepted.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_tags: An array containing the names of Tags
               corresponding to groups of Droplets from which the inbound traffic
               will be accepted.
        """
        pulumi.set(__self__, "protocol", protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_droplet_ids is not None:
            pulumi.set(__self__, "source_droplet_ids", source_droplet_ids)
        if source_kubernetes_ids is not None:
            pulumi.set(__self__, "source_kubernetes_ids", source_kubernetes_ids)
        if source_load_balancer_uids is not None:
            pulumi.set(__self__, "source_load_balancer_uids", source_load_balancer_uids)
        if source_tags is not None:
            pulumi.set(__self__, "source_tags", source_tags)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_addresses", value)

    @property
    @pulumi.getter(name="sourceDropletIds")
    def source_droplet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_droplet_ids")

    @source_droplet_ids.setter
    def source_droplet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "source_droplet_ids", value)

    @property
    @pulumi.getter(name="sourceKubernetesIds")
    def source_kubernetes_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array containing the IDs of
        the Kubernetes clusters from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_kubernetes_ids")

    @source_kubernetes_ids.setter
    def source_kubernetes_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_kubernetes_ids", value)

    @property
    @pulumi.getter(name="sourceLoadBalancerUids")
    def source_load_balancer_uids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_load_balancer_uids")

    @source_load_balancer_uids.setter
    def source_load_balancer_uids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_load_balancer_uids", value)

    @property
    @pulumi.getter(name="sourceTags")
    def source_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets from which the inbound traffic
        will be accepted.
        """
        return pulumi.get(self, "source_tags")

    @source_tags.setter
    def source_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "source_tags", value)


if not MYPY:
    class FirewallOutboundRuleArgsDict(TypedDict):
        protocol: pulumi.Input[str]
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        destination_addresses: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        destination_droplet_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        destination_kubernetes_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array containing the IDs of
        the Kubernetes clusters to which the outbound traffic will be allowed.
        """
        destination_load_balancer_uids: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        destination_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        """
        port_range: NotRequired[pulumi.Input[str]]
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
elif False:
    FirewallOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallOutboundRuleArgs:
    def __init__(__self__, *,
                 protocol: pulumi.Input[str],
                 destination_addresses: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_droplet_ids: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 destination_kubernetes_ids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_load_balancer_uids: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 destination_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 port_range: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
               outbound traffic will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] destination_droplet_ids: An array containing the IDs of
               the Droplets to which the outbound traffic will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_kubernetes_ids: An array containing the IDs of
               the Kubernetes clusters to which the outbound traffic will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_load_balancer_uids: An array containing the IDs
               of the Load Balancers to which the outbound traffic will be allowed.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_tags: An array containing the names of Tags
               corresponding to groups of Droplets to which the outbound traffic will
               be allowed.
        :param pulumi.Input[str] port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        """
        pulumi.set(__self__, "protocol", protocol)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_droplet_ids is not None:
            pulumi.set(__self__, "destination_droplet_ids", destination_droplet_ids)
        if destination_kubernetes_ids is not None:
            pulumi.set(__self__, "destination_kubernetes_ids", destination_kubernetes_ids)
        if destination_load_balancer_uids is not None:
            pulumi.set(__self__, "destination_load_balancer_uids", destination_load_balancer_uids)
        if destination_tags is not None:
            pulumi.set(__self__, "destination_tags", destination_tags)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_addresses", value)

    @property
    @pulumi.getter(name="destinationDropletIds")
    def destination_droplet_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_droplet_ids")

    @destination_droplet_ids.setter
    def destination_droplet_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "destination_droplet_ids", value)

    @property
    @pulumi.getter(name="destinationKubernetesIds")
    def destination_kubernetes_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array containing the IDs of
        the Kubernetes clusters to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_kubernetes_ids")

    @destination_kubernetes_ids.setter
    def destination_kubernetes_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_kubernetes_ids", value)

    @property
    @pulumi.getter(name="destinationLoadBalancerUids")
    def destination_load_balancer_uids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_load_balancer_uids")

    @destination_load_balancer_uids.setter
    def destination_load_balancer_uids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_load_balancer_uids", value)

    @property
    @pulumi.getter(name="destinationTags")
    def destination_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        """
        return pulumi.get(self, "destination_tags")

    @destination_tags.setter
    def destination_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "destination_tags", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[pulumi.Input[str]]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "port_range", value)


if not MYPY:
    class FirewallPendingChangeArgsDict(TypedDict):
        droplet_id: NotRequired[pulumi.Input[int]]
        removing: NotRequired[pulumi.Input[bool]]
        status: NotRequired[pulumi.Input[str]]
        """
        A status string indicating the current state of the Firewall.
        This can be "waiting", "succeeded", or "failed".
        """
elif False:
    FirewallPendingChangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallPendingChangeArgs:
    def __init__(__self__, *,
                 droplet_id: Optional[pulumi.Input[int]] = None,
                 removing: Optional[pulumi.Input[bool]] = None,
                 status: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] status: A status string indicating the current state of the Firewall.
               This can be "waiting", "succeeded", or "failed".
        """
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if removing is not None:
            pulumi.set(__self__, "removing", removing)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[int]]:
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "droplet_id", value)

    @property
    @pulumi.getter
    def removing(self) -> Optional[pulumi.Input[bool]]:
        return pulumi.get(self, "removing")

    @removing.setter
    def removing(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "removing", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        A status string indicating the current state of the Firewall.
        This can be "waiting", "succeeded", or "failed".
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class KubernetesClusterKubeConfigArgsDict(TypedDict):
        client_certificate: NotRequired[pulumi.Input[str]]
        """
        The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        cluster_ca_certificate: NotRequired[pulumi.Input[str]]
        """
        The base64 encoded public certificate for the cluster's certificate authority.
        """
        expires_at: NotRequired[pulumi.Input[str]]
        """
        The date and time when the credentials will expire and need to be regenerated.
        """
        host: NotRequired[pulumi.Input[str]]
        """
        The URL of the API server on the Kubernetes master node.
        """
        raw_config: NotRequired[pulumi.Input[str]]
        """
        The full contents of the Kubernetes cluster's kubeconfig file.
        """
        token: NotRequired[pulumi.Input[str]]
        """
        The DigitalOcean API access token used by clients to access the cluster.
        """
elif False:
    KubernetesClusterKubeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterKubeConfigArgs:
    def __init__(__self__, *,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 cluster_ca_certificate: Optional[pulumi.Input[str]] = None,
                 expires_at: Optional[pulumi.Input[str]] = None,
                 host: Optional[pulumi.Input[str]] = None,
                 raw_config: Optional[pulumi.Input[str]] = None,
                 token: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] client_certificate: The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param pulumi.Input[str] client_key: The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        :param pulumi.Input[str] cluster_ca_certificate: The base64 encoded public certificate for the cluster's certificate authority.
        :param pulumi.Input[str] expires_at: The date and time when the credentials will expire and need to be regenerated.
        :param pulumi.Input[str] host: The URL of the API server on the Kubernetes master node.
        :param pulumi.Input[str] raw_config: The full contents of the Kubernetes cluster's kubeconfig file.
        :param pulumi.Input[str] token: The DigitalOcean API access token used by clients to access the cluster.
        """
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if cluster_ca_certificate is not None:
            pulumi.set(__self__, "cluster_ca_certificate", cluster_ca_certificate)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if host is not None:
            pulumi.set(__self__, "host", host)
        if raw_config is not None:
            pulumi.set(__self__, "raw_config", raw_config)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded public certificate used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded private key used by clients to access the cluster. Only available if token authentication is not supported on your cluster.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clusterCaCertificate")
    def cluster_ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The base64 encoded public certificate for the cluster's certificate authority.
        """
        return pulumi.get(self, "cluster_ca_certificate")

    @cluster_ca_certificate.setter
    def cluster_ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_ca_certificate", value)

    @property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the credentials will expire and need to be regenerated.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expires_at", value)

    @property
    @pulumi.getter
    def host(self) -> Optional[pulumi.Input[str]]:
        """
        The URL of the API server on the Kubernetes master node.
        """
        return pulumi.get(self, "host")

    @host.setter
    def host(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host", value)

    @property
    @pulumi.getter(name="rawConfig")
    def raw_config(self) -> Optional[pulumi.Input[str]]:
        """
        The full contents of the Kubernetes cluster's kubeconfig file.
        """
        return pulumi.get(self, "raw_config")

    @raw_config.setter
    def raw_config(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "raw_config", value)

    @property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[str]]:
        """
        The DigitalOcean API access token used by clients to access the cluster.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class KubernetesClusterMaintenancePolicyArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[str]]
        """
        The day of the maintenance window policy. May be one of "monday" through "sunday", or "any" to indicate an arbitrary week day.
        """
        duration: NotRequired[pulumi.Input[str]]
        """
        A string denoting the duration of the service window, e.g., "04:00".
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        The start time in UTC of the maintenance window policy in 24-hour clock format / HH:MM notation (e.g., 15:00).
        """
elif False:
    KubernetesClusterMaintenancePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterMaintenancePolicyArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[str]] = None,
                 duration: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] day: The day of the maintenance window policy. May be one of "monday" through "sunday", or "any" to indicate an arbitrary week day.
        :param pulumi.Input[str] duration: A string denoting the duration of the service window, e.g., "04:00".
        :param pulumi.Input[str] start_time: The start time in UTC of the maintenance window policy in 24-hour clock format / HH:MM notation (e.g., 15:00).
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[str]]:
        """
        The day of the maintenance window policy. May be one of "monday" through "sunday", or "any" to indicate an arbitrary week day.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[str]]:
        """
        A string denoting the duration of the service window, e.g., "04:00".
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        The start time in UTC of the maintenance window policy in 24-hour clock format / HH:MM notation (e.g., 15:00).
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class KubernetesClusterNodePoolArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        A name for the node pool.
        """
        size: pulumi.Input[str]
        """
        The slug identifier for the type of Droplet to be used as workers in the node pool.
        """
        actual_node_count: NotRequired[pulumi.Input[int]]
        """
        A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        """
        auto_scale: NotRequired[pulumi.Input[bool]]
        """
        Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        """
        id: NotRequired[pulumi.Input[str]]
        """
        A unique ID that can be used to identify and reference the node.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        """
        max_nodes: NotRequired[pulumi.Input[int]]
        """
        If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        """
        min_nodes: NotRequired[pulumi.Input[int]]
        """
        If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        """
        node_count: NotRequired[pulumi.Input[int]]
        """
        The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        """
        nodes: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgsDict']]]]
        """
        A list of nodes in the pool. Each node exports the following attributes:
        """
        tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of tag names applied to the node pool.
        """
        taints: NotRequired[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgsDict']]]]
        """
        A block representing a taint applied to all nodes in the pool. Each taint exports the following attributes (taints must be unique by key and effect pair):
        """
elif False:
    KubernetesClusterNodePoolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterNodePoolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 size: pulumi.Input[str],
                 actual_node_count: Optional[pulumi.Input[int]] = None,
                 auto_scale: Optional[pulumi.Input[bool]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 max_nodes: Optional[pulumi.Input[int]] = None,
                 min_nodes: Optional[pulumi.Input[int]] = None,
                 node_count: Optional[pulumi.Input[int]] = None,
                 nodes: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgs']]]] = None):
        """
        :param pulumi.Input[str] name: A name for the node pool.
        :param pulumi.Input[str] size: The slug identifier for the type of Droplet to be used as workers in the node pool.
        :param pulumi.Input[int] actual_node_count: A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        :param pulumi.Input[bool] auto_scale: Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        :param pulumi.Input[str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        :param pulumi.Input[int] max_nodes: If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        :param pulumi.Input[int] min_nodes: If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        :param pulumi.Input[int] node_count: The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]] nodes: A list of nodes in the pool. Each node exports the following attributes:
        :param pulumi.Input[Sequence[pulumi.Input[str]]] tags: A list of tag names applied to the node pool.
        :param pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgs']]] taints: A block representing a taint applied to all nodes in the pool. Each taint exports the following attributes (taints must be unique by key and effect pair):
        """
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "size", size)
        if actual_node_count is not None:
            pulumi.set(__self__, "actual_node_count", actual_node_count)
        if auto_scale is not None:
            pulumi.set(__self__, "auto_scale", auto_scale)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if max_nodes is not None:
            pulumi.set(__self__, "max_nodes", max_nodes)
        if min_nodes is not None:
            pulumi.set(__self__, "min_nodes", min_nodes)
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)
        if nodes is not None:
            pulumi.set(__self__, "nodes", nodes)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def size(self) -> pulumi.Input[str]:
        """
        The slug identifier for the type of Droplet to be used as workers in the node pool.
        """
        return pulumi.get(self, "size")

    @size.setter
    def size(self, value: pulumi.Input[str]):
        pulumi.set(self, "size", value)

    @property
    @pulumi.getter(name="actualNodeCount")
    def actual_node_count(self) -> Optional[pulumi.Input[int]]:
        """
        A computed field representing the actual number of nodes in the node pool, which is especially useful when auto-scaling is enabled.
        """
        return pulumi.get(self, "actual_node_count")

    @actual_node_count.setter
    def actual_node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "actual_node_count", value)

    @property
    @pulumi.getter(name="autoScale")
    def auto_scale(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable auto-scaling of the number of nodes in the node pool within the given min/max range.
        """
        return pulumi.get(self, "auto_scale")

    @auto_scale.setter
    def auto_scale(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "auto_scale", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key/value pairs to apply to nodes in the pool. The labels are exposed in the Kubernetes API as labels in the metadata of the corresponding [Node resources](https://kubernetes.io/docs/concepts/architecture/nodes/).
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        If auto-scaling is enabled, this represents the maximum number of nodes that the node pool can be scaled up to.
        """
        return pulumi.get(self, "max_nodes")

    @max_nodes.setter
    def max_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_nodes", value)

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> Optional[pulumi.Input[int]]:
        """
        If auto-scaling is enabled, this represents the minimum number of nodes that the node pool can be scaled down to.
        """
        return pulumi.get(self, "min_nodes")

    @min_nodes.setter
    def min_nodes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_nodes", value)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of Droplet instances in the node pool. If auto-scaling is enabled, this should only be set if the desired result is to explicitly reset the number of nodes to this value. If auto-scaling is enabled, and the node count is outside of the given min/max range, it will use the min nodes value.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter
    def nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]]:
        """
        A list of nodes in the pool. Each node exports the following attributes:
        """
        return pulumi.get(self, "nodes")

    @nodes.setter
    def nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolNodeArgs']]]]):
        pulumi.set(self, "nodes", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of tag names applied to the node pool.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "tags", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgs']]]]:
        """
        A block representing a taint applied to all nodes in the pool. Each taint exports the following attributes (taints must be unique by key and effect pair):
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KubernetesClusterNodePoolTaintArgs']]]]):
        pulumi.set(self, "taints", value)


if not MYPY:
    class KubernetesClusterNodePoolNodeArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        """
        The date and time when the node was created.
        """
        droplet_id: NotRequired[pulumi.Input[str]]
        """
        The id of the node's droplet
        """
        id: NotRequired[pulumi.Input[str]]
        """
        A unique ID that can be used to identify and reference the node.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A name for the Kubernetes cluster.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        A string indicating the current status of the individual node.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        The date and time when the node was last updated.
        """
elif False:
    KubernetesClusterNodePoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterNodePoolNodeArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 droplet_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] created_at: The date and time when the node was created.
        :param pulumi.Input[str] droplet_id: The id of the node's droplet
        :param pulumi.Input[str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[str] name: A name for the Kubernetes cluster.
        :param pulumi.Input[str] status: A string indicating the current status of the individual node.
        :param pulumi.Input[str] updated_at: The date and time when the node was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the node's droplet
        """
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "droplet_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the Kubernetes cluster.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class KubernetesClusterNodePoolTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        key: pulumi.Input[str]
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        value: pulumi.Input[str]
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
elif False:
    KubernetesClusterNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesClusterNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        :param pulumi.Input[str] key: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        :param pulumi.Input[str] value: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class KubernetesNodePoolNodeArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[str]]
        """
        The date and time when the node was created.
        """
        droplet_id: NotRequired[pulumi.Input[str]]
        """
        The id of the node's droplet
        """
        id: NotRequired[pulumi.Input[str]]
        """
        A unique ID that can be used to identify and reference the node.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        A name for the node pool.
        """
        status: NotRequired[pulumi.Input[str]]
        """
        A string indicating the current status of the individual node.
        """
        updated_at: NotRequired[pulumi.Input[str]]
        """
        The date and time when the node was last updated.
        """
elif False:
    KubernetesNodePoolNodeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolNodeArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[str]] = None,
                 droplet_id: Optional[pulumi.Input[str]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 status: Optional[pulumi.Input[str]] = None,
                 updated_at: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] created_at: The date and time when the node was created.
        :param pulumi.Input[str] droplet_id: The id of the node's droplet
        :param pulumi.Input[str] id: A unique ID that can be used to identify and reference the node.
        :param pulumi.Input[str] name: A name for the node pool.
        :param pulumi.Input[str] status: A string indicating the current status of the individual node.
        :param pulumi.Input[str] updated_at: The date and time when the node was last updated.
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if droplet_id is not None:
            pulumi.set(__self__, "droplet_id", droplet_id)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if updated_at is not None:
            pulumi.set(__self__, "updated_at", updated_at)

    @property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the node was created.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_at", value)

    @property
    @pulumi.getter(name="dropletId")
    def droplet_id(self) -> Optional[pulumi.Input[str]]:
        """
        The id of the node's droplet
        """
        return pulumi.get(self, "droplet_id")

    @droplet_id.setter
    def droplet_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "droplet_id", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        A unique ID that can be used to identify and reference the node.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        A name for the node pool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[str]]:
        """
        A string indicating the current status of the individual node.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "status", value)

    @property
    @pulumi.getter(name="updatedAt")
    def updated_at(self) -> Optional[pulumi.Input[str]]:
        """
        The date and time when the node was last updated.
        """
        return pulumi.get(self, "updated_at")

    @updated_at.setter
    def updated_at(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "updated_at", value)


if not MYPY:
    class KubernetesNodePoolTaintArgsDict(TypedDict):
        effect: pulumi.Input[str]
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        key: pulumi.Input[str]
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        value: pulumi.Input[str]
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
elif False:
    KubernetesNodePoolTaintArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KubernetesNodePoolTaintArgs:
    def __init__(__self__, *,
                 effect: pulumi.Input[str],
                 key: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] effect: How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        :param pulumi.Input[str] key: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        :param pulumi.Input[str] value: An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        pulumi.set(__self__, "effect", effect)
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> pulumi.Input[str]:
        """
        How the node reacts to pods that it won't tolerate. Available effect values are: "NoSchedule", "PreferNoSchedule", "NoExecute".
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: pulumi.Input[str]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        An arbitrary string. The "key" and "value" fields of the "taint" object form a key-value pair.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class LoadBalancerDomainArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The domain name to be used for ingressing traffic to a Global Load Balancer.
        """
        certificate_name: NotRequired[pulumi.Input[str]]
        """
        name of certificate required for TLS handshaking
        """
        is_managed: NotRequired[pulumi.Input[bool]]
        """
        Control flag to specify whether the domain is managed by DigitalOcean.
        """
        ssl_validation_error_reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list of domain SSL validation errors
        """
        verification_error_reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        list of domain verification errors
        """
elif False:
    LoadBalancerDomainArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerDomainArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 certificate_name: Optional[pulumi.Input[str]] = None,
                 is_managed: Optional[pulumi.Input[bool]] = None,
                 ssl_validation_error_reasons: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 verification_error_reasons: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] name: The domain name to be used for ingressing traffic to a Global Load Balancer.
        :param pulumi.Input[str] certificate_name: name of certificate required for TLS handshaking
        :param pulumi.Input[bool] is_managed: Control flag to specify whether the domain is managed by DigitalOcean.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ssl_validation_error_reasons: list of domain SSL validation errors
        :param pulumi.Input[Sequence[pulumi.Input[str]]] verification_error_reasons: list of domain verification errors
        """
        pulumi.set(__self__, "name", name)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if is_managed is not None:
            pulumi.set(__self__, "is_managed", is_managed)
        if ssl_validation_error_reasons is not None:
            pulumi.set(__self__, "ssl_validation_error_reasons", ssl_validation_error_reasons)
        if verification_error_reasons is not None:
            pulumi.set(__self__, "verification_error_reasons", verification_error_reasons)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The domain name to be used for ingressing traffic to a Global Load Balancer.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[str]]:
        """
        name of certificate required for TLS handshaking
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_name", value)

    @property
    @pulumi.getter(name="isManaged")
    def is_managed(self) -> Optional[pulumi.Input[bool]]:
        """
        Control flag to specify whether the domain is managed by DigitalOcean.
        """
        return pulumi.get(self, "is_managed")

    @is_managed.setter
    def is_managed(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_managed", value)

    @property
    @pulumi.getter(name="sslValidationErrorReasons")
    def ssl_validation_error_reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of domain SSL validation errors
        """
        return pulumi.get(self, "ssl_validation_error_reasons")

    @ssl_validation_error_reasons.setter
    def ssl_validation_error_reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ssl_validation_error_reasons", value)

    @property
    @pulumi.getter(name="verificationErrorReasons")
    def verification_error_reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        list of domain verification errors
        """
        return pulumi.get(self, "verification_error_reasons")

    @verification_error_reasons.setter
    def verification_error_reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "verification_error_reasons", value)


if not MYPY:
    class LoadBalancerFirewallArgsDict(TypedDict):
        allows: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of strings describing allow rules. Must be colon delimited strings of the form `{type}:{source}`
        * Ex. `deny = ["cidr:1.2.0.0/16", "ip:2.3.4.5"]` or `allow = ["ip:1.2.3.4", "cidr:2.3.4.0/24"]`
        """
        denies: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of strings describing deny rules. Must be colon delimited strings of the form `{type}:{source}`
        """
elif False:
    LoadBalancerFirewallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerFirewallArgs:
    def __init__(__self__, *,
                 allows: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 denies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allows: A list of strings describing allow rules. Must be colon delimited strings of the form `{type}:{source}`
               * Ex. `deny = ["cidr:1.2.0.0/16", "ip:2.3.4.5"]` or `allow = ["ip:1.2.3.4", "cidr:2.3.4.0/24"]`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] denies: A list of strings describing deny rules. Must be colon delimited strings of the form `{type}:{source}`
        """
        if allows is not None:
            pulumi.set(__self__, "allows", allows)
        if denies is not None:
            pulumi.set(__self__, "denies", denies)

    @property
    @pulumi.getter
    def allows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings describing allow rules. Must be colon delimited strings of the form `{type}:{source}`
        * Ex. `deny = ["cidr:1.2.0.0/16", "ip:2.3.4.5"]` or `allow = ["ip:1.2.3.4", "cidr:2.3.4.0/24"]`
        """
        return pulumi.get(self, "allows")

    @allows.setter
    def allows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allows", value)

    @property
    @pulumi.getter
    def denies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of strings describing deny rules. Must be colon delimited strings of the form `{type}:{source}`
        """
        return pulumi.get(self, "denies")

    @denies.setter
    def denies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "denies", value)


if not MYPY:
    class LoadBalancerForwardingRuleArgsDict(TypedDict):
        entry_port: pulumi.Input[int]
        """
        An integer representing the port on which the Load Balancer instance will listen.
        """
        entry_protocol: pulumi.Input[str]
        """
        The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`.
        """
        target_port: pulumi.Input[int]
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        """
        target_protocol: pulumi.Input[str]
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`.
        """
        certificate_id: NotRequired[pulumi.Input[str]]
        """
        **Deprecated** The ID of the TLS certificate to be used for SSL termination.
        """
        certificate_name: NotRequired[pulumi.Input[str]]
        """
        The unique name of the TLS certificate to be used for SSL termination.
        """
        tls_passthrough: NotRequired[pulumi.Input[bool]]
        """
        A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
elif False:
    LoadBalancerForwardingRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerForwardingRuleArgs:
    def __init__(__self__, *,
                 entry_port: pulumi.Input[int],
                 entry_protocol: pulumi.Input[str],
                 target_port: pulumi.Input[int],
                 target_protocol: pulumi.Input[str],
                 certificate_id: Optional[pulumi.Input[str]] = None,
                 certificate_name: Optional[pulumi.Input[str]] = None,
                 tls_passthrough: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] entry_port: An integer representing the port on which the Load Balancer instance will listen.
        :param pulumi.Input[str] entry_protocol: The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`.
        :param pulumi.Input[int] target_port: An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        :param pulumi.Input[str] target_protocol: The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`.
        :param pulumi.Input[str] certificate_id: **Deprecated** The ID of the TLS certificate to be used for SSL termination.
        :param pulumi.Input[str] certificate_name: The unique name of the TLS certificate to be used for SSL termination.
        :param pulumi.Input[bool] tls_passthrough: A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
        pulumi.set(__self__, "entry_port", entry_port)
        pulumi.set(__self__, "entry_protocol", entry_protocol)
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if certificate_id is not None:
            warnings.warn("""Certificate IDs may change, for example when a Let's Encrypt certificate is auto-renewed. Please specify 'certificate_name' instead.""", DeprecationWarning)
            pulumi.log.warn("""certificate_id is deprecated: Certificate IDs may change, for example when a Let's Encrypt certificate is auto-renewed. Please specify 'certificate_name' instead.""")
        if certificate_id is not None:
            pulumi.set(__self__, "certificate_id", certificate_id)
        if certificate_name is not None:
            pulumi.set(__self__, "certificate_name", certificate_name)
        if tls_passthrough is not None:
            pulumi.set(__self__, "tls_passthrough", tls_passthrough)

    @property
    @pulumi.getter(name="entryPort")
    def entry_port(self) -> pulumi.Input[int]:
        """
        An integer representing the port on which the Load Balancer instance will listen.
        """
        return pulumi.get(self, "entry_port")

    @entry_port.setter
    def entry_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "entry_port", value)

    @property
    @pulumi.getter(name="entryProtocol")
    def entry_protocol(self) -> pulumi.Input[str]:
        """
        The protocol used for traffic to the Load Balancer. The possible values are: `http`, `https`, `http2`, `http3`, `tcp`, or `udp`.
        """
        return pulumi.get(self, "entry_protocol")

    @entry_protocol.setter
    def entry_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "entry_protocol", value)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[int]:
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "target_port", value)

    @property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> pulumi.Input[str]:
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http`, `https`, `http2`, `tcp`, or `udp`.
        """
        return pulumi.get(self, "target_protocol")

    @target_protocol.setter
    def target_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_protocol", value)

    @property
    @pulumi.getter(name="certificateId")
    @_utilities.deprecated("""Certificate IDs may change, for example when a Let's Encrypt certificate is auto-renewed. Please specify 'certificate_name' instead.""")
    def certificate_id(self) -> Optional[pulumi.Input[str]]:
        """
        **Deprecated** The ID of the TLS certificate to be used for SSL termination.
        """
        return pulumi.get(self, "certificate_id")

    @certificate_id.setter
    def certificate_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_id", value)

    @property
    @pulumi.getter(name="certificateName")
    def certificate_name(self) -> Optional[pulumi.Input[str]]:
        """
        The unique name of the TLS certificate to be used for SSL termination.
        """
        return pulumi.get(self, "certificate_name")

    @certificate_name.setter
    def certificate_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "certificate_name", value)

    @property
    @pulumi.getter(name="tlsPassthrough")
    def tls_passthrough(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value indicating whether SSL encrypted traffic will be passed through to the backend Droplets. The default value is `false`.
        """
        return pulumi.get(self, "tls_passthrough")

    @tls_passthrough.setter
    def tls_passthrough(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "tls_passthrough", value)


if not MYPY:
    class LoadBalancerGlbSettingsArgsDict(TypedDict):
        target_port: pulumi.Input[int]
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic. The possible values are: `80` for `http` and `443` for `https`.
        """
        target_protocol: pulumi.Input[str]
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http` and `https`.
        """
        cdn: NotRequired[pulumi.Input['LoadBalancerGlbSettingsCdnArgsDict']]
        """
        CDN configuration supporting the following:
        """
        failover_threshold: NotRequired[pulumi.Input[int]]
        """
        fail-over threshold
        """
        region_priorities: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[int]]]]
        """
        region priority map
        """
elif False:
    LoadBalancerGlbSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerGlbSettingsArgs:
    def __init__(__self__, *,
                 target_port: pulumi.Input[int],
                 target_protocol: pulumi.Input[str],
                 cdn: Optional[pulumi.Input['LoadBalancerGlbSettingsCdnArgs']] = None,
                 failover_threshold: Optional[pulumi.Input[int]] = None,
                 region_priorities: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[int] target_port: An integer representing the port on the backend Droplets to which the Load Balancer will send traffic. The possible values are: `80` for `http` and `443` for `https`.
        :param pulumi.Input[str] target_protocol: The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http` and `https`.
        :param pulumi.Input['LoadBalancerGlbSettingsCdnArgs'] cdn: CDN configuration supporting the following:
        :param pulumi.Input[int] failover_threshold: fail-over threshold
        :param pulumi.Input[Mapping[str, pulumi.Input[int]]] region_priorities: region priority map
        """
        pulumi.set(__self__, "target_port", target_port)
        pulumi.set(__self__, "target_protocol", target_protocol)
        if cdn is not None:
            pulumi.set(__self__, "cdn", cdn)
        if failover_threshold is not None:
            pulumi.set(__self__, "failover_threshold", failover_threshold)
        if region_priorities is not None:
            pulumi.set(__self__, "region_priorities", region_priorities)

    @property
    @pulumi.getter(name="targetPort")
    def target_port(self) -> pulumi.Input[int]:
        """
        An integer representing the port on the backend Droplets to which the Load Balancer will send traffic. The possible values are: `80` for `http` and `443` for `https`.
        """
        return pulumi.get(self, "target_port")

    @target_port.setter
    def target_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "target_port", value)

    @property
    @pulumi.getter(name="targetProtocol")
    def target_protocol(self) -> pulumi.Input[str]:
        """
        The protocol used for traffic from the Load Balancer to the backend Droplets. The possible values are: `http` and `https`.
        """
        return pulumi.get(self, "target_protocol")

    @target_protocol.setter
    def target_protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "target_protocol", value)

    @property
    @pulumi.getter
    def cdn(self) -> Optional[pulumi.Input['LoadBalancerGlbSettingsCdnArgs']]:
        """
        CDN configuration supporting the following:
        """
        return pulumi.get(self, "cdn")

    @cdn.setter
    def cdn(self, value: Optional[pulumi.Input['LoadBalancerGlbSettingsCdnArgs']]):
        pulumi.set(self, "cdn", value)

    @property
    @pulumi.getter(name="failoverThreshold")
    def failover_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        fail-over threshold
        """
        return pulumi.get(self, "failover_threshold")

    @failover_threshold.setter
    def failover_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "failover_threshold", value)

    @property
    @pulumi.getter(name="regionPriorities")
    def region_priorities(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]:
        """
        region priority map
        """
        return pulumi.get(self, "region_priorities")

    @region_priorities.setter
    def region_priorities(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[int]]]]):
        pulumi.set(self, "region_priorities", value)


if not MYPY:
    class LoadBalancerGlbSettingsCdnArgsDict(TypedDict):
        is_enabled: NotRequired[pulumi.Input[bool]]
        """
        Control flag to specify if caching is enabled.
        """
elif False:
    LoadBalancerGlbSettingsCdnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerGlbSettingsCdnArgs:
    def __init__(__self__, *,
                 is_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] is_enabled: Control flag to specify if caching is enabled.
        """
        if is_enabled is not None:
            pulumi.set(__self__, "is_enabled", is_enabled)

    @property
    @pulumi.getter(name="isEnabled")
    def is_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Control flag to specify if caching is enabled.
        """
        return pulumi.get(self, "is_enabled")

    @is_enabled.setter
    def is_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "is_enabled", value)


if not MYPY:
    class LoadBalancerHealthcheckArgsDict(TypedDict):
        port: pulumi.Input[int]
        """
        An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        """
        protocol: pulumi.Input[str]
        """
        The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https` or `tcp`.
        """
        check_interval_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds between two consecutive health checks. If not specified, the default value is `10`.
        """
        healthy_threshold: NotRequired[pulumi.Input[int]]
        """
        The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        The path on the backend Droplets to which the Load Balancer instance will send a request.
        """
        response_timeout_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        """
        unhealthy_threshold: NotRequired[pulumi.Input[int]]
        """
        The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
elif False:
    LoadBalancerHealthcheckArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerHealthcheckArgs:
    def __init__(__self__, *,
                 port: pulumi.Input[int],
                 protocol: pulumi.Input[str],
                 check_interval_seconds: Optional[pulumi.Input[int]] = None,
                 healthy_threshold: Optional[pulumi.Input[int]] = None,
                 path: Optional[pulumi.Input[str]] = None,
                 response_timeout_seconds: Optional[pulumi.Input[int]] = None,
                 unhealthy_threshold: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] port: An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        :param pulumi.Input[str] protocol: The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https` or `tcp`.
        :param pulumi.Input[int] check_interval_seconds: The number of seconds between two consecutive health checks. If not specified, the default value is `10`.
        :param pulumi.Input[int] healthy_threshold: The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        :param pulumi.Input[str] path: The path on the backend Droplets to which the Load Balancer instance will send a request.
        :param pulumi.Input[int] response_timeout_seconds: The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        :param pulumi.Input[int] unhealthy_threshold: The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
        pulumi.set(__self__, "port", port)
        pulumi.set(__self__, "protocol", protocol)
        if check_interval_seconds is not None:
            pulumi.set(__self__, "check_interval_seconds", check_interval_seconds)
        if healthy_threshold is not None:
            pulumi.set(__self__, "healthy_threshold", healthy_threshold)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if response_timeout_seconds is not None:
            pulumi.set(__self__, "response_timeout_seconds", response_timeout_seconds)
        if unhealthy_threshold is not None:
            pulumi.set(__self__, "unhealthy_threshold", unhealthy_threshold)

    @property
    @pulumi.getter
    def port(self) -> pulumi.Input[int]:
        """
        An integer representing the port on the backend Droplets on which the health check will attempt a connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: pulumi.Input[int]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[str]:
        """
        The protocol used for health checks sent to the backend Droplets. The possible values are `http`, `https` or `tcp`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[str]):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="checkIntervalSeconds")
    def check_interval_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds between two consecutive health checks. If not specified, the default value is `10`.
        """
        return pulumi.get(self, "check_interval_seconds")

    @check_interval_seconds.setter
    def check_interval_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "check_interval_seconds", value)

    @property
    @pulumi.getter(name="healthyThreshold")
    def healthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times a health check must pass for a backend Droplet to be marked "healthy" and be re-added to the pool. If not specified, the default value is `5`.
        """
        return pulumi.get(self, "healthy_threshold")

    @healthy_threshold.setter
    def healthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "healthy_threshold", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        The path on the backend Droplets to which the Load Balancer instance will send a request.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="responseTimeoutSeconds")
    def response_timeout_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds the Load Balancer instance will wait for a response until marking a health check as failed. If not specified, the default value is `5`.
        """
        return pulumi.get(self, "response_timeout_seconds")

    @response_timeout_seconds.setter
    def response_timeout_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "response_timeout_seconds", value)

    @property
    @pulumi.getter(name="unhealthyThreshold")
    def unhealthy_threshold(self) -> Optional[pulumi.Input[int]]:
        """
        The number of times a health check must fail for a backend Droplet to be marked "unhealthy" and be removed from the pool. If not specified, the default value is `3`.
        """
        return pulumi.get(self, "unhealthy_threshold")

    @unhealthy_threshold.setter
    def unhealthy_threshold(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "unhealthy_threshold", value)


if not MYPY:
    class LoadBalancerStickySessionsArgsDict(TypedDict):
        cookie_name: NotRequired[pulumi.Input[str]]
        """
        The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        """
        cookie_ttl_seconds: NotRequired[pulumi.Input[int]]
        """
        The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
elif False:
    LoadBalancerStickySessionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LoadBalancerStickySessionsArgs:
    def __init__(__self__, *,
                 cookie_name: Optional[pulumi.Input[str]] = None,
                 cookie_ttl_seconds: Optional[pulumi.Input[int]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] cookie_name: The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        :param pulumi.Input[int] cookie_ttl_seconds: The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        :param pulumi.Input[str] type: An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
        if cookie_name is not None:
            pulumi.set(__self__, "cookie_name", cookie_name)
        if cookie_ttl_seconds is not None:
            pulumi.set(__self__, "cookie_ttl_seconds", cookie_ttl_seconds)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="cookieName")
    def cookie_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name to be used for the cookie sent to the client. This attribute is required when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_name")

    @cookie_name.setter
    def cookie_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cookie_name", value)

    @property
    @pulumi.getter(name="cookieTtlSeconds")
    def cookie_ttl_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The number of seconds until the cookie set by the Load Balancer expires. This attribute is required when using `cookies` for the sticky sessions type.
        """
        return pulumi.get(self, "cookie_ttl_seconds")

    @cookie_ttl_seconds.setter
    def cookie_ttl_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cookie_ttl_seconds", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        An attribute indicating how and if requests from a client will be persistently served by the same backend Droplet. The possible values are `cookies` or `none`. If not specified, the default value is `none`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class MonitorAlertAlertsArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of email addresses to sent notifications to
        """
        slacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['MonitorAlertAlertsSlackArgsDict']]]]
elif False:
    MonitorAlertAlertsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorAlertAlertsArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 slacks: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorAlertAlertsSlackArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: List of email addresses to sent notifications to
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of email addresses to sent notifications to
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def slacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MonitorAlertAlertsSlackArgs']]]]:
        return pulumi.get(self, "slacks")

    @slacks.setter
    def slacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MonitorAlertAlertsSlackArgs']]]]):
        pulumi.set(self, "slacks", value)


if not MYPY:
    class MonitorAlertAlertsSlackArgsDict(TypedDict):
        channel: pulumi.Input[str]
        """
        The Slack channel to send alerts to
        """
        url: pulumi.Input[str]
        """
        The webhook URL for Slack
        """
elif False:
    MonitorAlertAlertsSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MonitorAlertAlertsSlackArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] channel: The Slack channel to send alerts to
        :param pulumi.Input[str] url: The webhook URL for Slack
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def channel(self) -> pulumi.Input[str]:
        """
        The Slack channel to send alerts to
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The webhook URL for Slack
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class SpacesBucketCorsConfigurationCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of Headers that are specified in the Access-Control-Request-Headers header.
        """
        expose_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        max_age_seconds: NotRequired[pulumi.Input[int]]
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
elif False:
    SpacesBucketCorsConfigurationCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketCorsConfigurationCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 expose_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 max_age_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: Set of origins you want customers to be able to access the bucket from.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: Set of Headers that are specified in the Access-Control-Request-Headers header.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] expose_headers: Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        :param pulumi.Input[str] id: Unique identifier for the rule. The value cannot be longer than 255 characters.
        :param pulumi.Input[int] max_age_seconds: Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if expose_headers is not None:
            pulumi.set(__self__, "expose_headers", expose_headers)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of HTTP methods that you allow the origin to execute. Valid values are GET, PUT, HEAD, POST, and DELETE.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Set of origins you want customers to be able to access the bucket from.
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of Headers that are specified in the Access-Control-Request-Headers header.
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="exposeHeaders")
    def expose_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Set of headers in the response that you want customers to be able to access from their applications (for example, from a JavaScript XMLHttpRequest object).
        """
        return pulumi.get(self, "expose_headers")

    @expose_headers.setter
    def expose_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "expose_headers", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the rule. The value cannot be longer than 255 characters.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Time in seconds that your browser is to cache the preflight response for the specified resource.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class SpacesBucketCorsRuleArgsDict(TypedDict):
        allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        """
        allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        """
        allowed_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        """
        max_age_seconds: NotRequired[pulumi.Input[int]]
        """
        The time in seconds that browser can cache the response for a preflight request.
        """
elif False:
    SpacesBucketCorsRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketCorsRuleArgs:
    def __init__(__self__, *,
                 allowed_methods: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_origins: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allowed_headers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 max_age_seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_methods: A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_origins: A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_headers: A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        :param pulumi.Input[int] max_age_seconds: The time in seconds that browser can cache the response for a preflight request.
        """
        pulumi.set(__self__, "allowed_methods", allowed_methods)
        pulumi.set(__self__, "allowed_origins", allowed_origins)
        if allowed_headers is not None:
            pulumi.set(__self__, "allowed_headers", allowed_headers)
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)

    @property
    @pulumi.getter(name="allowedMethods")
    def allowed_methods(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of HTTP methods (e.g. `GET`) which are allowed from the specified origin.
        """
        return pulumi.get(self, "allowed_methods")

    @allowed_methods.setter
    def allowed_methods(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_methods", value)

    @property
    @pulumi.getter(name="allowedOrigins")
    def allowed_origins(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of hosts from which requests using the specified methods are allowed. A host may contain one wildcard (e.g. http://*.example.com).
        """
        return pulumi.get(self, "allowed_origins")

    @allowed_origins.setter
    def allowed_origins(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "allowed_origins", value)

    @property
    @pulumi.getter(name="allowedHeaders")
    def allowed_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of headers that will be included in the CORS preflight request's `Access-Control-Request-Headers`. A header may contain one wildcard (e.g. `x-amz-*`).
        """
        return pulumi.get(self, "allowed_headers")

    @allowed_headers.setter
    def allowed_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_headers", value)

    @property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[int]]:
        """
        The time in seconds that browser can cache the response for a preflight request.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_age_seconds", value)


if not MYPY:
    class SpacesBucketLifecycleRuleArgsDict(TypedDict):
        enabled: pulumi.Input[bool]
        """
        Specifies lifecycle rule status.
        """
        abort_incomplete_multipart_upload_days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days after initiating a multipart
        upload when the multipart upload must be completed or else Spaces will abort the upload.
        """
        expiration: NotRequired[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgsDict']]
        """
        Specifies a time period after which applicable objects expire (documented below).
        """
        id: NotRequired[pulumi.Input[str]]
        """
        Unique identifier for the rule.
        """
        noncurrent_version_expiration: NotRequired[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgsDict']]
        """
        Specifies when non-current object versions expire (documented below).

        At least one of `expiration` or `noncurrent_version_expiration` must be specified.
        """
        prefix: NotRequired[pulumi.Input[str]]
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
elif False:
    SpacesBucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 abort_incomplete_multipart_upload_days: Optional[pulumi.Input[int]] = None,
                 expiration: Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']] = None,
                 id: Optional[pulumi.Input[str]] = None,
                 noncurrent_version_expiration: Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']] = None,
                 prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] enabled: Specifies lifecycle rule status.
        :param pulumi.Input[int] abort_incomplete_multipart_upload_days: Specifies the number of days after initiating a multipart
               upload when the multipart upload must be completed or else Spaces will abort the upload.
        :param pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs'] expiration: Specifies a time period after which applicable objects expire (documented below).
        :param pulumi.Input[str] id: Unique identifier for the rule.
        :param pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs'] noncurrent_version_expiration: Specifies when non-current object versions expire (documented below).
               
               At least one of `expiration` or `noncurrent_version_expiration` must be specified.
        :param pulumi.Input[str] prefix: Object key prefix identifying one or more objects to which the rule applies.
        """
        pulumi.set(__self__, "enabled", enabled)
        if abort_incomplete_multipart_upload_days is not None:
            pulumi.set(__self__, "abort_incomplete_multipart_upload_days", abort_incomplete_multipart_upload_days)
        if expiration is not None:
            pulumi.set(__self__, "expiration", expiration)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if noncurrent_version_expiration is not None:
            pulumi.set(__self__, "noncurrent_version_expiration", noncurrent_version_expiration)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Specifies lifecycle rule status.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="abortIncompleteMultipartUploadDays")
    def abort_incomplete_multipart_upload_days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after initiating a multipart
        upload when the multipart upload must be completed or else Spaces will abort the upload.
        """
        return pulumi.get(self, "abort_incomplete_multipart_upload_days")

    @abort_incomplete_multipart_upload_days.setter
    def abort_incomplete_multipart_upload_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "abort_incomplete_multipart_upload_days", value)

    @property
    @pulumi.getter
    def expiration(self) -> Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']]:
        """
        Specifies a time period after which applicable objects expire (documented below).
        """
        return pulumi.get(self, "expiration")

    @expiration.setter
    def expiration(self, value: Optional[pulumi.Input['SpacesBucketLifecycleRuleExpirationArgs']]):
        pulumi.set(self, "expiration", value)

    @property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for the rule.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter(name="noncurrentVersionExpiration")
    def noncurrent_version_expiration(self) -> Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']]:
        """
        Specifies when non-current object versions expire (documented below).

        At least one of `expiration` or `noncurrent_version_expiration` must be specified.
        """
        return pulumi.get(self, "noncurrent_version_expiration")

    @noncurrent_version_expiration.setter
    def noncurrent_version_expiration(self, value: Optional[pulumi.Input['SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs']]):
        pulumi.set(self, "noncurrent_version_expiration", value)

    @property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[str]]:
        """
        Object key prefix identifying one or more objects to which the rule applies.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class SpacesBucketLifecycleRuleExpirationArgsDict(TypedDict):
        date: NotRequired[pulumi.Input[str]]
        """
        Specifies the date/time after which you want applicable objects to expire. The argument uses
        RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        """
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days after object creation when the applicable objects will expire.
        """
        expired_object_delete_marker: NotRequired[pulumi.Input[bool]]
        """
        On a versioned bucket (versioning-enabled or versioning-suspended
        bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
elif False:
    SpacesBucketLifecycleRuleExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketLifecycleRuleExpirationArgs:
    def __init__(__self__, *,
                 date: Optional[pulumi.Input[str]] = None,
                 days: Optional[pulumi.Input[int]] = None,
                 expired_object_delete_marker: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] date: Specifies the date/time after which you want applicable objects to expire. The argument uses
               RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        :param pulumi.Input[int] days: Specifies the number of days after object creation when the applicable objects will expire.
        :param pulumi.Input[bool] expired_object_delete_marker: On a versioned bucket (versioning-enabled or versioning-suspended
               bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
        if date is not None:
            pulumi.set(__self__, "date", date)
        if days is not None:
            pulumi.set(__self__, "days", days)
        if expired_object_delete_marker is not None:
            pulumi.set(__self__, "expired_object_delete_marker", expired_object_delete_marker)

    @property
    @pulumi.getter
    def date(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the date/time after which you want applicable objects to expire. The argument uses
        RFC3339 format, e.g. "2020-03-22T15:03:55Z" or parts thereof e.g. "2019-02-28".
        """
        return pulumi.get(self, "date")

    @date.setter
    def date(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "date", value)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after object creation when the applicable objects will expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter(name="expiredObjectDeleteMarker")
    def expired_object_delete_marker(self) -> Optional[pulumi.Input[bool]]:
        """
        On a versioned bucket (versioning-enabled or versioning-suspended
        bucket), setting this to true directs Spaces to delete expired object delete markers.
        """
        return pulumi.get(self, "expired_object_delete_marker")

    @expired_object_delete_marker.setter
    def expired_object_delete_marker(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "expired_object_delete_marker", value)


if not MYPY:
    class SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[int]]
        """
        Specifies the number of days after which an object's non-current versions expire.
        """
elif False:
    SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketLifecycleRuleNoncurrentVersionExpirationArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] days: Specifies the number of days after which an object's non-current versions expire.
        """
        if days is not None:
            pulumi.set(__self__, "days", days)

    @property
    @pulumi.getter
    def days(self) -> Optional[pulumi.Input[int]]:
        """
        Specifies the number of days after which an object's non-current versions expire.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "days", value)


if not MYPY:
    class SpacesBucketVersioningArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[bool]]
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
        state. You can, however, suspend versioning on that bucket.
        """
elif False:
    SpacesBucketVersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpacesBucketVersioningArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
               state. You can, however, suspend versioning on that bucket.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable versioning. Once you version-enable a bucket, it can never return to an unversioned
        state. You can, however, suspend versioning on that bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class UptimeAlertNotificationArgsDict(TypedDict):
        emails: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of email addresses to sent notifications to.
        """
        slacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['UptimeAlertNotificationSlackArgsDict']]]]
elif False:
    UptimeAlertNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeAlertNotificationArgs:
    def __init__(__self__, *,
                 emails: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 slacks: Optional[pulumi.Input[Sequence[pulumi.Input['UptimeAlertNotificationSlackArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] emails: List of email addresses to sent notifications to.
        """
        if emails is not None:
            pulumi.set(__self__, "emails", emails)
        if slacks is not None:
            pulumi.set(__self__, "slacks", slacks)

    @property
    @pulumi.getter
    def emails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of email addresses to sent notifications to.
        """
        return pulumi.get(self, "emails")

    @emails.setter
    def emails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "emails", value)

    @property
    @pulumi.getter
    def slacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['UptimeAlertNotificationSlackArgs']]]]:
        return pulumi.get(self, "slacks")

    @slacks.setter
    def slacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['UptimeAlertNotificationSlackArgs']]]]):
        pulumi.set(self, "slacks", value)


if not MYPY:
    class UptimeAlertNotificationSlackArgsDict(TypedDict):
        channel: pulumi.Input[str]
        """
        The Slack channel to send alerts to.
        """
        url: pulumi.Input[str]
        """
        The webhook URL for Slack.
        """
elif False:
    UptimeAlertNotificationSlackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class UptimeAlertNotificationSlackArgs:
    def __init__(__self__, *,
                 channel: pulumi.Input[str],
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] channel: The Slack channel to send alerts to.
        :param pulumi.Input[str] url: The webhook URL for Slack.
        """
        pulumi.set(__self__, "channel", channel)
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def channel(self) -> pulumi.Input[str]:
        """
        The Slack channel to send alerts to.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: pulumi.Input[str]):
        pulumi.set(self, "channel", value)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The webhook URL for Slack.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class GetAppDedicatedIpArgsDict(TypedDict):
        id: str
        """
        The ID of the dedicated egress IP.
        """
        ip: str
        """
        The IP address of the dedicated egress IP.
        """
        status: str
        """
        The status of the dedicated egress IP.
        """
elif False:
    GetAppDedicatedIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetAppDedicatedIpArgs:
    def __init__(__self__, *,
                 id: str,
                 ip: str,
                 status: str):
        """
        :param str id: The ID of the dedicated egress IP.
        :param str ip: The IP address of the dedicated egress IP.
        :param str status: The status of the dedicated egress IP.
        """
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "ip", ip)
        pulumi.set(__self__, "status", status)

    @property
    @pulumi.getter
    def id(self) -> str:
        """
        The ID of the dedicated egress IP.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: str):
        pulumi.set(self, "id", value)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        The IP address of the dedicated egress IP.
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: str):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def status(self) -> str:
        """
        The status of the dedicated egress IP.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: str):
        pulumi.set(self, "status", value)


if not MYPY:
    class GetDomainsFilterArgsDict(TypedDict):
        key: str
        """
        Filter the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        values: Sequence[str]
        """
        A list of values to match against the `key` field. Only retrieves domains
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetDomainsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDomainsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        :param Sequence[str] values: A list of values to match against the `key` field. Only retrieves domains
               where the `key` field takes on one or more of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match against the `key` field. Only retrieves domains
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetDomainsSortArgsDict(TypedDict):
        key: str
        """
        Sort the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetDomainsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDomainsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the domains by this key. This may be one of `name`, `urn`, and `ttl`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetDropletsFilterArgsDict(TypedDict):
        key: str
        """
        Filter the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`.
        """
        values: Sequence[str]
        """
        A list of values to match against the `key` field. Only retrieves Droplets
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetDropletsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDropletsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
               `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
               `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
               `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`.
        :param Sequence[str] values: A list of values to match against the `key` field. Only retrieves Droplets
               where the `key` field takes on one or more of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `tags`, `urn`, `vcpus`, `volume_ids`, or `vpc_uuid`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match against the `key` field. Only retrieves Droplets
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetDropletsSortArgsDict(TypedDict):
        key: str
        """
        Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `urn`, `vcpus`, or `vpc_uuid`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetDropletsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetDropletsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
               `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
               `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
               `status`, `urn`, `vcpus`, or `vpc_uuid`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the Droplets by this key. This may be one of `backups`, `created_at`, `disk`, `id`,
        `image`, `ipv4_address`, `ipv4_address_private`, `ipv6`, `ipv6_address`, `ipv6_address_private`, `locked`,
        `memory`, `monitoring`, `name`, `price_hourly`, `price_monthly`, `private_networking`, `region`, `size`,
        `status`, `urn`, `vcpus`, or `vpc_uuid`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetFirewallInboundRuleArgsDict(TypedDict):
        protocol: str
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        port_range: NotRequired[str]
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        source_addresses: NotRequired[Sequence[str]]
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        source_droplet_ids: NotRequired[Sequence[int]]
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        source_kubernetes_ids: NotRequired[Sequence[str]]
        source_load_balancer_uids: NotRequired[Sequence[str]]
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        source_tags: NotRequired[Sequence[str]]
        """
        A set of names of Tags corresponding to group of
        Droplets from which the inbound traffic will be accepted.
        """
elif False:
    GetFirewallInboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFirewallInboundRuleArgs:
    def __init__(__self__, *,
                 protocol: str,
                 port_range: Optional[str] = None,
                 source_addresses: Optional[Sequence[str]] = None,
                 source_droplet_ids: Optional[Sequence[int]] = None,
                 source_kubernetes_ids: Optional[Sequence[str]] = None,
                 source_load_balancer_uids: Optional[Sequence[str]] = None,
                 source_tags: Optional[Sequence[str]] = None):
        """
        :param str protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param str port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        :param Sequence[str] source_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
               inbound traffic will be accepted.
        :param Sequence[int] source_droplet_ids: An array containing the IDs of
               the Droplets from which the inbound traffic will be accepted.
        :param Sequence[str] source_load_balancer_uids: An array containing the IDs
               of the Load Balancers from which the inbound traffic will be accepted.
        :param Sequence[str] source_tags: A set of names of Tags corresponding to group of
               Droplets from which the inbound traffic will be accepted.
        """
        pulumi.set(__self__, "protocol", protocol)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)
        if source_addresses is not None:
            pulumi.set(__self__, "source_addresses", source_addresses)
        if source_droplet_ids is not None:
            pulumi.set(__self__, "source_droplet_ids", source_droplet_ids)
        if source_kubernetes_ids is not None:
            pulumi.set(__self__, "source_kubernetes_ids", source_kubernetes_ids)
        if source_load_balancer_uids is not None:
            pulumi.set(__self__, "source_load_balancer_uids", source_load_balancer_uids)
        if source_tags is not None:
            pulumi.set(__self__, "source_tags", source_tags)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: str):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[str]):
        pulumi.set(self, "port_range", value)

    @property
    @pulumi.getter(name="sourceAddresses")
    def source_addresses(self) -> Optional[Sequence[str]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs from which the
        inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_addresses")

    @source_addresses.setter
    def source_addresses(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "source_addresses", value)

    @property
    @pulumi.getter(name="sourceDropletIds")
    def source_droplet_ids(self) -> Optional[Sequence[int]]:
        """
        An array containing the IDs of
        the Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_droplet_ids")

    @source_droplet_ids.setter
    def source_droplet_ids(self, value: Optional[Sequence[int]]):
        pulumi.set(self, "source_droplet_ids", value)

    @property
    @pulumi.getter(name="sourceKubernetesIds")
    def source_kubernetes_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "source_kubernetes_ids")

    @source_kubernetes_ids.setter
    def source_kubernetes_ids(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "source_kubernetes_ids", value)

    @property
    @pulumi.getter(name="sourceLoadBalancerUids")
    def source_load_balancer_uids(self) -> Optional[Sequence[str]]:
        """
        An array containing the IDs
        of the Load Balancers from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_load_balancer_uids")

    @source_load_balancer_uids.setter
    def source_load_balancer_uids(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "source_load_balancer_uids", value)

    @property
    @pulumi.getter(name="sourceTags")
    def source_tags(self) -> Optional[Sequence[str]]:
        """
        A set of names of Tags corresponding to group of
        Droplets from which the inbound traffic will be accepted.
        """
        return pulumi.get(self, "source_tags")

    @source_tags.setter
    def source_tags(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "source_tags", value)


if not MYPY:
    class GetFirewallOutboundRuleArgsDict(TypedDict):
        protocol: str
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        destination_addresses: NotRequired[Sequence[str]]
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        destination_droplet_ids: NotRequired[Sequence[int]]
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        destination_kubernetes_ids: NotRequired[Sequence[str]]
        destination_load_balancer_uids: NotRequired[Sequence[str]]
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        destination_tags: NotRequired[Sequence[str]]
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        traffic.
        """
        port_range: NotRequired[str]
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
elif False:
    GetFirewallOutboundRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetFirewallOutboundRuleArgs:
    def __init__(__self__, *,
                 protocol: str,
                 destination_addresses: Optional[Sequence[str]] = None,
                 destination_droplet_ids: Optional[Sequence[int]] = None,
                 destination_kubernetes_ids: Optional[Sequence[str]] = None,
                 destination_load_balancer_uids: Optional[Sequence[str]] = None,
                 destination_tags: Optional[Sequence[str]] = None,
                 port_range: Optional[str] = None):
        """
        :param str protocol: The type of traffic to be allowed.
               This may be one of "tcp", "udp", or "icmp".
        :param Sequence[str] destination_addresses: An array of strings containing the IPv4
               addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
               outbound traffic will be allowed.
        :param Sequence[int] destination_droplet_ids: An array containing the IDs of
               the Droplets to which the outbound traffic will be allowed.
        :param Sequence[str] destination_load_balancer_uids: An array containing the IDs
               of the Load Balancers to which the outbound traffic will be allowed.
        :param Sequence[str] destination_tags: An array containing the names of Tags
               corresponding to groups of Droplets to which the outbound traffic will
               be allowed.
               traffic.
        :param str port_range: The ports on which traffic will be allowed
               specified as a string containing a single port, a range (e.g. "8000-9000"),
               or "1-65535" to open all ports for a protocol. Required for when protocol is
               `tcp` or `udp`.
        """
        pulumi.set(__self__, "protocol", protocol)
        if destination_addresses is not None:
            pulumi.set(__self__, "destination_addresses", destination_addresses)
        if destination_droplet_ids is not None:
            pulumi.set(__self__, "destination_droplet_ids", destination_droplet_ids)
        if destination_kubernetes_ids is not None:
            pulumi.set(__self__, "destination_kubernetes_ids", destination_kubernetes_ids)
        if destination_load_balancer_uids is not None:
            pulumi.set(__self__, "destination_load_balancer_uids", destination_load_balancer_uids)
        if destination_tags is not None:
            pulumi.set(__self__, "destination_tags", destination_tags)
        if port_range is not None:
            pulumi.set(__self__, "port_range", port_range)

    @property
    @pulumi.getter
    def protocol(self) -> str:
        """
        The type of traffic to be allowed.
        This may be one of "tcp", "udp", or "icmp".
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: str):
        pulumi.set(self, "protocol", value)

    @property
    @pulumi.getter(name="destinationAddresses")
    def destination_addresses(self) -> Optional[Sequence[str]]:
        """
        An array of strings containing the IPv4
        addresses, IPv6 addresses, IPv4 CIDRs, and/or IPv6 CIDRs to which the
        outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_addresses")

    @destination_addresses.setter
    def destination_addresses(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "destination_addresses", value)

    @property
    @pulumi.getter(name="destinationDropletIds")
    def destination_droplet_ids(self) -> Optional[Sequence[int]]:
        """
        An array containing the IDs of
        the Droplets to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_droplet_ids")

    @destination_droplet_ids.setter
    def destination_droplet_ids(self, value: Optional[Sequence[int]]):
        pulumi.set(self, "destination_droplet_ids", value)

    @property
    @pulumi.getter(name="destinationKubernetesIds")
    def destination_kubernetes_ids(self) -> Optional[Sequence[str]]:
        return pulumi.get(self, "destination_kubernetes_ids")

    @destination_kubernetes_ids.setter
    def destination_kubernetes_ids(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "destination_kubernetes_ids", value)

    @property
    @pulumi.getter(name="destinationLoadBalancerUids")
    def destination_load_balancer_uids(self) -> Optional[Sequence[str]]:
        """
        An array containing the IDs
        of the Load Balancers to which the outbound traffic will be allowed.
        """
        return pulumi.get(self, "destination_load_balancer_uids")

    @destination_load_balancer_uids.setter
    def destination_load_balancer_uids(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "destination_load_balancer_uids", value)

    @property
    @pulumi.getter(name="destinationTags")
    def destination_tags(self) -> Optional[Sequence[str]]:
        """
        An array containing the names of Tags
        corresponding to groups of Droplets to which the outbound traffic will
        be allowed.
        traffic.
        """
        return pulumi.get(self, "destination_tags")

    @destination_tags.setter
    def destination_tags(self, value: Optional[Sequence[str]]):
        pulumi.set(self, "destination_tags", value)

    @property
    @pulumi.getter(name="portRange")
    def port_range(self) -> Optional[str]:
        """
        The ports on which traffic will be allowed
        specified as a string containing a single port, a range (e.g. "8000-9000"),
        or "1-65535" to open all ports for a protocol. Required for when protocol is
        `tcp` or `udp`.
        """
        return pulumi.get(self, "port_range")

    @port_range.setter
    def port_range(self, value: Optional[str]):
        pulumi.set(self, "port_range", value)


if not MYPY:
    class GetImagesFilterArgsDict(TypedDict):
        key: str
        """
        Filter the images by this key. This may be one of `distribution`, `error_message`,
        `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
        `tags`, or `type`.
        """
        values: Sequence[str]
        """
        A list of values to match against the `key` field. Only retrieves images
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetImagesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagesFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the images by this key. This may be one of `distribution`, `error_message`,
               `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
               `tags`, or `type`.
        :param Sequence[str] values: A list of values to match against the `key` field. Only retrieves images
               where the `key` field takes on one or more of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the images by this key. This may be one of `distribution`, `error_message`,
        `id`, `image`, `min_disk_size`, `name`, `private`, `regions`, `size_gigabytes`, `slug`, `status`,
        `tags`, or `type`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match against the `key` field. Only retrieves images
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetImagesSortArgsDict(TypedDict):
        key: str
        """
        Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
        `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetImagesSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetImagesSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
               `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the images by this key. This may be one of `distribution`, `error_message`, `id`,
        `image`, `min_disk_size`, `name`, `private`, `size_gigabytes`, `slug`, `status`, or `type`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetProjectsFilterArgsDict(TypedDict):
        key: str
        """
        Filter the projects by this key. This may be one of `name`,
        `purpose`, `description`, `environment`, or `is_default`.
        """
        values: Sequence[str]
        """
        A list of values to match against the `key` field. Only retrieves projects
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetProjectsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the projects by this key. This may be one of `name`,
               `purpose`, `description`, `environment`, or `is_default`.
        :param Sequence[str] values: A list of values to match against the `key` field. Only retrieves projects
               where the `key` field takes on one or more of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the projects by this key. This may be one of `name`,
        `purpose`, `description`, `environment`, or `is_default`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match against the `key` field. Only retrieves projects
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetProjectsSortArgsDict(TypedDict):
        key: str
        """
        Sort the projects by this key. This may be one of `name`,
        `purpose`, `description`, or `environment`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetProjectsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetProjectsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the projects by this key. This may be one of `name`,
               `purpose`, `description`, or `environment`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the projects by this key. This may be one of `name`,
        `purpose`, `description`, or `environment`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetRecordsFilterArgsDict(TypedDict):
        key: str
        """
        Filter the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        values: Sequence[str]
        """
        A list of values to match against the `key` field. Only retrieves DNS records
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetRecordsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRecordsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
               `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        :param Sequence[str] values: A list of values to match against the `key` field. Only retrieves DNS records
               where the `key` field takes on one or more of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match against the `key` field. Only retrieves DNS records
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetRecordsSortArgsDict(TypedDict):
        key: str
        """
        Sort the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetRecordsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRecordsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
               `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the DNS records by this key. This may be one of `domain`, `flags`, `name`, `port`,
        `priority`, `tag`, `ttl`, `type`, `value`, or `weight`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetRegionsFilterArgsDict(TypedDict):
        key: str
        """
        Filter the regions by this key. This may be one of `slug`,
        `name`, `available`, `features`, or `sizes`.
        """
        values: Sequence[str]
        """
        A list of values to match against the `key` field. Only retrieves regions
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetRegionsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegionsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the regions by this key. This may be one of `slug`,
               `name`, `available`, `features`, or `sizes`.
        :param Sequence[str] values: A list of values to match against the `key` field. Only retrieves regions
               where the `key` field takes on one or more of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the regions by this key. This may be one of `slug`,
        `name`, `available`, `features`, or `sizes`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match against the `key` field. Only retrieves regions
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetRegionsSortArgsDict(TypedDict):
        key: str
        """
        Sort the regions by this key. This may be one of `slug`,
        `name`, or `available`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetRegionsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetRegionsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the regions by this key. This may be one of `slug`,
               `name`, or `available`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the regions by this key. This may be one of `slug`,
        `name`, or `available`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetSizesFilterArgsDict(TypedDict):
        key: str
        """
        Filter the sizes by this key. This may be one of `slug`,
        `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
        `price_hourly`, or `available`.
        """
        values: Sequence[str]
        """
        Only retrieves sizes which keys has value that matches
        one of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetSizesFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSizesFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the sizes by this key. This may be one of `slug`,
               `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
               `price_hourly`, or `available`.
        :param Sequence[str] values: Only retrieves sizes which keys has value that matches
               one of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the sizes by this key. This may be one of `slug`,
        `regions`, `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`,
        `price_hourly`, or `available`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves sizes which keys has value that matches
        one of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetSizesSortArgsDict(TypedDict):
        key: str
        """
        Sort the sizes by this key. This may be one of `slug`,
        `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetSizesSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSizesSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the sizes by this key. This may be one of `slug`,
               `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the sizes by this key. This may be one of `slug`,
        `memory`, `vcpus`, `disk`, `transfer`, `price_monthly`, or `price_hourly`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetSpacesBucketsFilterArgsDict(TypedDict):
        key: str
        """
        Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        values: Sequence[str]
        """
        A list of values to match against the `key` field. Only retrieves Spaces buckets
        where the `key` field takes on one or more of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetSpacesBucketsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSpacesBucketsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        :param Sequence[str] values: A list of values to match against the `key` field. Only retrieves Spaces buckets
               where the `key` field takes on one or more of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match against the `key` field. Only retrieves Spaces buckets
        where the `key` field takes on one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetSpacesBucketsSortArgsDict(TypedDict):
        key: str
        """
        Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetSpacesBucketsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSpacesBucketsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the images by this key. This may be one of `bucket_domain_name`, `name`, `region`, or `urn`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetSshKeysFilterArgsDict(TypedDict):
        key: str
        """
        Filter the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        values: Sequence[str]
        """
        A list of values to match against the key field. Only retrieves SSH keys where the key field matches one or more of the values provided here.
        """
        all: NotRequired[bool]
        match_by: NotRequired[str]
elif False:
    GetSshKeysFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSshKeysFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        :param Sequence[str] values: A list of values to match against the key field. Only retrieves SSH keys where the key field matches one or more of the values provided here.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        A list of values to match against the key field. Only retrieves SSH keys where the key field matches one or more of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetSshKeysSortArgsDict(TypedDict):
        key: str
        """
        Sort the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetSshKeysSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetSshKeysSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the SSH Keys by this key. This may be one of `name`, `public_key`, or `fingerprint`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


if not MYPY:
    class GetTagsFilterArgsDict(TypedDict):
        key: str
        """
        Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        values: Sequence[str]
        """
        Only retrieves tags which keys has value that matches
        one of the values provided here.
        """
        all: NotRequired[bool]
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        match_by: NotRequired[str]
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
elif False:
    GetTagsFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsFilterArgs:
    def __init__(__self__, *,
                 key: str,
                 values: Sequence[str],
                 all: Optional[bool] = None,
                 match_by: Optional[str] = None):
        """
        :param str key: Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        :param Sequence[str] values: Only retrieves tags which keys has value that matches
               one of the values provided here.
        :param bool all: Set to `true` to require that a field match all of the `values` instead of just one or more of
               them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
               that all of the `values` are present in the list or set.
        :param str match_by: One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
               match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
               substrings to find within the string field.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "values", values)
        if all is not None:
            pulumi.set(__self__, "all", all)
        if match_by is not None:
            pulumi.set(__self__, "match_by", match_by)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Filter the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def values(self) -> Sequence[str]:
        """
        Only retrieves tags which keys has value that matches
        one of the values provided here.
        """
        return pulumi.get(self, "values")

    @values.setter
    def values(self, value: Sequence[str]):
        pulumi.set(self, "values", value)

    @property
    @pulumi.getter
    def all(self) -> Optional[bool]:
        """
        Set to `true` to require that a field match all of the `values` instead of just one or more of
        them. This is useful when matching against multi-valued fields such as lists or sets where you want to ensure
        that all of the `values` are present in the list or set.
        """
        return pulumi.get(self, "all")

    @all.setter
    def all(self, value: Optional[bool]):
        pulumi.set(self, "all", value)

    @property
    @pulumi.getter(name="matchBy")
    def match_by(self) -> Optional[str]:
        """
        One of `exact` (default), `re`, or `substring`. For string-typed fields, specify `re` to
        match by using the `values` as regular expressions, or specify `substring` to match by treating the `values` as
        substrings to find within the string field.
        """
        return pulumi.get(self, "match_by")

    @match_by.setter
    def match_by(self, value: Optional[str]):
        pulumi.set(self, "match_by", value)


if not MYPY:
    class GetTagsSortArgsDict(TypedDict):
        key: str
        """
        Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        direction: NotRequired[str]
        """
        The sort direction. This may be either `asc` or `desc`.
        """
elif False:
    GetTagsSortArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GetTagsSortArgs:
    def __init__(__self__, *,
                 key: str,
                 direction: Optional[str] = None):
        """
        :param str key: Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        :param str direction: The sort direction. This may be either `asc` or `desc`.
        """
        pulumi.set(__self__, "key", key)
        if direction is not None:
            pulumi.set(__self__, "direction", direction)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Sort the tags by this key. This may be one of `name`, `total_resource_count`,  `droplets_count`, `images_count`, `volumes_count`, `volume_snapshots_count`, or `databases_count`.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: str):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def direction(self) -> Optional[str]:
        """
        The sort direction. This may be either `asc` or `desc`.
        """
        return pulumi.get(self, "direction")

    @direction.setter
    def direction(self, value: Optional[str]):
        pulumi.set(self, "direction", value)


